<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Beatrider • Spotify Mode</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script src="https://sdk.scdn.co/spotify-player.js"></script>
  <style>
    :root { --fg:#0f0; --fg2:#9f9; --bg:#000; }
    html,body { height:100%;}
    body { margin:0; background:var(--bg); color:var(--fg); font:14px/1.4 monospace; }
    #ui { position:absolute; left:10px; top:10px; background:rgba(0,0,0,.6); padding:10px; border:1px solid var(--fg); border-radius:6px; width:560px; max-width:calc(100% - 20px); z-index:10; }
    #ui input[type="text"], #ui input[type="url"] { width: 360px; }
    #ui input[type="number"] { width: 90px; }
    #led { display:inline-block; width:10px; height:10px; margin-left:6px; background:#030; border:1px solid var(--fg); vertical-align:middle; }
    button { cursor:pointer; }
    .row { margin:6px 0; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .muted { color:var(--fg2); }
    .small { font-size:12px; }
    #log { max-height:110px; overflow:auto; border:1px solid #083; padding:6px; font-size:12px; background:#010; }
  </style>
</head>
<body>
<div id="ui">
  <div class="row"><strong>Spotify Mode Demo</strong> <span class="muted small">• Premium required for playback • HTTPS/127.0.0.1 only</span></div>

  <div class="row">
    <button id="loginBtn">Log in with Spotify</button>
    <span id="authState" class="muted"></span>
  </div>

  <div class="row small">
    <label>Calibration (ms)
      <input id="calib" type="number" value="0" step="5" />
    </label>
    <span id="beatInfo" class="muted">Beats: 0</span>
    <span id="led" title="Beat LED"></span>
  </div>

  <div class="row">
    <input id="spotifyUrl" type="url" placeholder="Paste a Spotify track or playlist URL (e.g. https://open.spotify.com/track/...)" />
    <button id="loadBtn">Load</button>
  </div>

  <div class="row">
    <button id="playBtn">Play</button>
    <button id="pauseBtn">Pause</button>
    <span id="nowplay" class="muted small"></span>
  </div>

  <div class="row small">
    <span>Device: <span id="deviceName" class="muted">(starting…)</span></span>
    <span>SDK: <span id="sdkState" class="muted">waiting</span></span>
  </div>

  <div id="log" class="small"></div>

  <div class="row small muted">
    <details>
      <summary>Setup notes</summary>
      <div>
        1) In Spotify Dashboard, set Redirect URI to <code><span id="redirHint"></span></code><br/>
        2) Paste your Client ID below (temporary) and click Login.<br/>
      </div>
      <label>Client ID <input id="clientId" type="text" placeholder="YOUR_SPOTIFY_CLIENT_ID"/></label>
    </details>
  </div>
</div>

<script>
/*******************
 * CONFIG / PKCE AUTH
 *******************/
const REDIRECT_URI = (location.protocol+"//"+location.host+location.pathname).replace(/[#?].*$/,'');
const SCOPES = [
  'streaming',
  'user-read-email',
  'user-read-private',
  'user-read-playback-state',
  'user-modify-playback-state',
  'playlist-read-private',
  'playlist-read-collaborative'
];

const els = (id => document.getElementById(id));
const logEl = els('log');
function log(msg){ const t=document.createElement('div'); t.textContent=msg; logEl.prepend(t); }
function setText(id, txt){ els(id).textContent = txt; }
setText('redirHint', REDIRECT_URI);

function base64url(arraybuffer){
  let str = btoa(String.fromCharCode.apply(null, new Uint8Array(arraybuffer)));
  return str.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}
async function sha256(verifier){
  const enc = new TextEncoder().encode(verifier);
  return await crypto.subtle.digest('SHA-256', enc);
}
function randString(len=64){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
  let out=''; for(let i=0;i<len;i++) out+=chars[Math.floor(Math.random()*chars.length)];
  return out;
}

function saveToken(tok){ localStorage.setItem('spotify_token', JSON.stringify({ ...tok, ts: Date.now() })); }
function loadToken(){ try{ const t=JSON.parse(localStorage.getItem('spotify_token')||'null'); return t; }catch{return null;} }
function clearToken(){ localStorage.removeItem('spotify_token'); }

async function startAuth(clientId){
  const verifier = randString(64);
  const challenge = base64url(await sha256(verifier));
  localStorage.setItem('pkce_verifier', verifier);
  const url = new URL('https://accounts.spotify.com/authorize');
  url.searchParams.set('client_id', clientId);
  url.searchParams.set('response_type', 'code');
  url.searchParams.set('redirect_uri', REDIRECT_URI);
  url.searchParams.set('code_challenge_method', 'S256');
  url.searchParams.set('code_challenge', challenge);
  url.searchParams.set('scope', SCOPES.join(' '));
  location.assign(url.toString());
}

async function finishAuth(clientId){
  const params = new URLSearchParams(location.search);
  const code = params.get('code');
  if(!code) return null;
  const verifier = localStorage.getItem('pkce_verifier');
  if(!verifier){ log('Missing PKCE verifier.'); return null; }
  const body = new URLSearchParams();
  body.set('client_id', clientId);
  body.set('grant_type', 'authorization_code');
  body.set('code', code);
  body.set('redirect_uri', REDIRECT_URI);
  body.set('code_verifier', verifier);
  const res = await fetch('https://accounts.spotify.com/api/token', { method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'}, body });
  if(!res.ok){ log('Token exchange failed: '+res.status); return null; }
  const tok = await res.json();
  saveToken(tok);
  // cleanup query string
  history.replaceState({}, '', REDIRECT_URI);
  return tok;
}

async function refreshToken(clientId){
  const tok = loadToken();
  if(!tok || !tok.refresh_token) return null;
  const body = new URLSearchParams();
  body.set('client_id', clientId);
  body.set('grant_type', 'refresh_token');
  body.set('refresh_token', tok.refresh_token);
  const res = await fetch('https://accounts.spotify.com/api/token', { method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'}, body });
  if(!res.ok){ clearToken(); return null; }
  const n = await res.json();
  const merged = { ...tok, ...n };
  saveToken(merged);
  return merged;
}

/*******************
 * SPOTIFY SDK + WEB API
 *******************/
let player, deviceId, accessToken, userPremium=false;
let sdkReady = false;
let sdkReadyResolve = null;

// Define the callback immediately for when SDK loads
window.onSpotifyWebPlaybackSDKReady = () => {
  sdkReady = true;
  if (sdkReadyResolve) sdkReadyResolve();
};

function getAuthHeader(){ return { 'Authorization': 'Bearer '+accessToken }; }

async function api(path, opts={}){
  const res = await fetch('https://api.spotify.com/v1'+path, { ...opts, headers: { 'Content-Type':'application/json', ...getAuthHeader(), ...(opts.headers||{}) } });
  
  if(res.status===401){ // try refresh once
    log('Token expired, attempting refresh...');
    const cid = els('clientId').value.trim() || window.ENV?.SPOTIFY_CLIENT_ID;
    const nt = await refreshToken(cid);
    if(nt){ 
      accessToken = nt.access_token; 
      log('Token refreshed successfully');
      return api(path, opts); 
    }
    log('Token refresh failed - please login again');
    throw new Error('Authentication failed');
  }
  
  // Handle 204 No Content (successful but no response body)
  if(res.status === 204 || res.status === 202) {
    return null;
  }
  
  // Read the response body
  const text = await res.text();
  
  if(!res.ok) {
    console.error('API error response:', text);
    throw new Error(`API ${path} -> ${res.status}: ${text.substring(0, 100)}`);
  }
  
  // Empty response is ok for some endpoints
  if(!text || text.trim() === '') {
    return null;
  }
  
  // Try to parse JSON
  try {
    return JSON.parse(text);
  } catch(e) {
    console.error('Failed to parse API response as JSON:', text.substring(0, 200));
    throw new Error('API returned invalid JSON: ' + text.substring(0, 100));
  }
}

function parseSpotifyUrl(u){
  try{
    const url = new URL(u);
    const parts = url.pathname.split('/').filter(Boolean);
    const type = parts[0]; const id = parts[1];
    return { type, id };
  }catch{ return null; }
}

async function ensureDevice(){
  // Check if SDK is already loaded and player exists
  if(player && deviceId) {
    log('Device already initialized: '+deviceId);
    return;
  }
  
  return new Promise((resolve, reject)=>{
    // Set a timeout in case SDK doesn't initialize
    const timeout = setTimeout(() => {
      reject(new Error('SDK initialization timeout'));
    }, 10000);
    
    window.onSpotifyWebPlaybackSDKReady = () => {
      player = new Spotify.Player({
        name: 'Beatrider (Browser)',
        getOAuthToken: cb => cb(accessToken),
        volume: 0.8
      });

      player.addListener('ready', ({ device_id }) => { 
        clearTimeout(timeout);
        deviceId = device_id; 
        setText('deviceName', device_id.slice(0,8)+'…'); 
        log('SDK ready: device '+device_id); 
        resolve(); 
      });
      player.addListener('not_ready', ({ device_id }) => { log('Device went offline: '+device_id); });
      player.addListener('initialization_error', ({ message }) => { 
        clearTimeout(timeout);
        log('init error: '+message);
        reject(new Error('SDK init error: '+message));
      });
      player.addListener('authentication_error', ({ message }) => { 
        clearTimeout(timeout);
        log('auth error: '+message);
        reject(new Error('SDK auth error: '+message));
      });
      player.addListener('account_error', ({ message }) => { 
        clearTimeout(timeout);
        log('account error: '+message);
        reject(new Error('SDK account error: '+message));
      });

      player.connect().then(ok => { setText('sdkState', ok? 'connected':'failed'); });
    };
    
    // If SDK script is already loaded, trigger the ready callback
    if(window.Spotify && window.Spotify.Player) {
      window.onSpotifyWebPlaybackSDKReady();
    }
  });
}

async function transferPlayback(){
  await api('/me/player', { method:'PUT', body: JSON.stringify({ device_ids:[deviceId], play:false }) });
}

async function playUris(uris){
  await api(`/me/player/play?device_id=${deviceId}`, { method:'PUT', body: JSON.stringify({ uris }) });
}

async function playContext(context_uri){
  await api(`/me/player/play?device_id=${deviceId}`, { method:'PUT', body: JSON.stringify({ context_uri }) });
}

async function pause(){ await api('/me/player/pause?device_id='+deviceId, { method:'PUT' }); }

async function getPlayerState(){
  try{ return await player.getCurrentState(); }catch{ return null; }
}

/*******************
 * AUDIO ANALYSIS → BEAT DETECTION
 *******************/
let beatCounter = 0;
let calibrationMs = 0;
let audioContext = null;
let analyser = null;
let beatDetector = null;

function setCalibration(ms){ calibrationMs = (+ms)|0; }

// Beat detection using frequency analysis
class BeatDetector {
  constructor(analyser) {
    this.analyser = analyser;
    this.bufferLength = analyser.frequencyBinCount;
    this.dataArray = new Uint8Array(this.bufferLength);
    this.lastKick = 0;
    this.kickThreshold = 0;
    this.kickHistory = [];
    this.minTimeBetweenBeats = 300; // ms - prevents double triggers
  }
  
  detectBeat() {
    this.analyser.getByteFrequencyData(this.dataArray);
    
    // Focus on kick drum frequencies (60-130 Hz)
    // For 44100 Hz sample rate with 2048 FFT size: each bin = ~21.5 Hz
    let kickEnergy = 0;
    for(let i = 3; i < 7; i++) {
      kickEnergy += this.dataArray[i];
    }
    kickEnergy = kickEnergy / 4;
    
    // Adaptive threshold based on recent history
    this.kickHistory.push(kickEnergy);
    if(this.kickHistory.length > 43) { // ~1 second at 43fps
      this.kickHistory.shift();
    }
    
    const avgEnergy = this.kickHistory.reduce((a,b) => a+b, 0) / this.kickHistory.length;
    const threshold = avgEnergy * 1.5; // Beat is 50% above average
    
    const now = Date.now();
    if(kickEnergy > threshold && kickEnergy > 150 && (now - this.lastKick) > this.minTimeBetweenBeats) {
      this.lastKick = now;
      return true;
    }
    return false;
  }
}

async function setupAudioAnalysis(){
  try {
    // Create audio context and analyser
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.8;
    
    // Try to capture audio from the page
    // Note: This is a simplified version - in production you'd need to handle 
    // cross-origin issues and potentially use a different audio source
    const audioElement = document.querySelector('audio') || document.createElement('audio');
    const source = audioContext.createMediaElementSource(audioElement);
    source.connect(analyser);
    analyser.connect(audioContext.destination);
    
    beatDetector = new BeatDetector(analyser);
    log('Beat detector initialized');
    return true;
  } catch(err) {
    log('Could not setup audio analysis: ' + err.message);
    console.error('Audio setup error:', err);
    return false;
  }
}

function flashLED(){ const led=els('led'); led.style.background='#0f0'; setTimeout(()=>led.style.background='#030', 60); }

function startBeatDetection(){
  log('Starting real-time beat detection...');
  
  // Animation frame loop for beat detection
  let detecting = false;
  
  function detectLoop() {
    if(!beatDetector || !analyser) {
      requestAnimationFrame(detectLoop);
      return;
    }
    
    // Check if music is playing
    player.getCurrentState().then(state => {
      if(state && !state.paused && !detecting) {
        detecting = true;
        
        // Detect beat
        if(beatDetector.detectBeat()) {
          onBeat();
        }
        
        detecting = false;
      }
    });
    
    requestAnimationFrame(detectLoop);
  }
  
  detectLoop();
}

function onBeat(){
  beatCounter++; 
  flashLED(); 
  setText('beatInfo', 'Beats: '+beatCounter);
  console.log('Beat detected! Counter:', beatCounter, 'GameAPI exists:', !!window.GameAPI);
  // tell game to spawn on-beat
  if(window.GameAPI && typeof window.GameAPI.onBeat==='function') {
    window.GameAPI.onBeat();
  } else {
    console.warn('GameAPI.onBeat not available!');
  }
}

/*******************
 * SIMPLE 5-LANE GAME (manual movement, no physics)
 *******************/
(function(){
  const WIDTH=800, HEIGHT=600, LANES=5, LANE_W=WIDTH/LANES;
  const PLAYER_Y=HEIGHT-60, ENEMY_SPEED_BASE=200, BULLET_SPEED=520, FIRE_COOLDOWN=110;
  let sceneRef=null;

  class Main extends Phaser.Scene {
    create(){
      this.cameras.main.setBackgroundColor('#000');
      const g=this.add.graphics(); g.lineStyle(1,0x111111,1); for(let i=1;i<LANES;i++) g.lineBetween(i*LANE_W,0,i*LANE_W,HEIGHT);
      const gfx=this.make.graphics({x:0,y:0,add:false});
      gfx.fillStyle(0x00ffcc,1).fillRect(0,0,24,24).generateTexture('playerTex',24,24).clear();
      gfx.fillStyle(0xff3366,1).fillRect(0,0,20,20).generateTexture('enemyTex',20,20).clear();
      gfx.fillStyle(0xffffff,1).fillRect(0,0,6,12).generateTexture('bulletTex',6,12).clear();
      
      // Create purple blocker with glow effect (2x size of enemies)
      gfx.fillStyle(0xff00ff,0.3).fillCircle(20,20,22); // Outer glow
      gfx.fillStyle(0xcc66ff,0.6).fillCircle(20,20,18); // Mid glow
      gfx.fillStyle(0xbf40ff,1).fillCircle(20,20,14);   // Core
      gfx.generateTexture('blockerTex',40,40);
      gfx.destroy();

      this.playerLane=2; this.player=this.add.image(this._laneX(this.playerLane), PLAYER_Y, 'playerTex');
      this.enemies=[]; this.blockers=[]; this.bullets=[]; this.lastShotAt=0;
      this.keys=this.input.keyboard.addKeys('LEFT,RIGHT,A,D,SPACE');
      this.score=0; this.beats=0; this.scoreText=this.add.text(10, HEIGHT-24, 'score 0', {font:'16px monospace', fill:'#0f0'});

      window.GameAPI = {
        onBeat: ()=>{ 
          console.log('GameAPI.onBeat called, beat #', this.beats);
          this.beats++; 
          const speed=ENEMY_SPEED_BASE + Math.floor(this.beats/16)*30; 
          if(Math.random()<0.8){ 
            const lane = Phaser.Math.Between(0,LANES-1);
            console.log('Spawning enemy in lane', lane);
            this._spawnEnemy(lane, speed); 
          } 
        },
        reset: ()=>{ this.scene.restart(); }
      };
      sceneRef=this;
    }

    _laneX(i){ return i*LANE_W + LANE_W/2; }
    _spawnEnemy(lane, speed){ const e=this.add.image(this._laneX(lane), -20, 'enemyTex'); e.vy=speed; e.w=20; e.h=20; this.enemies.push(e); }
    _spawnBlocker(lane, speed){ const b=this.add.image(this._laneX(lane), -30, 'blockerTex'); b.vy=speed; b.w=40; b.h=40; b.hits=3; this.blockers.push(b); }
    _fire(){ const now=this.time.now; if(now-this.lastShotAt<FIRE_COOLDOWN) return; this.lastShotAt=now; const b=this.add.image(this.player.x, this.player.y-20, 'bulletTex'); b.vy=-BULLET_SPEED; b.w=6; b.h=12; this.bullets.push(b); }
    _aabb(a,b){ return Math.abs(a.x-b.x) < (a.w+b.w)/2 && Math.abs(a.y-b.y) < (a.h+b.h)/2; }

    update(_, dt){
      if(Phaser.Input.Keyboard.JustDown(this.keys.LEFT)||Phaser.Input.Keyboard.JustDown(this.keys.A)){ this.playerLane=Math.max(0,this.playerLane-1); this.player.x=this._laneX(this.playerLane); }
      if(Phaser.Input.Keyboard.JustDown(this.keys.RIGHT)||Phaser.Input.Keyboard.JustDown(this.keys.D)){ this.playerLane=Math.min(LANES-1,this.playerLane+1); this.player.x=this._laneX(this.playerLane); }
      if(this.keys.SPACE.isDown) this._fire();

      const dy=dt/1000; // seconds
      for(let i=this.enemies.length-1;i>=0;i--){ const e=this.enemies[i]; e.y += e.vy*dy; if(e.y>PLAYER_Y){ this.scene.restart(); return; } if(e.y>HEIGHT+30){ e.destroy(); this.enemies.splice(i,1); } }
      for(let i=this.bullets.length-1;i>=0;i--){ const b=this.bullets[i]; b.y += b.vy*dy; if(b.y<-30){ b.destroy(); this.bullets.splice(i,1); continue; } for(let j=this.enemies.length-1;j>=0;j--){ const e=this.enemies[j]; if(this._aabb({x:b.x,y:b.y,w:b.w,h:b.h},{x:e.x,y:e.y,w:e.w,h:e.h})){ b.destroy(); this.bullets.splice(i,1); e.destroy(); this.enemies.splice(j,1); this.score+=10; this.scoreText.setText('score '+this.score); break; } } }
    }
  }

  new Phaser.Game({ type: Phaser.AUTO, width: WIDTH, height: HEIGHT, backgroundColor:'#000', scene:[Main] });
})();

/*******************
 * UI WIRING
 *******************/
const loginBtn = els('loginBtn');
const authState = els('authState');
const loadBtn  = els('loadBtn');
const playBtn  = els('playBtn');
const pauseBtn = els('pauseBtn');
const spotifyUrl = els('spotifyUrl');

els('calib').addEventListener('change', (e)=> setCalibration(e.target.value));

loginBtn.addEventListener('click', async ()=>{
  const cid = els('clientId').value.trim() || window.ENV?.SPOTIFY_CLIENT_ID;
  if(!cid){ alert('Enter your Spotify Client ID (see Setup notes).'); return; }
  await startAuth(cid);
});

loadBtn.addEventListener('click', async ()=>{
  try{
    const cid = els('clientId').value.trim() || window.ENV?.SPOTIFY_CLIENT_ID;
    if(!cid){ alert('Enter Client ID and login first.'); return; }

    // Acquire token (finish PKCE or use cached)
    let tok = loadToken();
    if(!tok){ tok = await finishAuth(cid); }
    if(!tok){ alert('Not logged in. Click Login.'); return; }
    accessToken = tok.access_token;
    console.log('Access token set:', accessToken ? 'yes ('+accessToken.substring(0,20)+'...)' : 'no');
    setText('authState', 'token ok');

    // Get current user to verify Premium
    const me = await api('/me');
    userPremium = (me?.product === 'premium');
    if(!userPremium){ log('Warning: account is not Premium; playback via SDK may fail.'); }

    // Ensure SDK device
    await ensureDevice();
    await transferPlayback();

    const parsed = parseSpotifyUrl(spotifyUrl.value.trim());
    if(!parsed){ alert('Paste a valid Spotify track or playlist URL.'); return; }

    if(parsed.type === 'track'){
      await playUris([`spotify:track:${parsed.id}`]);
    } else if(parsed.type === 'playlist'){
      await playContext(`spotify:playlist:${parsed.id}`);
    } else if(parsed.type === 'album'){
      await playContext(`spotify:album:${parsed.id}`);
    } else {
      alert('Only track / playlist / album URLs are supported in this demo.');
      return;
    }

    setText('nowplay', 'Setting up beat detection…');
    await new Promise(r=>setTimeout(r, 600)); // give player a moment to start
    
    // Setup audio analysis for beat detection
    const audioReady = await setupAudioAnalysis();
    if(!audioReady) {
      log('Beat detection unavailable - manual rhythm mode');
      // Could implement a timer-based beat here as fallback
    }
    
    startBeatDetection();
    setText('nowplay', 'Ready. Hit Play.');
  }catch(err){ log('Load error: '+err.message); }
});

playBtn.addEventListener('click', async ()=>{
  try{ 
    if(!deviceId) { log('No device ready. Click Load first.'); return; }
    await api(`/me/player/play?device_id=${deviceId}`, { method:'PUT', body: JSON.stringify({}) }); 
    setText('nowplay','Playing');
    
    // Reset beat index to resync with current position
    const st = await getPlayerState();
    if(st && st.position !== undefined) {
      const posSec = st.position/1000;
      beatIdx = 0;
      // Find the right beat index for current position
      while (beatIdx < beatTimesSec.length && beatTimesSec[beatIdx] < posSec) {
        beatIdx++;
      }
      log(`Resumed at ${posSec.toFixed(1)}s, beat index: ${beatIdx}`);
    }
  }
  catch(err){ log('Play error: '+err.message); }
});

pauseBtn.addEventListener('click', async ()=>{
  try{ 
    if(!deviceId) { log('No device ready. Click Load first.'); return; }
    await pause(); 
    setText('nowplay','Paused'); 
  }
  catch(err){ log('Pause error: '+err.message); }
});

// Debug function to test API calls manually
window.debugAPI = async function(endpoint) {
  if(!accessToken) {
    console.log('No access token set. Load a track first.');
    return;
  }
  
  console.log(`Testing API call to: ${endpoint}`);
  console.log(`Using token: ${accessToken.substring(0, 20)}...`);
  
  try {
    const res = await fetch('https://api.spotify.com/v1' + endpoint, {
      headers: {
        'Authorization': 'Bearer ' + accessToken,
        'Content-Type': 'application/json'
      }
    });
    
    console.log('Response status:', res.status);
    console.log('Response headers:', Object.fromEntries(res.headers.entries()));
    
    const text = await res.text();
    console.log('Response body (first 500 chars):', text.substring(0, 500));
    
    try {
      const json = JSON.parse(text);
      console.log('Parsed JSON:', json);
      return json;
    } catch(e) {
      console.log('Not valid JSON');
      return text;
    }
  } catch(err) {
    console.error('Request failed:', err);
  }
};

// On page load, populate fields from environment variables
window.addEventListener('DOMContentLoaded', ()=>{
  if(window.ENV?.SPOTIFY_CLIENT_ID && !els('clientId').value) {
    els('clientId').value = window.ENV.SPOTIFY_CLIENT_ID;
    log('Client ID loaded from environment');
  }
  if(window.ENV?.SPOTIFY_DEFAULT_URL && !spotifyUrl.value) {
    spotifyUrl.value = window.ENV.SPOTIFY_DEFAULT_URL;
  }
  
  // Log debug instructions
  console.log('Debug commands available:');
  console.log('  debugAPI("/me") - test user endpoint');
  console.log('  debugAPI("/me/player/currently-playing") - test current track');
  console.log('  debugAPI("/audio-analysis/TRACK_ID") - test audio analysis');
});
</script>
<script src="https://sdk.scdn.co/spotify-player.js"></script>
</body>
</html>
