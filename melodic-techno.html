<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Melodic Techno Generator</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@latest/build/Tone.min.js"></script>
  <style>
    body { 
      background: #000; 
      color: #0f0; 
      font: 14px monospace; 
      padding: 20px;
      text-shadow: 0 0 10px #0f0;
    }
    button { 
      background: #111; 
      color: #0f0; 
      border: 1px solid #0f0; 
      padding: 10px 20px; 
      margin: 5px;
      cursor: pointer;
      text-shadow: 0 0 5px #0f0;
    }
    button:hover { 
      background: #222; 
      box-shadow: 0 0 10px #0f0;
    }
    .controls { margin: 20px 0; }
    h1 { 
      color: #ff0; 
      text-shadow: 0 0 20px #ff0;
    }
    .track-row {
      margin: 5px 0;
      display: flex;
      align-items: center;
    }
    .track-name {
      width: 80px;
      text-align: right;
      margin-right: 10px;
    }
    .beat-indicator {
      display: inline-block;
      width: 20px;
      height: 20px;
      background: #030;
      border: 1px solid #0f0;
      margin-right: 5px;
    }
    .pattern-display {
      display: inline-block;
      margin-left: 10px;
      font-size: 10px;
      color: #0a0;
    }
    #progression {
      margin: 20px 0;
      padding: 10px;
      border: 1px solid #0f0;
      background: #010;
    }
  </style>
</head>
<body>
  <h1>MELODIC TECHNO ENGINE</h1>
  
  <div class="controls">
    <button id="playBtn">PLAY</button>
    <button id="stopBtn">STOP</button>
    <label>BPM: <input type="range" id="bpmSlider" min="120" max="150" value="132"></label>
    <span id="bpmDisplay">132</span>
    <label>ENERGY: <input type="range" id="energySlider" min="0" max="100" value="50"></label>
    <span id="energyDisplay">50</span>
  </div>
  
  <div id="tracks">
    <div class="track-row">
      <span class="track-name">KICK:</span>
      <span class="beat-indicator" id="kickIndicator"></span>
      <span class="pattern-display" id="kickPattern"></span>
    </div>
    <div class="track-row">
      <span class="track-name">SNARE:</span>
      <span class="beat-indicator" id="snareIndicator"></span>
      <span class="pattern-display" id="snarePattern"></span>
    </div>
    <div class="track-row">
      <span class="track-name">HIHAT:</span>
      <span class="beat-indicator" id="hatIndicator"></span>
      <span class="pattern-display" id="hatPattern"></span>
    </div>
    <div class="track-row">
      <span class="track-name">ACID:</span>
      <span class="beat-indicator" id="acidIndicator"></span>
      <span class="pattern-display" id="acidPattern"></span>
    </div>
    <div class="track-row">
      <span class="track-name">STAB:</span>
      <span class="beat-indicator" id="stabIndicator"></span>
      <span class="pattern-display" id="stabPattern"></span>
    </div>
    <div class="track-row">
      <span class="track-name">SUB:</span>
      <span class="beat-indicator" id="subIndicator"></span>
      <span class="pattern-display" id="subPattern"></span>
    </div>
  </div>
  
  <div id="progression">
    <div>SECTION: <span id="section">INTRO</span></div>
    <div>BAR: <span id="bar">0</span> / 64</div>
    <div>CHORD: <span id="chord">Cm</span></div>
    <div>NEXT: <span id="nextSection">BUILD in 8 bars</span></div>
  </div>
  
  <div id="status">READY</div>

<script>
// Master chain with sidechain compression
const masterLimiter = new Tone.Limiter(-3).toDestination();
const sidechain = new Tone.Compressor({
  threshold: -20,
  ratio: 8,
  attack: 0.003,
  release: 0.1
}).connect(masterLimiter);

// Instruments
const kick = new Tone.MembraneSynth({
  pitchDecay: 0.05,
  octaves: 10,
  oscillator: { type: "sine" },
  envelope: {
    attack: 0.001,
    decay: 0.4,
    sustain: 0.01,
    release: 1.4
  }
}).connect(masterLimiter);

const snare = new Tone.NoiseSynth({
  noise: { type: "white" },
  envelope: {
    attack: 0.001,
    decay: 0.15,
    sustain: 0
  }
}).connect(sidechain);

const hihat = new Tone.MetalSynth({
  frequency: 250,
  envelope: {
    attack: 0.001,
    decay: 0.03,
    release: 0.01
  },
  harmonicity: 5.1,
  modulationIndex: 32,
  resonance: 4000,
  octaves: 1.5
}).connect(sidechain);

// Acid with automated filter
const acidFilter = new Tone.Filter({
  frequency: 800,
  type: "lowpass",
  rolloff: -12,
  Q: 8
}).connect(sidechain);

const acid = new Tone.MonoSynth({
  oscillator: { type: "sawtooth" },
  envelope: {
    attack: 0.01,
    decay: 0.3,
    sustain: 0.4,
    release: 0.2
  },
  filterEnvelope: {
    attack: 0.01,
    decay: 0.3,
    sustain: 0.5,
    release: 0.2,
    baseFrequency: 200,
    octaves: 3.5
  }
}).connect(acidFilter);

// Rave stabs
const raveSynth = new Tone.PolySynth(Tone.Synth, {
  oscillator: { type: "sawtooth" },
  envelope: {
    attack: 0.01,
    decay: 0.2,
    sustain: 0.3,
    release: 0.4
  },
  volume: -6
}).connect(sidechain);

// Sub bass
const subBass = new Tone.MonoSynth({
  oscillator: { type: "sine" },
  envelope: {
    attack: 0.02,
    decay: 0.1,
    sustain: 0.7,
    release: 0.3
  },
  volume: -12
}).connect(masterLimiter);

// Musical structures
const scale = {
  C: ["C", "D", "Eb", "F", "G", "Ab", "Bb"],
  indices: { C: 0, D: 1, Eb: 2, F: 3, G: 4, Ab: 5, Bb: 6 }
};

// Chord progression with melodic movement hints
const chordProgression = [
  { root: "C", chord: ["C4", "Eb4", "G4"], bass: "C1", melodicFocus: ["C", "Eb", "G"] },
  { root: "C", chord: ["C4", "Eb4", "G4"], bass: "C1", melodicFocus: ["G", "Eb", "C"] },
  { root: "Bb", chord: ["Bb3", "D4", "F4"], bass: "Bb0", melodicFocus: ["Bb", "F", "D"] },
  { root: "Ab", chord: ["Ab3", "C4", "Eb4"], bass: "Ab0", melodicFocus: ["Ab", "Eb", "C"] }
];

// Pattern bank for variety
const patternBank = {
  kick: {
    fourOnFloor: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],
    halfTime: [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
    syncopated: [1,0,0,0, 1,0,0,1, 0,0,1,0, 1,0,0,0],
    minimal: [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
    fill: [1,0,1,0, 1,0,1,1, 1,1,1,0, 1,1,1,1]
  },
  snare: {
    backbeat: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
    ghost: [0,0,0,0, 1,0,0,1, 0,0,0,0, 1,0,0,0],
    fill: [0,0,0,0, 1,0,1,0, 1,0,1,1, 1,1,1,1],
    minimal: [0,0,0,0, 0,0,0,0, 0,0,0,0, 1,0,0,0]
  }
};

// State
let currentBar = 0;
let currentChordIndex = 0;
let acidSequence = [];
let energyLevel = 50;
let lastSection = '';
let isTransitioning = false;

// Visual feedback
function flashIndicator(id) {
  const el = document.getElementById(id);
  if (el) {
    el.style.background = '#0f0';
    setTimeout(() => el.style.background = '#030', 60);
  }
}

// Generate melodic acid sequence
function generateMelodicAcidSequence(chordInfo, section, previousSequence = []) {
  const sequence = [];
  const octave = section === 'DROP' ? 3 : 2;
  const density = section === 'DROP' ? 0.8 : section === 'BUILD' ? 0.6 : section === 'BREAK' ? 0.3 : 0.5;
  
  // Use chord tones as anchors
  const chordTones = chordInfo.melodicFocus;
  let lastNote = previousSequence.length > 0 ? previousSequence[previousSequence.length - 1] : null;
  
  for (let i = 0; i < 16; i++) {
    if (Math.random() < density) {
      let note;
      
      // Strong beats (0, 4, 8, 12) favor chord tones
      if (i % 4 === 0) {
        note = chordTones[Math.floor(Math.random() * chordTones.length)] + octave;
      } else if (lastNote && Math.random() > 0.3) {
        // Stepwise motion from last note
        const lastPitch = lastNote.replace(/\d/, '');
        const lastOctave = parseInt(lastNote.replace(/\D/g, ''));
        const scaleIndex = scale.indices[lastPitch];
        
        if (scaleIndex !== undefined) {
          const direction = Math.random() > 0.5 ? 1 : -1;
          const newIndex = (scaleIndex + direction + 7) % 7;
          note = scale.C[newIndex] + lastOctave;
        } else {
          note = chordTones[Math.floor(Math.random() * chordTones.length)] + octave;
        }
      } else {
        // Random scale note
        note = scale.C[Math.floor(Math.random() * scale.C.length)] + octave;
      }
      
      sequence.push(note);
      lastNote = note;
    } else {
      sequence.push(null);
    }
  }
  
  return sequence;
}

// Generate drum fill
function generateDrumFill() {
  return {
    kick: patternBank.kick.fill,
    snare: patternBank.snare.fill,
    hihat: new Array(16).fill(1) // Rapid hi-hats
  };
}

// Get section
function getSection(bar) {
  const pos = bar % 64;
  if (pos < 8) return 'INTRO';
  if (pos < 16) return 'BUILD';
  if (pos < 32) return 'MAIN';
  if (pos < 40) return 'BREAK';
  if (pos < 56) return 'DROP';
  return 'OUTRO';
}

// Check if we're approaching a section change
function isApproachingTransition(bar) {
  const pos = bar % 64;
  const transitionBars = [7, 15, 31, 39, 55, 63];
  return transitionBars.includes(pos);
}

// Generate patterns based on section and energy
function generatePatterns(section, bar, energy) {
  const patterns = {};
  const isFill = isApproachingTransition(bar);
  
  if (isFill) {
    // Drum fill before section change
    const fill = generateDrumFill();
    patterns.kick = fill.kick;
    patterns.snare = fill.snare;
    patterns.hihat = fill.hihat;
  } else {
    // Normal patterns based on section
    if (section === 'DROP') {
      patterns.kick = patternBank.kick.fourOnFloor;
      patterns.snare = energy > 70 ? patternBank.snare.ghost : patternBank.snare.backbeat;
    } else if (section === 'MAIN') {
      patterns.kick = energy > 60 ? patternBank.kick.fourOnFloor : patternBank.kick.syncopated;
      patterns.snare = patternBank.snare.backbeat;
    } else if (section === 'BUILD') {
      patterns.kick = patternBank.kick.halfTime;
      patterns.snare = patternBank.snare.minimal;
    } else if (section === 'BREAK') {
      patterns.kick = patternBank.kick.minimal;
      patterns.snare = new Array(16).fill(0);
    } else {
      patterns.kick = patternBank.kick.halfTime;
      patterns.snare = patternBank.snare.minimal;
    }
    
    // Hi-hat density based on energy
    patterns.hihat = [];
    const hihatDensity = (energy / 100) * 0.8;
    for (let i = 0; i < 16; i++) {
      patterns.hihat[i] = Math.random() < hihatDensity ? 1 : 0;
    }
  }
  
  // Stab pattern - call and response with acid
  const stabTiming = bar % 4;
  if (stabTiming === 0 || stabTiming === 2) {
    patterns.stab = [0,0,0,1, 0,0,1,0, 0,0,0,1, 0,0,0,0];
  } else {
    patterns.stab = new Array(16).fill(0);
  }
  
  return patterns;
}

// Sequences
let kickLoop, snareLoop, hihatLoop, acidLoop, chordLoop, subLoop;

function updatePatterns() {
  const section = getSection(currentBar);
  const patterns = generatePatterns(section, currentBar, energyLevel);
  const chordInfo = chordProgression[currentChordIndex];
  
  // Update pattern displays
  document.getElementById('kickPattern').textContent = patterns.kick.join('');
  document.getElementById('snarePattern').textContent = patterns.snare.join('');
  document.getElementById('hatPattern').textContent = patterns.hihat.join('');
  
  // Generate melodic acid sequence
  if (currentBar % 2 === 0) {
    acidSequence = generateMelodicAcidSequence(chordInfo, section, acidSequence);
    document.getElementById('acidPattern').textContent = acidSequence.map(n => n ? '♪' : '·').join('');
  }
  
  // Clear and recreate sequences
  if (kickLoop) kickLoop.dispose();
  if (snareLoop) snareLoop.dispose();
  if (hihatLoop) hihatLoop.dispose();
  if (acidLoop) acidLoop.dispose();
  if (chordLoop) chordLoop.dispose();
  if (subLoop) subLoop.dispose();
  
  // Kick
  kickLoop = new Tone.Sequence((time, note) => {
    if (note) {
      kick.triggerAttackRelease("C1", "8n", time);
      sidechain.ratio.setValueAtTime(20, time);
      sidechain.ratio.linearRampToValueAtTime(8, time + 0.1);
      Tone.Draw.schedule(() => flashIndicator('kickIndicator'), time);
    }
  }, patterns.kick, "16n");
  
  // Snare
  snareLoop = new Tone.Sequence((time, note) => {
    if (note) {
      snare.triggerAttackRelease("8n", time);
      Tone.Draw.schedule(() => flashIndicator('snareIndicator'), time);
    }
  }, patterns.snare, "16n");
  
  // Hi-hat
  hihatLoop = new Tone.Sequence((time, note) => {
    if (note) {
      hihat.triggerAttackRelease("32n", time, 0.3);
      Tone.Draw.schedule(() => flashIndicator('hatIndicator'), time);
    }
  }, patterns.hihat, "16n");
  
  // Acid with melodic sequence
  acidLoop = new Tone.Sequence((time, note) => {
    if (note) {
      acid.triggerAttackRelease(note, "16n", time);
      Tone.Draw.schedule(() => flashIndicator('acidIndicator'), time);
    }
  }, acidSequence, "16n");
  
  // Stabs
  chordLoop = new Tone.Sequence((time, hit) => {
    if (hit) {
      chordInfo.chord.forEach((note, i) => {
        raveSynth.triggerAttackRelease(note, "8n", time + i * 0.01);
      });
      Tone.Draw.schedule(() => flashIndicator('stabIndicator'), time);
    }
  }, patterns.stab, "16n");
  
  // Sub bass following chord progression
  subLoop = new Tone.Sequence((time, note) => {
    if (note) {
      subBass.triggerAttackRelease(note, "2n", time);
      Tone.Draw.schedule(() => flashIndicator('subIndicator'), time);
    }
  }, [chordInfo.bass], "1n");
  
  kickLoop.start(0);
  snareLoop.start(0);
  hihatLoop.start(0);
  acidLoop.start(0);
  chordLoop.start(0);
  subLoop.start(0);
}

// Automation curves for smooth transitions
function applyAutomation(section, prevSection) {
  const now = Tone.now();
  
  // Filter automation
  if (section === 'DROP' && prevSection !== 'DROP') {
    acidFilter.frequency.exponentialRampToValueAtTime(2000, now + 2);
    acidFilter.Q.linearRampToValueAtTime(15, now + 2);
  } else if (section === 'BREAK') {
    acidFilter.frequency.exponentialRampToValueAtTime(400, now + 1);
    acidFilter.Q.linearRampToValueAtTime(5, now + 1);
  } else if (section === 'BUILD') {
    acidFilter.frequency.exponentialRampToValueAtTime(1200, now + 4);
  }
}

// Main evolution function
function evolve() {
  const section = getSection(currentBar);
  const nextBar = (currentBar + 1) % 64;
  const nextSection = getSection(nextBar);
  
  // Update displays
  document.getElementById('section').textContent = section;
  document.getElementById('bar').textContent = currentBar;
  document.getElementById('chord').textContent = chordProgression[currentChordIndex].root + 'm';
  
  // Calculate next transition
  const barsUntilNext = nextSection !== section ? 1 : 
    nextBar < 8 ? 8 - nextBar :
    nextBar < 16 ? 16 - nextBar :
    nextBar < 32 ? 32 - nextBar :
    nextBar < 40 ? 40 - nextBar :
    nextBar < 56 ? 56 - nextBar :
    64 - nextBar;
  document.getElementById('nextSection').textContent = 
    nextSection !== section ? `${nextSection} next bar` : 
    `${getSection(currentBar + barsUntilNext)} in ${barsUntilNext} bars`;
  
  // Apply automation on section changes
  if (section !== lastSection) {
    applyAutomation(section, lastSection);
    lastSection = section;
  }
  
  // Update patterns every bar
  if (currentBar % 1 === 0) {
    updatePatterns();
  }
  
  // Progress chord every 4 bars
  if (currentBar % 4 === 0) {
    currentChordIndex = (currentChordIndex + 1) % chordProgression.length;
  }
  
  currentBar = (currentBar + 1) % 64;
}

// Schedule evolution
Tone.Transport.scheduleRepeat(() => evolve(), "1m");

// Controls
document.getElementById('playBtn').addEventListener('click', async () => {
  await Tone.start();
  currentBar = 0;
  currentChordIndex = 0;
  lastSection = '';
  updatePatterns();
  Tone.Transport.start();
  document.getElementById('status').textContent = 'PLAYING';
});

document.getElementById('stopBtn').addEventListener('click', () => {
  Tone.Transport.stop();
  Tone.Transport.cancel();
  currentBar = 0;
  document.getElementById('status').textContent = 'STOPPED';
});

document.getElementById('bpmSlider').addEventListener('input', (e) => {
  const bpm = parseInt(e.target.value);
  Tone.Transport.bpm.value = bpm;
  document.getElementById('bpmDisplay').textContent = bpm;
});

document.getElementById('energySlider').addEventListener('input', (e) => {
  energyLevel = parseInt(e.target.value);
  document.getElementById('energyDisplay').textContent = energyLevel;
});

// Initial BPM
Tone.Transport.bpm.value = 132;
</script>
</body>
</html>