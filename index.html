<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Beat Rider - Melodic Techno</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@latest/build/Tone.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body { 
      background: #000; 
      color: #0f0; 
      font: 14px monospace; 
      text-shadow: 0 0 10px #0f0;
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }
    .container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    .left-panel {
      position: absolute;
      top: 70px;
      left: 10px;
      width: 380px;
      max-height: 0;
      overflow: hidden;
      background: rgba(0, 0, 0, 0.95);
      border: 1px solid #0f0;
      border-radius: 0 0 8px 8px;
      border-top: none;
      z-index: 9;
      backdrop-filter: blur(5px);
      transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), padding 0.4s;
      padding: 0 10px;
    }
    
    .left-panel.expanded {
      max-height: 400px;
      padding: 10px;
      overflow-y: auto;
    }
    #gameContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    button { 
      background: #111; 
      color: #0f0; 
      border: 1px solid #0f0; 
      padding: 10px 20px; 
      margin: 5px;
      cursor: pointer;
      text-shadow: 0 0 5px #0f0;
    }
    button:hover { 
      background: #222; 
      box-shadow: 0 0 10px #0f0;
    }
    .controls { 
      margin: 20px 0; 
    }
    .slider-row {
      display: flex;
      align-items: center;
      margin: 10px 0;
      gap: 10px;
    }
    .slider-label {
      min-width: 80px;
      text-align: right;
      color: #0f0;
    }
    .slider {
      flex: 1;
      max-width: 200px;
    }
    .slider-value {
      min-width: 40px;
      color: #ff0;
      font-weight: bold;
    }
    .sound-select {
      flex: 1;
      max-width: 200px;
      background: #111;
      color: #0f0;
      border: 1px solid #0f0;
      padding: 4px;
      font-family: monospace;
    }
    h1 { 
      color: #ff0; 
      text-shadow: 0 0 20px #ff0;
      font-size: 18px;
      margin: 10px 0;
    }
    .track-row {
      margin: 5px 0;
      display: flex;
      align-items: center;
    }
    .track-name {
      width: 80px;
      text-align: right;
      margin-right: 10px;
    }
    .beat-indicator {
      display: inline-block;
      width: 20px;
      height: 20px;
      background: #030;
      border: 1px solid #0f0;
      margin-right: 5px;
    }
    .pattern-display {
      display: inline-block;
      margin-left: 10px;
      font-size: 10px;
      color: #0a0;
    }
    .mute-btn {
      width: 40px;
      height: 20px;
      padding: 2px;
      margin: 0 5px;
      font-size: 10px;
      background: #030;
      color: #0f0;
      border: 1px solid #0f0;
      cursor: pointer;
    }
    .mute-btn.muted {
      background: #300;
      color: #f00;
      border-color: #f00;
    }
    #progression {
      margin: 20px 0;
      padding: 10px;
      border: 1px solid #0f0;
      background: #010;
    }
    
    /* Minimized music controls */
    .music-controls {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid #0f0;
      border-radius: 8px;
      padding: 10px;
      z-index: 10;
      backdrop-filter: blur(5px);
    }
    
    .control-btn {
      width: 40px;
      height: 40px;
      background: #111;
      color: #0f0;
      border: 1px solid #0f0;
      border-radius: 4px;
      cursor: pointer;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    
    .control-btn:hover {
      background: #222;
      box-shadow: 0 0 10px #0f0;
    }
    
    .track-squares {
      display: flex;
      gap: 8px;
      padding: 0 10px;
      border-left: 1px solid #0f0;
      border-right: 1px solid #0f0;
    }
    
    .track-square {
      width: 30px;
      height: 30px;
      background: #030;
      border: 2px solid #0f0;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .track-square.active {
      background: #0f0;
      box-shadow: 0 0 15px #0f0;
    }
    
    .track-square.muted {
      background: #300;
      border-color: #f00;
      opacity: 0.5;
    }
    
    .track-square.flash {
      animation: flash 0.1s;
    }
    
    @keyframes flash {
      0% { background: #0f0; box-shadow: 0 0 20px #0f0; }
      100% { background: #030; box-shadow: none; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="gameContainer"></div>
    
    <!-- Minimized music controls -->
    <div id="musicControls" class="music-controls">
      <button id="playBtn" class="control-btn" title="Play">▶</button>
      <button id="stopBtn" class="control-btn" title="Stop">■</button>
      <div class="track-squares">
        <div class="track-square" id="kickSquare" data-track="kick" title="Kick"></div>
        <div class="track-square" id="snareSquare" data-track="snare" title="Snare"></div>
        <div class="track-square" id="hatSquare" data-track="hat" title="Hi-hat"></div>
        <div class="track-square" id="acidSquare" data-track="acid" title="Acid"></div>
        <div class="track-square" id="stabSquare" data-track="stab" title="Stab"></div>
        <div class="track-square" id="subSquare" data-track="sub" title="Sub"></div>
      </div>
      <button id="expandBtn" class="control-btn" title="Settings">⚙</button>
    </div>
    
    <!-- Expanded panel (hidden by default) -->
    <div class="left-panel" id="expandedPanel">
      <h1>MELODIC TECHNO ENGINE</h1>
      <button id="minimizeBtn" style="float: right; margin-top: -30px;">×</button>
      
      <div class="controls">
        <div class="slider-row">
          <label class="slider-label">BPM:</label>
          <input type="range" id="bpmSlider" min="120" max="150" value="132" class="slider">
          <span id="bpmDisplay" class="slider-value">132</span>
        </div>
        <div class="slider-row">
          <label class="slider-label">ENERGY:</label>
          <input type="range" id="energySlider" min="0" max="100" value="50" class="slider">
          <span id="energyDisplay" class="slider-value">50</span>
        </div>
        <div class="slider-row">
          <label class="slider-label">TENSION:</label>
          <input type="range" id="tensionSlider" min="0" max="100" value="30" class="slider">
          <span id="tensionDisplay" class="slider-value">30</span>
        </div>
        <div class="slider-row">
          <label class="slider-label">SHOT:</label>
          <select id="soundSelector" class="sound-select">
            <option value="0">Triangle</option>
            <option value="1">Acid</option>
            <option value="2">Chord</option>
            <option value="3">Echo</option>
            <option value="4">Pluck</option>
            <option value="5">Pew Pew</option>
          </select>
          <span id="soundDisplay" class="slider-value">Triangle</span>
        </div>
      </div>
  
  <div id="progression">
    <div>SECTION: <span id="section">INTRO</span></div>
    <div>BAR: <span id="bar">0</span> / 64</div>
    <div>CHORD: <span id="chord">Cm</span></div>
    <div>NEXT: <span id="nextSection">BUILD in 8 bars</span></div>
  </div>
  
      <div id="status">READY</div>
    </div>
  </div>

<script>
// Master chain with sidechain compression
const masterLimiter = new Tone.Limiter(-3).toDestination();

// High-pass filter for tension building (cuts bass)
const masterHighpass = new Tone.Filter({
  frequency: 20,
  type: "highpass",
  rolloff: -24
}).connect(masterLimiter);

const sidechain = new Tone.Compressor({
  threshold: -20,
  ratio: 8,
  attack: 0.003,
  release: 0.1
}).connect(masterHighpass);

// Instruments
const kick = new Tone.MembraneSynth({
  pitchDecay: 0.05,
  octaves: 10,
  oscillator: { type: "sine" },
  envelope: {
    attack: 0.001,
    decay: 0.4,
    sustain: 0.01,
    release: 1.4
  }
}).connect(masterHighpass); // Kick bypasses sidechain to keep punch

const snare = new Tone.NoiseSynth({
  noise: { type: "white" },
  envelope: {
    attack: 0.001,
    decay: 0.15,
    sustain: 0
  }
}).connect(sidechain);

// Hi-hat using filtered noise for more realistic sound
const hihatFilter = new Tone.Filter({
  frequency: 10000,
  type: "highpass"
}).connect(sidechain);

const hihat = new Tone.NoiseSynth({
  noise: {
    type: "white"
  },
  envelope: {
    attack: 0.001,
    decay: 0.02,
    sustain: 0,
    release: 0.03
  },
  volume: -10
}).connect(hihatFilter);

// Acid with automated filter - trying to approximate 18dB slope with cascaded filters
const acidFilter1 = new Tone.Filter({
  frequency: 800,
  type: "lowpass",
  rolloff: -12,
  Q: 4
}).connect(sidechain);

const acidFilter2 = new Tone.Filter({
  frequency: 800,
  type: "lowpass", 
  rolloff: -12,  // Can't do -6, using -12 instead
  Q: 2
}).connect(acidFilter1);

// Add distortion for that overdriven 303 sound
const acidDistortion = new Tone.Distortion(0.3).connect(acidFilter2);

const acid = new Tone.MonoSynth({
  oscillator: { type: "sawtooth" },
  envelope: {
    attack: 0.003,  // Faster attack
    decay: 0.2,     // Shorter decay
    sustain: 0.1,   // Lower sustain for more plucky sound
    release: 0.1
  },
  filterEnvelope: {
    attack: 0.003,
    decay: 0.4,     // Longer filter decay for that sweep
    sustain: 0.2,
    release: 0.2,
    baseFrequency: 100,  // Start lower
    octaves: 4      // More dramatic sweep
  },
  portamento: 0.05  // Add glide between notes!
}).connect(acidDistortion);

// Rave stabs with filter and reverb for space
const stabReverb = new Tone.Reverb({
  decay: 2,
  wet: 0.3
}).connect(sidechain);

const stabFilter = new Tone.Filter({
  frequency: 3000,  // Open up the filter more
  type: "lowpass",
  rolloff: -12,
  Q: 2
}).connect(stabReverb);

const raveSynth = new Tone.PolySynth(Tone.Synth, {
  oscillator: { 
    type: "sawtooth",
    partialCount: 3  // Fewer harmonics = softer sound
  },
  envelope: {
    attack: 0.01,    // Quick attack
    decay: 0.15,     // Slightly longer decay
    sustain: 0,      // No sustain - just decay/release
    release: 0.2     // Moderate release - musical but won't overlap too much
  },
  volume: -2       // Boost volume back up
}).connect(stabFilter);

// Sub bass with EQ to prevent mud
const subEQ = new Tone.EQ3({
  low: 3,        // Boost the deep sub frequencies
  mid: -6,       // Cut the muddy mids (100-200Hz)
  high: -12,     // Remove any high frequency content
  lowFrequency: 60,
  highFrequency: 200
}).connect(sidechain);  // Now goes through sidechain for ducking!

// Sub bass - controlled power
const subBass = new Tone.MonoSynth({
  oscillator: { type: "sine" },
  envelope: {
    attack: 0.01,   // Faster attack for more punch
    decay: 0.3,     // Longer decay
    sustain: 0.6,   // Bit less sustain
    release: 0.5
  },
  volume: -6      // Compromise between -12 and 0
}).connect(subEQ);

// Noise riser for tension
const noiseRiser = new Tone.Noise("white").connect(
  new Tone.Filter({
    frequency: 200,
    type: "highpass",
    rolloff: -24
  }).connect(
    new Tone.Volume(-20).connect(sidechain)
  )
);
const riserEnvelope = new Tone.Envelope({
  attack: 8,
  decay: 0,
  sustain: 1,
  release: 0.5
});

// Musical structures
const scale = {
  C: ["C", "D", "Eb", "F", "G", "Ab", "Bb"],
  indices: { C: 0, D: 1, Eb: 2, F: 3, G: 4, Ab: 5, Bb: 6 }
};

// Extended chord progression with variations
const chordProgressions = {
  main: [
    { root: "C", chord: ["C4", "Eb4", "G4"], bass: "C1", melodicFocus: ["C", "Eb", "G"] },
    { root: "C", chord: ["C4", "Eb4", "G4"], bass: "C1", melodicFocus: ["G", "Eb", "C"] },
    { root: "Bb", chord: ["Bb3", "D4", "F4"], bass: "Bb0", melodicFocus: ["Bb", "F", "D"] },
    { root: "Ab", chord: ["Ab3", "C4", "Eb4"], bass: "Ab0", melodicFocus: ["Ab", "Eb", "C"] }
  ],
  variation1: [
    { root: "C", chord: ["C4", "Eb4", "G4"], bass: "C1", melodicFocus: ["C", "G", "Eb"] },
    { root: "F", chord: ["F3", "Ab3", "C4"], bass: "F0", melodicFocus: ["F", "Ab", "C"] },
    { root: "G", chord: ["G3", "Bb3", "D4"], bass: "G0", melodicFocus: ["G", "D", "Bb"] },
    { root: "C", chord: ["C4", "Eb4", "G4"], bass: "C1", melodicFocus: ["C", "Eb", "G"] }
  ],
  variation2: [
    { root: "C", chord: ["C4", "Eb4", "G4", "Bb4"], bass: "C1", melodicFocus: ["C", "Bb", "G"] }, // Cm7
    { root: "Ab", chord: ["Ab3", "C4", "Eb4", "G4"], bass: "Ab0", melodicFocus: ["Ab", "Eb", "G"] }, // Abmaj7
    { root: "F", chord: ["F3", "Ab3", "C4", "Eb4"], bass: "F0", melodicFocus: ["F", "C", "Ab"] }, // Fm7
    { root: "G", chord: ["G3", "B3", "D4", "F4"], bass: "G0", melodicFocus: ["G", "B", "F"] } // G7
  ],
  breakdown: [
    { root: "C", chord: ["C3"], bass: "C1", melodicFocus: ["C"] }, // Just root
    { root: "C", chord: ["C3", "G3"], bass: "C1", melodicFocus: ["C", "G"] }, // Power chord
    { root: "Ab", chord: ["Ab2"], bass: "Ab0", melodicFocus: ["Ab"] }, // Just root
    { root: "G", chord: ["G2", "D3"], bass: "G0", melodicFocus: ["G", "D"] } // Power chord
  ]
};

// Select progression based on section
function getChordProgression(section) {
  if (section === 'BREAK') return chordProgressions.breakdown;
  if (section === 'DROP') return chordProgressions.variation2;
  if (currentBar % 16 < 8) return chordProgressions.main;
  return Math.random() > 0.5 ? chordProgressions.variation1 : chordProgressions.variation2;
}

// Pattern bank with classic techno/acid patterns
const patternBank = {
  kick: {
    fourOnFloor: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],
    halfTime: [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
    syncopated: [1,0,0,0, 1,0,0,1, 0,0,1,0, 1,0,0,0],
    minimal: [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
    // Classic 909 kick patterns
    detroit: [1,0,0,1, 1,0,0,0, 1,0,1,0, 1,0,0,0],  // Detroit techno style
    berlin: [1,0,0,0, 1,0,1,0, 1,0,0,0, 1,0,0,0],   // Berlin minimal
    chicago: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,1,0],  // Chicago acid house
    fill: [1,0,1,0, 1,0,1,1, 1,1,1,0, 1,1,1,1]
  },
  snare: {
    backbeat: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
    ghost: [0,0,0,0, 1,0,0,1, 0,0,0,0, 1,0,0,0],
    detroit: [0,0,0,0, 1,0,0,0, 0,0,1,0, 1,0,0,0],  // Off-beat snare
    fill: [0,0,0,0, 1,0,1,0, 1,0,1,1, 1,1,1,1],
    minimal: [0,0,0,0, 0,0,0,0, 0,0,0,0, 1,0,0,0]
  },
  // Classic acid bassline patterns (rhythm only, notes added later)
  acid: {
    // Phuture - Acid Tracks style
    phuture: [1,0,1,0, 1,0,0,1, 1,0,1,0, 0,1,0,1],
    // Josh Wink - Higher State of Consciousness style  
    wink: [1,1,0,1, 0,1,1,0, 1,0,1,1, 0,0,1,0],
    // Hardfloor style
    hardfloor: [1,0,0,1, 1,0,1,0, 0,1,0,1, 1,0,0,0],
    // DJ Pierre style
    pierre: [1,0,1,1, 0,0,1,0, 1,1,0,1, 0,0,1,0],
    // Minimal acid
    minimal: [1,0,0,0, 0,0,1,0, 0,0,0,0, 1,0,0,0],
    // Random busy pattern
    busy: [1,1,0,1, 1,0,1,1, 0,1,1,0, 1,0,1,1]
  }
};

// State
let currentBar = 0;
let currentChordIndex = 0;
let currentProgression = null;
let acidSequence = [];
let energyLevel = 50;
let tensionLevel = 30;
let lastSection = '';
let isTransitioning = false;
let riserActive = false;

// Mute states
const muteStates = {
  kick: false,
  snare: false,
  hat: false,
  acid: false,
  stab: false,
  sub: false
};

// Humanization - adds micro-timing variations
function humanize(time, amount = 0.01) {
  // Add random timing offset between -amount and +amount seconds
  return time + (Math.random() - 0.5) * amount * 2;
}

// Visual feedback
function flashIndicator(id) {
  // Flash the minimized track square
  const trackName = id.replace('Indicator', '');
  const square = document.getElementById(trackName + 'Square');
  if (square && !muteStates[trackName]) {
    square.classList.add('flash');
    setTimeout(() => square.classList.remove('flash'), 100);
  }
}

// Generate melodic acid sequence using classic patterns
function generateMelodicAcidSequence(chordInfo, section, previousSequence = []) {
  const sequence = [];
  const octave = section === 'DROP' ? 3 : 2;
  
  // Select rhythm pattern based on section
  let rhythmPattern;
  if (section === 'DROP') {
    // Use classic acid patterns for drops
    const patterns = [patternBank.acid.phuture, patternBank.acid.wink, patternBank.acid.hardfloor];
    rhythmPattern = patterns[Math.floor(Math.random() * patterns.length)];
  } else if (section === 'BUILD') {
    rhythmPattern = patternBank.acid.pierre;
  } else if (section === 'BREAK') {
    rhythmPattern = patternBank.acid.minimal;
  } else {
    // Main section varies
    rhythmPattern = Math.random() > 0.5 ? patternBank.acid.hardfloor : patternBank.acid.phuture;
  }
  
  // Use chord tones as anchors
  const chordTones = chordInfo.melodicFocus;
  let lastNote = previousSequence.length > 0 ? previousSequence[previousSequence.length - 1] : null;
  
  for (let i = 0; i < 16; i++) {
    if (rhythmPattern[i]) {
      let note;
      
      // Strong beats (0, 4, 8, 12) favor chord tones
      if (i % 4 === 0) {
        note = chordTones[Math.floor(Math.random() * chordTones.length)] + octave;
      } else if (lastNote && Math.random() > 0.3) {
        // Stepwise motion from last note for that 303 feel
        const lastPitch = lastNote.replace(/\d/, '');
        const lastOctave = parseInt(lastNote.replace(/\D/g, ''));
        const scaleIndex = scale.indices[lastPitch];
        
        if (scaleIndex !== undefined) {
          // Classic 303 often moves in small steps
          const direction = Math.random() > 0.5 ? 1 : -1;
          const stepSize = Math.random() > 0.7 ? 2 : 1; // Occasionally jump a third
          const newIndex = (scaleIndex + direction * stepSize + 7) % 7;
          note = scale.C[newIndex] + lastOctave;
        } else {
          note = chordTones[Math.floor(Math.random() * chordTones.length)] + octave;
        }
      } else {
        // Random scale note
        note = scale.C[Math.floor(Math.random() * scale.C.length)] + octave;
      }
      
      sequence.push(note);
      lastNote = note;
    } else {
      sequence.push(null);
    }
  }
  
  return sequence;
}

// Generate drum fill
function generateDrumFill() {
  return {
    kick: patternBank.kick.fill,
    snare: patternBank.snare.fill,
    hihat: new Array(16).fill(1) // Rapid hi-hats
  };
}

// Get section
function getSection(bar) {
  const pos = bar % 64;
  if (pos < 8) return 'INTRO';
  if (pos < 16) return 'BUILD';
  if (pos < 32) return 'MAIN';
  if (pos < 40) return 'BREAK';
  if (pos < 56) return 'DROP';
  return 'OUTRO';
}

// Check if we're approaching a section change
function isApproachingTransition(bar) {
  const pos = bar % 64;
  const transitionBars = [7, 15, 31, 39, 55, 63];
  return transitionBars.includes(pos);
}

// Generate patterns based on section and energy
function generatePatterns(section, bar, energy) {
  const patterns = {};
  const isFill = isApproachingTransition(bar);
  
  if (isFill) {
    // Drum fill before section change
    const fill = generateDrumFill();
    patterns.kick = fill.kick;
    patterns.snare = fill.snare;
    patterns.hihat = fill.hihat;
  } else {
    // Use classic patterns based on section
    if (section === 'DROP') {
      // Drop uses Chicago or Detroit patterns
      patterns.kick = Math.random() > 0.5 ? patternBank.kick.chicago : patternBank.kick.detroit;
      patterns.snare = energy > 70 ? patternBank.snare.detroit : patternBank.snare.backbeat;
    } else if (section === 'MAIN') {
      // Main section alternates between styles
      const kickStyles = [patternBank.kick.fourOnFloor, patternBank.kick.berlin, patternBank.kick.detroit];
      patterns.kick = kickStyles[Math.floor((bar / 4) % kickStyles.length)];
      patterns.snare = patternBank.snare.backbeat;
    } else if (section === 'BUILD') {
      patterns.kick = patternBank.kick.halfTime;
      patterns.snare = patternBank.snare.minimal;
    } else if (section === 'BREAK') {
      patterns.kick = patternBank.kick.minimal;
      patterns.snare = new Array(16).fill(0);
    } else {
      patterns.kick = patternBank.kick.halfTime;
      patterns.snare = patternBank.snare.minimal;
    }
    
    // Hi-hat density based on energy AND tension
    patterns.hihat = [];
    const hihatDensity = (energy / 100) * 0.5 + (tensionLevel / 100) * 0.5;
    for (let i = 0; i < 16; i++) {
      // More rapid hits at high tension
      if (tensionLevel > 70 && i % 2 === 1) {
        patterns.hihat[i] = 1; // Constant 16ths at high tension
      } else {
        patterns.hihat[i] = Math.random() < hihatDensity ? 1 : 0;
      }
    }
  }
  
  // Stab patterns that complement the acid line
  // Look at where acid pattern has gaps and fill them
  const acidDensity = acidSequence ? acidSequence.filter(n => n).length : 8;
  
  const stabPatterns = [
    [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0], // Single hit on downbeat
    [0,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0], // Single hit midway
    [0,0,0,0, 0,0,0,1, 0,0,0,0, 0,0,0,0], // Single hit on upbeat
    new Array(16).fill(0) // Rest
  ];
  
  // Simplified - sparse stabs for impact
  if (section === 'BREAK') {
    patterns.stab = stabPatterns[3]; // No stabs in break
  } else if (section === 'DROP') {
    // Hit on first bar of drop for impact
    patterns.stab = (bar % 4 === 0) ? stabPatterns[0] : stabPatterns[3];
  } else if (section === 'BUILD') {
    // Occasional stab to build tension
    patterns.stab = (bar % 2 === 1) ? stabPatterns[2] : stabPatterns[3];
  } else if (section === 'MAIN') {
    // Every other bar
    patterns.stab = (bar % 2 === 0) ? stabPatterns[1] : stabPatterns[3];
  } else {
    // INTRO/OUTRO - very minimal
    patterns.stab = (bar % 4 === 0) ? stabPatterns[1] : stabPatterns[3];
  }
  
  return patterns;
}

// Sequences
let kickLoop, snareLoop, hihatLoop, acidLoop, chordLoop, subLoop;

function updatePatterns() {
  const section = getSection(currentBar);
  
  // Update progression if needed
  if (!currentProgression || currentBar % 8 === 0) {
    currentProgression = getChordProgression(section);
  }
  const chordInfo = currentProgression[currentChordIndex % currentProgression.length];
  
  // Generate melodic acid sequence FIRST
  if (currentBar % 2 === 0) {
    acidSequence = generateMelodicAcidSequence(chordInfo, section, acidSequence);
    // Pattern displays were removed with minimized UI
  }
  
  // THEN generate patterns (so stabs can respond to acid)
  const patterns = generatePatterns(section, currentBar, energyLevel);
  
  // Clear and recreate sequences
  if (kickLoop) kickLoop.dispose();
  if (snareLoop) snareLoop.dispose();
  if (hihatLoop) hihatLoop.dispose();
  if (acidLoop) acidLoop.dispose();
  if (chordLoop) chordLoop.dispose();
  if (subLoop) subLoop.dispose();
  
  // Kick with micro-timing
  kickLoop = new Tone.Sequence((time, note) => {
    if (note && !muteStates.kick) {
      // Slight timing variation, but keep kick more stable
      const humanTime = humanize(time, 0.003);
      kick.triggerAttackRelease("C1", "8n", humanTime);
      sidechain.ratio.setValueAtTime(20, humanTime);
      sidechain.ratio.linearRampToValueAtTime(8, humanTime + 0.1);
      Tone.Draw.schedule(() => {
        flashIndicator('kickIndicator');
        // Trigger game beat event
        if (window.GameAPI && window.GameAPI.onBeat) {
          window.GameAPI.onBeat();
        }
      }, humanTime);
    }
  }, patterns.kick, "16n");
  
  // Snare with more looseness
  snareLoop = new Tone.Sequence((time, note) => {
    if (note && !muteStates.snare) {
      const humanTime = humanize(time, 0.005);
      snare.triggerAttackRelease("8n", humanTime);
      Tone.Draw.schedule(() => {
        flashIndicator('snareIndicator');
        // Trigger different enemy type on snare
        if (window.GameAPI && window.GameAPI.onSnare) {
          window.GameAPI.onSnare();
        }
      }, humanTime);
    }
  }, patterns.snare, "16n");
  
  // Hi-hat with most variation
  hihatLoop = new Tone.Sequence((time, note) => {
    if (note && !muteStates.hat) {
      const humanTime = humanize(time, 0.008);
      // Vary between closed and open hi-hats
      const velocity = 0.3 + Math.random() * 0.4;
      const duration = Math.random() > 0.8 ? "16n" : "32n"; // Occasional longer hat
      hihat.triggerAttackRelease(duration, humanTime);
      hihat.volume.setValueAtTime(-15 + (velocity * 10), humanTime); // Subtle volume variation
      Tone.Draw.schedule(() => {
        flashIndicator('hatIndicator');
        // Spawn obstacles on some hi-hat hits
        if (Math.random() < 0.2 && window.GameAPI && window.GameAPI.onHihat) {
          window.GameAPI.onHihat();
        }
      }, humanTime);
    }
  }, patterns.hihat, "16n");
  
  // Acid with melodic sequence - slight timing variations and accent
  acidLoop = new Tone.Sequence((time, note, index) => {
    if (note && !muteStates.acid) {
      const humanTime = humanize(time, 0.004);
      // Add accent to some notes (first beat of each group and random others)
      const isAccent = index % 4 === 0 || (Math.random() > 0.85 && tensionLevel > 50);
      
      if (isAccent) {
        // Accent: louder with more filter modulation
        acid.volume.value = 3;
        acid.filterEnvelope.octaves = 5;
        acidDistortion.wet.value = 0.7;
      } else {
        acid.volume.value = 0;
        acid.filterEnvelope.octaves = 4;
        acidDistortion.wet.value = 0.5;
      }
      
      acid.triggerAttackRelease(note, "16n", humanTime);
      Tone.Draw.schedule(() => {
        flashIndicator('acidIndicator');
        // Spawn power-up occasionally
        if (Math.random() < 0.1 && window.GameAPI && window.GameAPI.onAcid) {
          window.GameAPI.onAcid();
        }
      }, humanTime);
    }
  }, acidSequence, "16n");
  
  // Stabs with slight spread and filter variation
  chordLoop = new Tone.Sequence((time, hit, index) => {
    if (hit && !muteStates.stab) {
      const humanTime = humanize(time, 0.006);
      
      // Vary the filter based on section
      const currentSection = getSection(currentBar);
      if (currentSection === 'DROP') {
        stabFilter.frequency.setValueAtTime(3500, humanTime);
      } else if (currentSection === 'BUILD') {
        // Gradually open filter in builds
        stabFilter.frequency.exponentialRampToValueAtTime(2500, humanTime + 0.2);
      } else {
        stabFilter.frequency.setValueAtTime(2000, humanTime);
      }
      
      // Choose chord voicing based on what acid is doing
      // If acid is playing high, play stabs lower and vice versa
      const acidNote = acidSequence[index];
      let chordToPlay = chordInfo.chord;
      
      if (acidNote && acidNote.includes('3')) {
        // Acid is high, play stabs an octave lower
        chordToPlay = chordInfo.chord.map(note => 
          note.replace(/(\d)/, (match) => parseInt(match) - 1)
        );
      }
      
      // Simple - just play the chord once with slight strum
      chordToPlay.forEach((note, i) => {
        const noteTime = humanTime + i * 0.015; // Slight strum
        raveSynth.triggerAttackRelease(note, "4n", noteTime); // Longer note for reverb tail
      });
      
      Tone.Draw.schedule(() => {
        flashIndicator('stabIndicator');
        // Spawn drifter enemy
        if (window.GameAPI && window.GameAPI.onStab) {
          window.GameAPI.onStab();
        }
      }, humanTime);
    }
  }, patterns.stab, "16n");
  
  // Sub bass pattern - offset from kick to avoid mud
  // Play slightly after the kick hits to avoid frequency clash
  const subPattern = [
    null, chordInfo.bass, null, null,  // Offset by one 16th
    null, null, null, null,
    null, chordInfo.bass, null, null,  // Offset by one 16th
    null, null, null, null
  ];
  subLoop = new Tone.Sequence((time, note) => {
    if (note && !muteStates.sub) {
      const humanTime = humanize(time, 0.002); // Very slight timing variation
      // Play longer note that sustains
      subBass.triggerAttackRelease(note, "2n", humanTime);
      // Add a subtle octave above for presence (only in drops)
      const currentSection = getSection(currentBar);
      if (currentSection === 'DROP' || currentSection === 'MAIN') {
        const octaveUp = note.replace(/\d/, (match) => parseInt(match) + 1);
        subBass.triggerAttackRelease(octaveUp, "2n", humanTime + 0.01, 0.3); // Quieter octave
      }
      Tone.Draw.schedule(() => {
        flashIndicator('subIndicator');
        // Pulse the grid
        if (window.GameAPI && window.GameAPI.onSub) {
          window.GameAPI.onSub();
        }
      }, humanTime);
    }
  }, subPattern, "16n");
  
  kickLoop.start(0);
  snareLoop.start(0);
  hihatLoop.start(0);
  acidLoop.start(0);
  chordLoop.start(0);
  subLoop.start(0);
}

// Apply tension to parameters
function applyTension() {
  const now = Tone.now();
  
  // Both acid filters open with tension
  const baseFreq = 300 + (tensionLevel * 15);
  const targetFreq = baseFreq + (tensionLevel * 25);
  acidFilter1.frequency.linearRampToValueAtTime(targetFreq, now + 0.5);
  acidFilter2.frequency.linearRampToValueAtTime(targetFreq * 0.9, now + 0.5);  // Slightly offset
  acidFilter1.Q.value = 4 + (tensionLevel / 100) * 12;
  acidFilter2.Q.value = 2 + (tensionLevel / 100) * 4;
  
  // Increase distortion with tension
  acidDistortion.distortion = 0.3 + (tensionLevel / 100) * 0.4;
  
  // Master highpass rises with extreme tension
  if (tensionLevel > 80) {
    masterHighpass.frequency.exponentialRampToValueAtTime(100 + (tensionLevel - 80) * 10, now + 0.5);
  } else {
    masterHighpass.frequency.exponentialRampToValueAtTime(20, now + 0.5);
  }
  
  // Sidechain gets more aggressive
  sidechain.ratio.value = 8 + (tensionLevel / 100) * 12;
  
  // Start/stop noise riser
  if (tensionLevel > 60 && !riserActive) {
    noiseRiser.start();
    riserEnvelope.triggerAttack();
    riserActive = true;
  } else if (tensionLevel <= 60 && riserActive) {
    riserEnvelope.triggerRelease();
    setTimeout(() => noiseRiser.stop(), 500);
    riserActive = false;
  }
  
  // Riser volume follows tension
  if (riserActive) {
    noiseRiser.volume.value = -40 + (tensionLevel - 60) * 0.5;
  }
}

// Automation curves for smooth transitions
function applyAutomation(section, prevSection) {
  const now = Tone.now();
  
  // Filter automation for both cascaded filters
  if (section === 'DROP' && prevSection !== 'DROP') {
    acidFilter1.frequency.exponentialRampToValueAtTime(2000, now + 2);
    acidFilter2.frequency.exponentialRampToValueAtTime(1800, now + 2);
    acidFilter1.Q.linearRampToValueAtTime(15, now + 2);
    acidDistortion.distortion = 0.6;
  } else if (section === 'BREAK') {
    acidFilter1.frequency.exponentialRampToValueAtTime(400, now + 1);
    acidFilter2.frequency.exponentialRampToValueAtTime(400, now + 1);
    acidFilter1.Q.linearRampToValueAtTime(5, now + 1);
    acidDistortion.distortion = 0.2;
  } else if (section === 'BUILD') {
    acidFilter1.frequency.exponentialRampToValueAtTime(1200, now + 4);
    acidFilter2.frequency.exponentialRampToValueAtTime(1100, now + 4);
  }
}

// Main evolution function
function evolve() {
  const section = getSection(currentBar);
  const nextBar = (currentBar + 1) % 64;
  const nextSection = getSection(nextBar);
  
  // Update displays
  document.getElementById('section').textContent = section;
  document.getElementById('bar').textContent = currentBar;
  const currentChord = currentProgression ? currentProgression[currentChordIndex % currentProgression.length] : { root: 'C' };
  document.getElementById('chord').textContent = currentChord.root + (currentChord.chord.length > 3 ? '7' : 'm');
  
  // Calculate next transition
  const barsUntilNext = nextSection !== section ? 1 : 
    nextBar < 8 ? 8 - nextBar :
    nextBar < 16 ? 16 - nextBar :
    nextBar < 32 ? 32 - nextBar :
    nextBar < 40 ? 40 - nextBar :
    nextBar < 56 ? 56 - nextBar :
    64 - nextBar;
  document.getElementById('nextSection').textContent = 
    nextSection !== section ? `${nextSection} next bar` : 
    `${getSection(currentBar + barsUntilNext)} in ${barsUntilNext} bars`;
  
  // Apply automation on section changes
  if (section !== lastSection) {
    applyAutomation(section, lastSection);
    lastSection = section;
  }
  
  // Update patterns every bar
  if (currentBar % 1 === 0) {
    updatePatterns();
  }
  
  // Apply tension continuously
  applyTension();
  
  // Vary chord progression rate based on section (already declared above)
  if (section === 'DROP' || section === 'MAIN') {
    // Change chord every 2 bars for more movement
    if (currentBar % 2 === 0) {
      currentChordIndex = (currentChordIndex + 1) % (currentProgression ? currentProgression.length : 4);
    }
  } else if (section === 'BREAK') {
    // Stay on same chord for whole break - hypnotic
    currentChordIndex = 0;
  } else {
    // Normal progression every 4 bars
    if (currentBar % 4 === 0) {
      currentChordIndex = (currentChordIndex + 1) % (currentProgression ? currentProgression.length : 4);
    }
  }
  
  currentBar = (currentBar + 1) % 64;
}

// Schedule evolution
Tone.Transport.scheduleRepeat(() => evolve(), "1m");

// Controls
document.getElementById('playBtn').addEventListener('click', async () => {
  await Tone.start();
  currentBar = 0;
  currentChordIndex = 0;
  lastSection = '';
  updatePatterns();
  Tone.Transport.start();
  document.getElementById('status').textContent = 'PLAYING';
});

document.getElementById('stopBtn').addEventListener('click', () => {
  Tone.Transport.stop();
  Tone.Transport.cancel();
  currentBar = 0;
  document.getElementById('status').textContent = 'STOPPED';
});

document.getElementById('bpmSlider').addEventListener('input', (e) => {
  const bpm = parseInt(e.target.value);
  Tone.Transport.bpm.value = bpm;
  document.getElementById('bpmDisplay').textContent = bpm;
});

document.getElementById('energySlider').addEventListener('input', (e) => {
  energyLevel = parseInt(e.target.value);
  document.getElementById('energyDisplay').textContent = energyLevel;
});

document.getElementById('tensionSlider').addEventListener('input', (e) => {
  tensionLevel = parseInt(e.target.value);
  document.getElementById('tensionDisplay').textContent = tensionLevel;
  // Apply tension immediately when slider moves
  if (Tone.Transport.state === 'started') {
    applyTension();
  }
});

// Sound selector
document.getElementById('soundSelector').addEventListener('change', (e) => {
  gameSounds.currentLaserSound = parseInt(e.target.value);
  document.getElementById('soundDisplay').textContent = e.target.options[e.target.selectedIndex].text;
});

// Initial BPM
Tone.Transport.bpm.value = 132;

// Track square handlers for minimized controls
['kick', 'snare', 'hat', 'acid', 'stab', 'sub'].forEach(track => {
  const square = document.getElementById(track + 'Square');
  if (square) {
    // Initialize as active (not muted)
    square.classList.add('active');
    
    square.addEventListener('click', () => {
      muteStates[track] = !muteStates[track];
      if (muteStates[track]) {
        square.classList.remove('active');
        square.classList.add('muted');
      } else {
        square.classList.add('active');
        square.classList.remove('muted');
      }
    });
  }
});

// Expand/minimize panel with smooth animation
const expandBtn = document.getElementById('expandBtn');
const minimizeBtn = document.getElementById('minimizeBtn');
const expandedPanel = document.getElementById('expandedPanel');

if (expandBtn) {
  expandBtn.addEventListener('click', () => {
    if (expandedPanel.classList.contains('expanded')) {
      // Panel is open, close it
      expandedPanel.classList.remove('expanded');
      expandBtn.innerHTML = '⚙';
    } else {
      // Panel is closed, open it
      expandedPanel.classList.add('expanded');
      expandBtn.innerHTML = '▼';
    }
  });
}

if (minimizeBtn) {
  minimizeBtn.addEventListener('click', () => {
    expandedPanel.classList.remove('expanded');
    expandBtn.innerHTML = '⚙';
  });
}

// Game sounds that blend with the music - route through sidechain for cohesion
const gameReverb = new Tone.Reverb({
  decay: 0.5,
  wet: 0.2
}).connect(sidechain);

// Game sound effects - musical and in-key
const gameSounds = {
  // Movement - subtle filter sweep in key
  move: new Tone.MonoSynth({
    oscillator: { type: "sine" },
    envelope: { attack: 0.001, decay: 0.02, sustain: 0, release: 0.01 },
    filter: { frequency: 2000, rolloff: -12, Q: 5 },
    filterEnvelope: { attack: 0.001, decay: 0.02, sustain: 0, release: 0.01, baseFrequency: 800, octaves: 1 },
    volume: -18
  }).connect(gameReverb),
  
  // Multiple laser sounds that complement the music
  laserSounds: [
    // 0: Original - Triangle wave with filter sweep
    new Tone.MonoSynth({
      oscillator: { type: "triangle" },
      envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.01 },
      filter: { frequency: 3000, rolloff: -12 },
      filterEnvelope: { attack: 0.001, decay: 0.03, sustain: 0, release: 0.01, baseFrequency: 1500, octaves: -1 },
      volume: -12
    }).connect(sidechain),
    
    // 1: Acid stab - mimics the 303 acid line
    new Tone.MonoSynth({
      oscillator: { type: "sawtooth" },
      envelope: { attack: 0.001, decay: 0.03, sustain: 0, release: 0.02 },
      filter: { frequency: 2000, rolloff: -24, Q: 8 },
      filterEnvelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.02, baseFrequency: 800, octaves: 2 },
      volume: -10
    }).connect(acidFilter1), // Route through acid filter for consistency
    
    // 2: Chord stab - harmonizes with the techno stabs
    new Tone.PolySynth(Tone.Synth, {
      oscillator: { type: "square4" },
      envelope: { attack: 0.001, decay: 0.02, sustain: 0, release: 0.01 },
      volume: -14
    }).connect(stabReverb), // Use the stab reverb for space
    
    // 3: Echo Pulse - metallic sound with delay
    new Tone.MonoSynth({
      oscillator: { type: "pulse", width: 0.2 },
      envelope: { attack: 0.001, decay: 0.04, sustain: 0.2, release: 0.05 },
      filter: { frequency: 4000, rolloff: -12, Q: 3 },
      filterEnvelope: { attack: 0.001, decay: 0.02, sustain: 0.5, release: 0.02, baseFrequency: 2000, octaves: 2 },
      volume: -8
    }).connect(new Tone.FeedbackDelay("16n", 0.5).connect(gameReverb)), // Add echo effect
    
    // 4: Pluck - organic melodic sound
    new Tone.PluckSynth({
      attackNoise: 0.8,
      dampening: 4000,
      resonance: 0.9,
      volume: -10
    }).connect(gameReverb),
    
    // 5: Pew Pew - classic laser with pitch sweep
    new Tone.MonoSynth({
      oscillator: { type: "sine" },
      envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.05 },
      portamento: 0.08, // Glide between pitches
      volume: -6
    }).connect(sidechain)
  ],
  
  currentLaserSound: 0, // Track which sound to use
  
  // Explosion - filtered noise burst that sounds like a snare hit
  explosion: new Tone.NoiseSynth({
    noise: { type: "pink" },
    envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.02 },
    volume: -8
  }).connect(new Tone.Filter(1200, "highpass").connect(sidechain)),
  
  // Enemy destroy - distorted version of the enemy spawn sound
  enemyDestroy: new Tone.MonoSynth({
    oscillator: { type: "sawtooth" },
    envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1 },
    filter: { frequency: 800, rolloff: -24, Q: 8 },
    filterEnvelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1, baseFrequency: 200, octaves: 2 },
    volume: -10
  }).connect(new Tone.Distortion(0.8).connect(sidechain)),
  
  // Obstacle hit - low thud with pitch bend
  obstacleHit: new Tone.MonoSynth({
    oscillator: { type: "sine" },
    envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.05 },
    portamento: 0.01,
    volume: -8
  }).connect(new Tone.Filter(400, "lowpass").connect(sidechain)),
  
  // Power-up - use same synth style as acid for consistency
  powerUp: new Tone.MonoSynth({
    oscillator: { type: "sawtooth" },
    envelope: { attack: 0.001, decay: 0.1, sustain: 0.1, release: 0.2 },
    filter: { frequency: 2000, rolloff: -12, Q: 3 },
    filterEnvelope: { attack: 0.001, decay: 0.2, sustain: 0.3, release: 0.2, baseFrequency: 400, octaves: 3 },
    volume: -10
  }).connect(acidFilter1) // Route through acid filter for consistency
};

// Helper to get notes in current scale
function getGameNote(index) {
  const scales = {
    minor: ["C", "D", "Eb", "F", "G", "Ab", "Bb"],
    dorian: ["C", "D", "Eb", "F", "G", "A", "Bb"],
    phrygian: ["C", "Db", "Eb", "F", "G", "Ab", "Bb"]
  };
  const scale = scales.minor; // Default to minor
  return scale[index % scale.length];
}

// Initialize Phaser game - use most of viewport
const WIDTH = window.innerWidth;
const HEIGHT = window.innerHeight
const LANES=5, LANE_W=WIDTH/LANES;

// Session highscore tracking
let sessionHighScore = 0;
// Persistent grid setting
let gridEnabled = true;
// Game dimensions initialized based on viewport
const PLAYER_Y=HEIGHT-60, ENEMY_SPEED_BASE=200, BULLET_SPEED=520, FIRE_COOLDOWN=110;

// Startup screen scene
class StartupScene extends Phaser.Scene {
  constructor() {
    super({ key: 'StartupScene' });
  }
  
  create() {
    const WIDTH = this.cameras.main.width;
    const HEIGHT = this.cameras.main.height;
    
    // Black background
    this.cameras.main.setBackgroundColor('#000');
    
    // Create grid effect in background
    const gridGraphics = this.add.graphics();
    gridGraphics.lineStyle(1, 0x00ff00, 0.1);
    
    // Vertical lines
    for(let x = 0; x < WIDTH; x += 40) {
      gridGraphics.lineBetween(x, 0, x, HEIGHT);
    }
    // Horizontal lines  
    for(let y = 0; y < HEIGHT; y += 40) {
      gridGraphics.lineBetween(0, y, WIDTH, y);
    }
    
    // Animated scan line effect
    const scanline = this.add.rectangle(0, 0, WIDTH, 3, 0x00ff00, 0.5);
    this.tweens.add({
      targets: scanline,
      y: HEIGHT,
      duration: 3000,
      repeat: -1,
      ease: 'Linear'
    });
    
    // Title with glow effect
    const titleStyle = {
      font: 'bold 72px monospace',
      fill: '#00ffcc',
      stroke: '#00ffcc',
      strokeThickness: 2,
      shadow: {
        offsetX: 0,
        offsetY: 0,
        color: '#00ffcc',
        blur: 20,
        fill: true
      }
    };
    
    const title = this.add.text(WIDTH/2, HEIGHT/3, 'BEATRIDER', titleStyle);
    title.setOrigin(0.5);
    
    // Pulsing glow animation for title
    this.tweens.add({
      targets: title,
      scaleX: 1.05,
      scaleY: 1.05,
      duration: 1000,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });
    
    // Subtitle with typewriter effect
    const subtitleText = 'MELODIC TECHNO EDITION';
    const subtitle = this.add.text(WIDTH/2, HEIGHT/3 + 80, '', {
      font: '24px monospace',
      fill: '#ff00ff',
      stroke: '#ff00ff',
      strokeThickness: 1
    });
    subtitle.setOrigin(0.5);
    
    // Typewriter effect
    let charIndex = 0;
    this.time.addEvent({
      delay: 100,
      callback: () => {
        if(charIndex < subtitleText.length) {
          subtitle.text += subtitleText[charIndex];
          charIndex++;
        }
      },
      repeat: subtitleText.length - 1
    });
    
    // Instructions
    const instructions = [
      'ARROWS/A/D - MOVE',
      'W/UP - JUMP',
      'SPACE - FIRE',
      'G - TOGGLE GRID'
    ];
    
    instructions.forEach((text, index) => {
      const instruction = this.add.text(WIDTH/2, HEIGHT/2 + 40 + index * 30, text, {
        font: '18px monospace',
        fill: '#00ff00'
      });
      instruction.setOrigin(0.5);
      instruction.setAlpha(0);
      
      // Fade in with delay
      this.tweens.add({
        targets: instruction,
        alpha: 1,
        delay: 1500 + index * 200,
        duration: 500
      });
    });
    
    // Press start message
    const startText = this.add.text(WIDTH/2, HEIGHT - 100, 'PRESS SPACE TO START', {
      font: 'bold 28px monospace',
      fill: '#ffff00',
      stroke: '#ffff00',
      strokeThickness: 1
    });
    startText.setOrigin(0.5);
    
    // Blinking effect
    this.tweens.add({
      targets: startText,
      alpha: 0,
      duration: 500,
      yoyo: true,
      repeat: -1
    });
    
    // Retro computer boot sequence text
    const bootLines = [
      'INITIALIZING BEAT DETECTION SYSTEM...',
      'LOADING MELODIC ALGORITHMS...',
      'CALIBRATING PERSPECTIVE MATRIX...',
      'SYNTHESIZERS ONLINE',
      'SYSTEM READY'
    ];
    
    const bootY = 60;
    bootLines.forEach((line, index) => {
      this.time.delayedCall(index * 300, () => {
        const bootText = this.add.text(40, bootY + index * 20, '> ' + line, {
          font: '14px monospace',
          fill: '#0f0'
        });
        
        // Type-in effect for boot text
        bootText.setAlpha(0);
        this.tweens.add({
          targets: bootText,
          alpha: 1,
          duration: 200
        });
        
        // Add a blinking cursor after the last line
        if(index === bootLines.length - 1) {
          const cursor = this.add.text(bootText.x + bootText.width + 5, bootText.y, '_', {
            font: '14px monospace',
            fill: '#0f0'
          });
          this.tweens.add({
            targets: cursor,
            alpha: 0,
            duration: 400,
            yoyo: true,
            repeat: -1
          });
        }
      });
    });
    
    // Floating particles in background
    for(let i = 0; i < 30; i++) {
      const particle = this.add.circle(
        Math.random() * WIDTH,
        Math.random() * HEIGHT,
        Math.random() * 2 + 1,
        0x00ff00,
        Math.random() * 0.3 + 0.1
      );
      
      this.tweens.add({
        targets: particle,
        y: particle.y - HEIGHT - 100,
        duration: Math.random() * 10000 + 10000,
        repeat: -1,
        delay: Math.random() * 5000
      });
    }
    
    // Listen for space key to start
    this.input.keyboard.once('keydown-SPACE', async () => {
      // Start Tone.js from user gesture
      if (typeof Tone !== 'undefined') {
        await Tone.start();
      }
      
      // Transition to game
      this.cameras.main.fadeOut(500, 0, 0, 0);
      this.time.delayedCall(500, () => {
        this.scene.start('Main');
      });
    });
    
    // Also support click/touch to start  
    this.input.once('pointerdown', async () => {
      // Start Tone.js from user gesture
      if (typeof Tone !== 'undefined') {
        await Tone.start();
      }
      
      // Transition to game
      this.cameras.main.fadeOut(500, 0, 0, 0);
      this.time.delayedCall(500, () => {
        this.scene.start('Main');
      });
    });
  }
}

class Main extends Phaser.Scene {
  constructor() {
    super({ key: 'Main' });
  }
  updateSoundDisplay() {
    const soundNames = ['Triangle', 'Acid', 'Chord', 'Sub', 'Pluck', 'Pew Pew'];
    const display = document.getElementById('soundDisplay');
    if (display) {
      display.textContent = soundNames[gameSounds.currentLaserSound];
    }
  }
  
  createStarfield() {
    // Create three layers of stars for parallax effect
    this.stars = [
      [], // Far stars (slow)
      [], // Medium stars
      []  // Near stars (fast)
    ];
    
    const starColors = [0x666666, 0x999999, 0xbbbbbb];
    const starCounts = [100, 50, 25];
    const starSizes = [1, 1.5, 2];
    
    this.starGraphics = this.add.graphics();
    
    // Generate random stars for each layer - they start at random positions along their path
    for(let layer = 0; layer < 3; layer++) {
      for(let i = 0; i < starCounts[layer]; i++) {
        this.stars[layer].push({
          // Stars spread across the whole screen area
          baseX: Math.random() * WIDTH * 2 - WIDTH/2, // Can be off-screen horizontally
          baseY: Math.random() * HEIGHT * 2 - HEIGHT, // Can go above and below screen
          progress: Math.random(), // Random starting position along path
          speed: (layer + 1) * 0.3, // Different speeds for parallax
          size: starSizes[layer],
          color: starColors[layer],
          twinkle: Math.random() * Math.PI * 2 // Random twinkle phase
        });
      }
    }
  }
  
  updateStarfield(dt) {
    if (!this.starGraphics) return; // Safety check
    this.starGraphics.clear();
    const vanishY = HEIGHT * 0.15;
    const vanishX = WIDTH / 2;
    
    // Update and draw each star layer
    for(let layer = 0; layer < 3; layer++) {
      for(let star of this.stars[layer]) {
        // Move stars along perspective (increase progress)
        star.progress += star.speed * (dt/1000);
        
        // Wrap around when star passes the player
        if(star.progress > 1.2) {
          star.progress = 0;
          star.baseX = Math.random() * WIDTH * 2 - WIDTH/2; // New random X spread
          star.baseY = Math.random() * HEIGHT * 2 - HEIGHT; // New random Y spread
        }
        
        // Calculate positions - stars follow same exponential curve as grid
        const curvedProgress = Math.pow(star.progress, 2.5); // Same curve as grid/objects
        const y = vanishY + (star.baseY - vanishY) * curvedProgress;
        const x = vanishX + (star.baseX - vanishX) * curvedProgress;
        
        // Skip stars that are off-screen
        if(x < -50 || x > WIDTH + 50) continue;
        
        // Scale based on distance (smaller when far)
        const size = star.size * (0.1 + star.progress * 1.5);
        
        // Add subtle twinkling and fade based on distance
        star.twinkle += dt * 0.003;
        const twinkleAlpha = 0.8 + Math.sin(star.twinkle) * 0.2;
        const distanceAlpha = Math.min(1, star.progress * 2); // Fade in as they approach
        const alpha = twinkleAlpha * distanceAlpha * 0.85;
        
        // Draw star
        this.starGraphics.fillStyle(star.color, alpha);
        this.starGraphics.fillCircle(x, y, size);
      }
    }
  }
  
  create(){
    this.cameras.main.setBackgroundColor('#000');
    
    // Create starfield background FIRST
    this.createStarfield();
    
    // Start the music automatically when game starts
    if (typeof Tone !== 'undefined' && Tone.Transport.state !== 'started') {
      // Tone should already be started from the startup screen
      currentBar = 0;
      currentChordIndex = 0;
      lastSection = '';
      updatePatterns();
      Tone.Transport.start();
      if (document.getElementById('status')) {
        document.getElementById('status').textContent = 'PLAYING';
      }
    }
    
    // Initialize trail system
    this.trails = [];
    this.trailGraphics = this.add.graphics();
    
    const gfx=this.make.graphics({x:0,y:0,add:false});
    gfx.fillStyle(0x00ffcc,1).fillRect(0,0,24,24).generateTexture('playerTex',24,24).clear();
    gfx.fillStyle(0xff3366,1).fillRect(0,0,20,20).generateTexture('enemyTex',20,20).clear();
    gfx.fillStyle(0xffff00,1).fillTriangle(10,0,0,20,20,20).generateTexture('fastEnemyTex',20,20).clear();
    gfx.fillStyle(0xffffff,1).fillRect(0,0,6,12).generateTexture('bulletTex',6,12).clear();
    // Purple blocker with neon glow effect (2x size: 60x16 instead of 30x8)
    gfx.fillStyle(0xff00ff,0.3).fillRect(0,0,60,16); // Outer glow
    gfx.fillStyle(0xcc66ff,0.6).fillRect(4,2,52,12); // Mid glow  
    gfx.fillStyle(0xbf40ff,1).fillRect(8,4,44,8);    // Core
    gfx.generateTexture('obstacleTex',60,16).clear();
    gfx.fillStyle(0x00ff00,1).fillCircle(10,10,10).generateTexture('powerUpTex',20,20).clear(); // Green power-up
    gfx.fillStyle(0xff00ff,1).fillStyle(0xff00ff,1).fillRect(2,2,16,16).generateTexture('drifterTex',20,20).destroy(); // Magenta drifter

    this.playerLane=2; 
    this.player=this.add.image(this._laneX(this.playerLane), PLAYER_Y, 'playerTex');
    this.player.w = 24; // Add collision dimensions
    this.player.h = 24;
    this.enemies=[]; 
    this.bullets=[]; 
    this.obstacles = [];
    this.powerUps = [];
    this.lastShotAt=0;
    this.rapidFire = false;
    this.rapidFireTimer = 0;
    this.offScreenTimer = 0; // Timer for rubber band effect
    this.isMoving = false; // Prevent shooting while transitioning
    this.isJumping = false; // Track jump state
    this.keys=this.input.keyboard.addKeys('LEFT,RIGHT,UP,A,D,W,SPACE,G,ONE,TWO,THREE,FOUR,FIVE,SIX');
    this.score=0; 
    this.beats=0; 
    this.scoreText=this.add.text(10, HEIGHT-24, 'score 0', {font:'16px monospace', fill:'#0f0'});
    this.highScoreText=this.add.text(10, HEIGHT-48, 'high ' + sessionHighScore, {font:'16px monospace', fill:'#ff0'});
    this.gridVisible = gridEnabled; // Use persistent grid setting
    this.gridText=this.add.text(10, 10, 'GRID: ' + (gridEnabled ? 'ON' : 'OFF') + ' [G]', {font:'12px monospace', fill:'#0f0'});

    // Mobile controls setup
    this.setupMobileControls();
    
    // Add mobile control hints (only on touch devices)
    if(this.input.activePointer.wasTouch || 'ontouchstart' in window) {
      const controlsText = this.add.text(WIDTH/2, HEIGHT - 80, 
        'SWIPE: Move • SWIPE UP: Jump • TAP: Fire • HOLD: Auto-fire', 
        {font:'12px monospace', fill:'#0f0', alpha: 0.5}
      );
      controlsText.setOrigin(0.5);
      // Fade out after 5 seconds
      this.tweens.add({
        targets: controlsText,
        alpha: 0,
        delay: 5000,
        duration: 1000
      });
    }

    // GameAPI is triggered by our drums
    window.GameAPI = {
      onBeat: ()=>{ 
        this.beats++; 
        const speed=ENEMY_SPEED_BASE + Math.floor(this.beats/16)*30; 
        // Always spawn on kick
        const lane = Phaser.Math.Between(0,LANES-1);
        this._spawnEnemy(lane, speed, 'enemyTex'); 
      },
      onSnare: ()=>{ 
        // Fast yellow enemies on snare hits - always spawn
        const speed=ENEMY_SPEED_BASE * 1.5 + Math.floor(this.beats/16)*30; 
        const lane = Phaser.Math.Between(0,LANES-1);
        this._spawnEnemy(lane, speed, 'fastEnemyTex'); 
      },
      onHihat: ()=>{
        // Spawn obstacles that block shots
        const lane = Phaser.Math.Between(0,LANES-1);
        this._spawnObstacle(lane);
      },
      onAcid: ()=>{
        // Spawn power-up for rapid fire
        const lane = Phaser.Math.Between(0,LANES-1);
        this._spawnPowerUp(lane);
      },
      onStab: ()=>{
        // Spawn lane-changing enemy
        const lane = Phaser.Math.Between(0,LANES-1);
        this._spawnDrifter(lane);
      },
      onSub: ()=>{
        // Pulse the grid
        this._pulseGrid();
      },
      reset: ()=>{ this.scene.restart(); }
    };
  }

  setupMobileControls() {
    // Touch control state
    this.touchStartX = 0;
    this.touchStartY = 0;
    this.touchStartTime = 0;
    this.isTouchFiring = false;
    this.swipeThreshold = 50; // Minimum distance for swipe
    this.swipeTimeLimit = 300; // Max time for swipe gesture (ms)
    
    // Touch start - anywhere on screen
    this.input.on('pointerdown', (pointer) => {
      this.touchStartX = pointer.x;
      this.touchStartY = pointer.y;
      this.touchStartTime = this.time.now;
      
      // Start firing timer for hold-to-fire
      this.fireHoldTimer = this.time.delayedCall(200, () => {
        this.isTouchFiring = true;
      });
    });
    
    // Touch move - detect swipes
    this.input.on('pointermove', (pointer) => {
      if (!pointer.isDown) return;
      
      const dx = pointer.x - this.touchStartX;
      const dy = pointer.y - this.touchStartY;
      const elapsed = this.time.now - this.touchStartTime;
      
      // Check for swipe gestures (quick movements)
      if (elapsed < this.swipeTimeLimit) {
        // Horizontal swipe
        if (Math.abs(dx) > this.swipeThreshold && Math.abs(dx) > Math.abs(dy)) {
          if (dx > 0 && !this.isMoving) {
            // Swipe right
            this.moveRight();
            this.touchStartX = pointer.x; // Reset for continuous swipes
          } else if (dx < 0 && !this.isMoving) {
            // Swipe left
            this.moveLeft();
            this.touchStartX = pointer.x; // Reset for continuous swipes
          }
        }
        
        // Vertical swipe up for jump
        if (dy < -this.swipeThreshold && Math.abs(dy) > Math.abs(dx)) {
          if (!this.isJumping) {
            this.jump();
            this.touchStartY = pointer.y; // Reset for next swipe
          }
        }
      }
    });
    
    // Touch end
    this.input.on('pointerup', (pointer) => {
      // Cancel firing timer if it hasn't triggered yet
      if (this.fireHoldTimer) {
        this.fireHoldTimer.remove();
        this.fireHoldTimer = null;
      }
      
      // Stop firing
      this.isTouchFiring = false;
      
      // Check for tap (no significant movement and quick release)
      const dx = pointer.x - this.touchStartX;
      const dy = pointer.y - this.touchStartY;
      const elapsed = this.time.now - this.touchStartTime;
      
      if (Math.abs(dx) < 20 && Math.abs(dy) < 20 && elapsed < 200) {
        // It's a tap - fire once
        this._fire();
      }
    });
  }

  moveLeft() {
    if(this.isMoving) return;
    this.playerLane=Math.max(-1,this.playerLane-1); // Can go to -1 (off-screen left)
    const targetX = this._laneX(this.playerLane);
    
    // Check if we're jumping for special animation
    if(this.isJumping) {
      // Mid-air twirl animation
      this.isMoving = true;
      this.tweens.add({
        targets: this.player,
        x: targetX,
        duration: 200,
        ease: 'Quad.easeOut',
        onComplete: () => {
          this.isMoving = false;
        }
      });
      
      // Add horizontal spin (barrel roll to the left)
      this.tweens.add({
        targets: this.player,
        angle: '-=360', // Spin counterclockwise
        duration: 300,
        ease: 'Cubic.easeOut'
      });
      
      // Add extra flair with scale pulse
      this.tweens.add({
        targets: this.player,
        scaleX: 1.5,
        scaleY: 0.7,
        duration: 100,
        yoyo: true,
        ease: 'Sine.easeInOut'
      });
    } else {
      // Ground movement - original animation
      this.isMoving = true;
      this.tweens.add({
        targets: this.player,
        x: targetX,
        duration: 150,
        ease: 'Sine.easeInOut',
        onStart: () => {
          // Squash and tilt during movement
          this.player.setScale(0.8, 1.2);
          this.player.angle = -15; // Tilt left
        },
        onComplete: () => {
          this.player.setScale(1, 1);
          this.player.angle = 0;
          this.isMoving = false;
        }
      });
    }
    
    // Reset rubber band timer when moving off-screen
    if(this.playerLane < 0 || this.playerLane >= LANES){
      this.offScreenTimer = 800; // 800ms before rubber band pulls back
      this.player.setAlpha(0.7); // Semi-transparent when off-screen
    } else {
      this.player.setAlpha(1);
    }
    // Play movement sound
    try {
      const note = getGameNote(Math.max(0, Math.min(4, this.playerLane))) + "5";
      gameSounds.move.triggerAttackRelease(note, "32n");
    } catch(e) {}
  }

  moveRight() {
    if(this.isMoving) return;
    this.playerLane=Math.min(LANES,this.playerLane+1); // Can go to 5 (off-screen right)
    const targetX = this._laneX(this.playerLane);
    
    // Check if we're jumping for special animation
    if(this.isJumping) {
      // Mid-air twirl animation
      this.isMoving = true;
      this.tweens.add({
        targets: this.player,
        x: targetX,
        duration: 200,
        ease: 'Quad.easeOut',
        onComplete: () => {
          this.isMoving = false;
        }
      });
      
      // Add horizontal spin (barrel roll to the right)
      this.tweens.add({
        targets: this.player,
        angle: '+=360', // Spin clockwise
        duration: 300,
        ease: 'Cubic.easeOut'
      });
      
      // Add extra flair with scale pulse
      this.tweens.add({
        targets: this.player,
        scaleX: 1.5,
        scaleY: 0.7,
        duration: 100,
        yoyo: true,
        ease: 'Sine.easeInOut'
      });
    } else {
      // Ground movement - original animation
      this.isMoving = true;
      this.tweens.add({
        targets: this.player,
        x: targetX,
        duration: 150,
        ease: 'Sine.easeInOut',
        onStart: () => {
          // Squash and tilt during movement
          this.player.setScale(0.8, 1.2);
          this.player.angle = 15; // Tilt right
        },
        onComplete: () => {
          this.player.setScale(1, 1);
          this.player.angle = 0;
          this.isMoving = false;
        }
      });
    }
    
    // Reset rubber band timer when moving off-screen
    if(this.playerLane < 0 || this.playerLane >= LANES){
      this.offScreenTimer = 800; // 800ms before rubber band pulls back
      this.player.setAlpha(0.7); // Semi-transparent when off-screen
    } else {
      this.player.setAlpha(1);
    }
    // Play movement sound
    try {
      const note = getGameNote(Math.max(0, Math.min(4, this.playerLane))) + "5";
      gameSounds.move.triggerAttackRelease(note, "32n");
    } catch(e) {}
  }

  jump() {
    if(this.isJumping) return;
    this.isJumping = true;
    
    // Jump animation - higher jump to clear obstacles better
    this.tweens.add({
      targets: this.player,
      y: PLAYER_Y - 120, // Higher jump
      scaleX: 1.2,
      scaleY: 1.2,
      duration: 250,
      ease: 'Quad.easeOut',
      yoyo: true,
      onComplete: () => {
        this.isJumping = false;
        this.player.y = PLAYER_Y;
        // Reset rotation if no mid-air move was performed
        if(Math.abs(this.player.angle % 360) < 10) {
          this.player.angle = 0;
        }
      }
    });
    
    // Only do a simple forward flip if no directional input
    // Mid-air directional moves will override this
    this.jumpSpinTween = this.tweens.add({
      targets: this.player,
      angle: 360,
      duration: 500, // Match total jump time (250 * 2)
      ease: 'Linear'
    });
    
    // Jump sound effect
    try {
      const now = Tone.now();
      gameSounds.move.triggerAttackRelease("C6", "16n", now);
      gameSounds.move.triggerAttackRelease("G6", "16n", now + 0.05);
    } catch(e) {}
  }

  _laneX(lane, progress = 1){ 
    // Interpolate X position between vanishing point and lane position based on progress
    const vanishX = WIDTH / 2;
    // Clamp off-screen lanes to be partially visible
    let clampedLane = lane;
    if(lane < 0) {
      clampedLane = -0.7; // Show 30% of ship on left edge
    } else if(lane >= LANES) {
      clampedLane = LANES - 0.3; // Show 30% of ship on right edge
    }
    const bottomLaneX = clampedLane * LANE_W + LANE_W / 2;
    return vanishX + (bottomLaneX - vanishX) * progress;
  }
  _spawnEnemy(lane, speed, texture='enemyTex'){ 
    const vanishY = HEIGHT * 0.15; // Same horizon as grid
    const e=this.add.image(this._laneX(lane, 0), vanishY, texture); // Start at vanishing point
    e.lane = lane;
    e.progress = 0; // 0 = at horizon, 1 = at player
    e.vy=speed; 
    e.baseSize = texture === 'fastEnemyTex' ? 25 : 20;
    e.w=e.baseSize; e.h=e.baseSize; 
    e.enemyType = texture; // Track enemy type
    e.setScale(0.1); // Start tiny at horizon
    e.trailPoints = []; // Store trail history
    this.enemies.push(e); 
  }
  
  _createSplatEffect(x, y) {
    // Create a splat/squish effect for hitting walls
    const splatColor = 0x00ffcc;
    
    // Main splat circle that expands and fades
    const splat = this.add.circle(x, y, 10, splatColor, 1);
    this.tweens.add({
      targets: splat,
      scaleX: 4,
      scaleY: 0.5, // Squish vertically
      alpha: 0,
      duration: 400,
      ease: 'Power2',
      onComplete: () => splat.destroy()
    });
    
    // Splatter particles that spray outward
    for(let i = 0; i < 12; i++) {
      const particle = this.add.rectangle(x, y, 8, 8, splatColor);
      const angle = (Math.PI * 2 / 12) * i;
      const speed = 150 + Math.random() * 100;
      
      // Particles spray more horizontally than vertically
      const xVel = Math.cos(angle) * speed * 1.5;
      const yVel = Math.sin(angle) * speed * 0.5;
      
      this.tweens.add({
        targets: particle,
        x: x + xVel,
        y: y + yVel,
        scaleX: 0.2,
        scaleY: 2, // Stretch vertically as they fall
        alpha: 0,
        rotation: Math.random() * Math.PI,
        duration: 600,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    }
    
    // Screen flash
    this.cameras.main.flash(200, 0, 255, 204, true);
  }
  
  _createDeathExplosion(playerX, playerY, enemyX, enemyY) {
    // Multi-stage explosion for dramatic effect
    const colors = [0x00ffcc, 0xff3366, 0xffff00, 0xffffff];
    
    // Stage 1: Initial impact
    this._createExplosion(playerX, playerY, 0x00ffcc, 25);
    this._createExplosion(enemyX, enemyY, 0xff3366, 15);
    
    // Stage 2: Shockwave ring
    const ring = this.add.circle(playerX, playerY, 20, 0xffffff, 0);
    ring.setStrokeStyle(4, 0x00ffff, 1);
    this.tweens.add({
      targets: ring,
      scale: 5,
      alpha: 0,
      duration: 500,
      ease: 'Power2',
      onComplete: () => ring.destroy()
    });
    
    // Stage 3: Delayed secondary explosions
    this.time.delayedCall(100, () => {
      for(let i = 0; i < 3; i++) {
        const offsetX = (Math.random() - 0.5) * 60;
        const offsetY = (Math.random() - 0.5) * 60;
        this._createExplosion(playerX + offsetX, playerY + offsetY, colors[i % colors.length], 10);
      }
    });
    
    // Camera shake and flash
    this.cameras.main.shake(500, 0.02);
    this.cameras.main.flash(300, 255, 0, 0, true);
  }
  
  _createExplosion(x, y, color = 0xff3366, particleCount = 8){
    // Create particle explosion effect
    for(let i = 0; i < particleCount; i++){
      const particle = this.add.rectangle(x, y, 4, 4, color);
      const angle = (Math.PI * 2 / particleCount) * i;
      const speed = 100 + Math.random() * 100;
      
      this.tweens.add({
        targets: particle,
        x: x + Math.cos(angle) * speed,
        y: y + Math.sin(angle) * speed,
        alpha: 0,
        scale: 0.1,
        duration: 400,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    }
    
    // Add a flash effect
    const flash = this.add.circle(x, y, 20, color, 0.6);
    this.tweens.add({
      targets: flash,
      scale: 2,
      alpha: 0,
      duration: 200,
      ease: 'Power2',
      onComplete: () => flash.destroy()
    });
  }
  _spawnObstacle(lane){
    const vanishY = HEIGHT * 0.15;
    const o = this.add.image(this._laneX(lane, 0), vanishY, 'obstacleTex');
    o.lane = lane;
    o.progress = 0;
    o.vy = ENEMY_SPEED_BASE * 0.7; // Slower than enemies
    o.baseSize = 60;
    o.w = o.baseSize; o.h = 16;
    o.setScale(0.1);
    o.trailPoints = []; // Initialize trail for obstacles too
    this.obstacles.push(o);
  }
  
  _spawnPowerUp(lane){
    const vanishY = HEIGHT * 0.15;
    const p = this.add.image(this._laneX(lane, 0), vanishY, 'powerUpTex');
    p.lane = lane;
    p.progress = 0;
    p.vy = ENEMY_SPEED_BASE * 1.2;
    p.baseSize = 20;
    p.setScale(0.1);
    this.powerUps.push(p);
  }
  
  _spawnDrifter(lane){
    const vanishY = HEIGHT * 0.15;
    const d = this.add.image(this._laneX(lane, 0), vanishY, 'drifterTex');
    d.lane = lane;
    d.targetLane = lane; // Will change
    d.progress = 0;
    d.vy = ENEMY_SPEED_BASE * 0.8;
    d.baseSize = 20;
    d.w = d.baseSize; d.h = d.baseSize;
    d.enemyType = 'drifterTex';
    d.isDrifter = true;
    d.driftTimer = 0;
    d.setScale(0.1);
    d.trailPoints = []; // Initialize trail points
    this.enemies.push(d); // Add to enemies array for collision
  }
  
  _pulseGrid(){
    // Set a pulse flag and timer with random direction
    this.pulseActive = true;
    this.pulseTimer = 150; // milliseconds
    this.pulsePhase = 0;
    // Random pulse type: 0 = forward, 1 = left, 2 = right
    this.pulseType = Math.floor(Math.random() * 3);
  }
  
  _drawPerspectiveGrid(){
    // Clear and redraw the entire grid
    if(!this.gridGraphics){
      this.gridGraphics = this.add.graphics();
      this.gridOffset = 0;
      this.vanishX = WIDTH / 2;
      this.vanishY = HEIGHT * 0.15;  // Move horizon much higher
    }
    
    // Safety check - recreate if destroyed
    if(!this.gridGraphics.scene) {
      this.gridGraphics = this.add.graphics();
    }
    
    // Safety check before clearing
    if(!this.gridGraphics || !this.gridGraphics.scene) {
      // Grid graphics lost, recreating...
      this.gridGraphics = this.add.graphics();
    }
    
    this.gridGraphics.clear();
    const numLines = 12;
    
    // Draw curved lane lines that match the exponential perspective
    for(let lane = 0; lane <= LANES; lane++){
      const bottomX = lane * LANE_W;
      this.gridGraphics.lineStyle(1, 0x00ff00, 0.2);
      
      // Draw lane as a series of connected segments following the curve
      let lastX = this.vanishX;
      let lastY = this.vanishY;
      
      for(let t = 0.1; t <= 1; t += 0.1){
        // Use same exponential curve as objects
        const y = this.vanishY + (HEIGHT - this.vanishY) * Math.pow(t, 2.5);
        // Interpolate X position along the curve
        const x = this.vanishX + (bottomX - this.vanishX) * t;
        
        this.gridGraphics.lineBetween(lastX, lastY, x, y);
        lastX = x;
        lastY = y;
      }
      // Final segment to bottom
      this.gridGraphics.lineBetween(lastX, lastY, bottomX, HEIGHT);
    }
    
    // Draw horizontal lines with exponential spacing (Beamrider style)
    for(let i = 0; i < numLines; i++){
      // Calculate position with perspective - exponential spacing
      const t = (i + this.gridOffset % 1) / numLines;
      const y = this.vanishY + (HEIGHT - this.vanishY) * Math.pow(t, 2.5); // Exponential curve for perspective
      
      if(y < this.vanishY || y > HEIGHT) continue;
      
      // Width increases as lines get closer
      const width = WIDTH * (0.1 + t * 1.5);
      const alpha = 0.3 - t * 0.2; // Fade in distance
      
      this.gridGraphics.lineStyle(2, 0x00ff00, alpha);
      this.gridGraphics.lineBetween(WIDTH/2 - width/2, y, WIDTH/2 + width/2, y);
    }
  }
  _fire(){ 
    // Can't shoot while moving or off-screen (but CAN shoot while jumping!)
    if(this.isMoving || this.playerLane < 0 || this.playerLane >= LANES) return;
    
    const now=this.time.now; 
    const cooldown = this.rapidFire ? FIRE_COOLDOWN/3 : FIRE_COOLDOWN;
    if(now-this.lastShotAt<cooldown) return; 
    this.lastShotAt=now; 
    // Shoot from current position (higher if jumping)
    const b=this.add.image(this.player.x, this.player.y-20, 'bulletTex'); 
    b.lane = this.playerLane;
    b.progress = 0.95; // Start near player
    b.vy=-BULLET_SPEED; b.w=6; b.h=12;
    
    // If jumping, give bullet an arc trajectory
    if(this.isJumping) {
      b.isArcShot = true;
      b.arcHeight = 0; // Height offset from base trajectory
      b.arcVelocity = -500; // Stronger initial upward velocity
      b.gravity = 600; // Slightly less gravity for longer arc
      b.startY = this.player.y; // Remember starting height
    } 
    if(this.rapidFire) {
      b.vy *= 1.5; // Faster bullets in rapid fire
      // Only play sound sometimes in rapid fire to avoid timing errors
      if(Math.random() < 0.3){
        try {
          // Use a consistent note in rapid fire instead of random
          const note = getGameNote(this.playerLane) + "6"; // Higher octave but same lane note
          const sound = gameSounds.laserSounds[gameSounds.currentLaserSound];
          if (sound.triggerAttackRelease) {
            sound.triggerAttackRelease(note, "32n", Tone.now() + 0.01);
          } else if (sound.triggerAttack) {
            // For PluckSynth which uses triggerAttack
            sound.triggerAttack(note, Tone.now() + 0.01);
          }
        } catch(e) {}
      }
    } else {
      try {
        const note = getGameNote(this.playerLane) + "5";
        const sound = gameSounds.laserSounds[gameSounds.currentLaserSound];
        
        // Different sounds need different trigger methods
        if (gameSounds.currentLaserSound === 2) {
          // Chord stab - play a mini chord
          const chordNotes = [note, getGameNote(this.playerLane + 2) + "5", getGameNote(this.playerLane + 4) + "5"];
          sound.triggerAttackRelease(chordNotes, "32n", Tone.now() + 0.01);
        } else if (gameSounds.currentLaserSound === 4) {
          // PluckSynth uses triggerAttack
          sound.triggerAttack(note, Tone.now() + 0.01);
        } else if (gameSounds.currentLaserSound === 5) {
          // Pew pew - play high note then quickly sweep down
          const highNote = getGameNote(this.playerLane) + "6";
          const lowNote = getGameNote(this.playerLane) + "3";
          sound.triggerAttackRelease(highNote, "16n", Tone.now());
          // Ramp the frequency down for pew pew effect
          sound.frequency.exponentialRampToValueAtTime(
            Tone.Frequency(lowNote).toFrequency(),
            Tone.now() + 0.15
          );
        } else {
          // Regular MonoSynth sounds
          sound.triggerAttackRelease(note, "32n", Tone.now() + 0.01);
        }
      } catch(e) {}
    }
    this.bullets.push(b); 
  }
  _aabb(a,b){ 
    return Math.abs(a.x-b.x) < (a.w+b.w)/2 && Math.abs(a.y-b.y) < (a.h+b.h)/2; 
  }

  update(_, dt){
    // Update starfield background
    this.updateStarfield(dt);
    
    // Update and draw trails
    this.updateTrails(dt);
    
    // Handle pulse effect - shift in different directions
    let pulseShift = 0;
    let pulseXShift = 0;
    if(this.pulseActive){
      this.pulseTimer -= dt;
      if(this.pulseTimer <= 0){
        this.pulseActive = false;
      } else {
        // Create a pulse curve
        const t = 1 - (this.pulseTimer / 150);
        const amount = Math.sin(t * Math.PI);
        
        if(this.pulseType === 0){
          // Forward pulse
          pulseShift = amount * 0.05;
        } else if(this.pulseType === 1){
          // Left pulse
          pulseXShift = -amount * 30; // pixels
        } else {
          // Right pulse
          pulseXShift = amount * 30;
        }
      }
    }
    
    // Animate the perspective grid tied to BPM
    if(!this.gridOffset) this.gridOffset = 0;
    // Get current BPM from Tone.Transport or use default
    const currentBPM = (typeof Tone !== 'undefined' && Tone.Transport) ? Tone.Transport.bpm.value : 132;
    // Scale grid speed to BPM - higher BPM = faster scrolling
    // Toggle grid with G key
    if(Phaser.Input.Keyboard.JustDown(this.keys.G)){
      this.gridVisible = !this.gridVisible;
      gridEnabled = this.gridVisible; // Save to persistent setting
      this.gridText.setText('GRID: ' + (this.gridVisible ? 'ON' : 'OFF') + ' [G]');
      if(!this.gridVisible && this.gridGraphics) {
        this.gridGraphics.clear();
      }
    }
    
    // Switch laser sounds with number keys
    if(Phaser.Input.Keyboard.JustDown(this.keys.ONE)) {
      gameSounds.currentLaserSound = 0;
      this.updateSoundDisplay();
    }
    if(Phaser.Input.Keyboard.JustDown(this.keys.TWO)) {
      gameSounds.currentLaserSound = 1;
      this.updateSoundDisplay();
    }
    if(Phaser.Input.Keyboard.JustDown(this.keys.THREE)) {
      gameSounds.currentLaserSound = 2;
      this.updateSoundDisplay();
    }
    if(Phaser.Input.Keyboard.JustDown(this.keys.FOUR)) {
      gameSounds.currentLaserSound = 3;
      this.updateSoundDisplay();
    }
    if(Phaser.Input.Keyboard.JustDown(this.keys.FIVE)) {
      gameSounds.currentLaserSound = 4;
      this.updateSoundDisplay();
    }
    if(Phaser.Input.Keyboard.JustDown(this.keys.SIX)) {
      gameSounds.currentLaserSound = 5;
      this.updateSoundDisplay();
    }
    
    // Add pulse shift to grid movement
    this.gridOffset += (dt / 1000) * (currentBPM / 60) + pulseShift * 2; // Lines per second based on BPM
    if(this.gridVisible) {
      this._drawPerspectiveGrid();
    }
    
    // Apply horizontal shift to grid
    if(this.gridGraphics && pulseXShift !== 0){
      this.gridGraphics.x = pulseXShift;
    } else if(this.gridGraphics){
      this.gridGraphics.x = 0;
    }
    
    // Movement with rubber band effect and smooth transitions
    if(Phaser.Input.Keyboard.JustDown(this.keys.LEFT)||Phaser.Input.Keyboard.JustDown(this.keys.A)){ 
      this.moveLeft();
    }
    if(Phaser.Input.Keyboard.JustDown(this.keys.RIGHT)||Phaser.Input.Keyboard.JustDown(this.keys.D)){ 
      this.moveRight();
    }
    
    // Rubber band effect - pull player back if off-screen too long
    if(this.playerLane < 0 || this.playerLane >= LANES){
      this.offScreenTimer -= dt;
      
      // Apply distortion effects when off-screen
      // Screen shake intensity based on how long off-screen
      const shakeIntensity = Math.max(0, 1 - (this.offScreenTimer / 800)) * 4;
      this.cameras.main.shake(100, shakeIntensity * 0.01);
      
      // Add chromatic aberration effect via camera tint
      if(this.playerLane < 0) {
        // Left side - cyan/red split
        this.cameras.main.setPostPipeline('ChromaticAberration');
      } else {
        // Right side - magenta/green split  
        this.cameras.main.setPostPipeline('ChromaticAberration');
      }
      
      // Visual warning - flash player when time is running out
      if(this.offScreenTimer < 300){
        this.player.setTint(0xff0000); // Red tint warning
        // Increase shake as timer runs out
        this.cameras.main.shake(100, 0.02);
      }
      // Pull back when timer expires
      if(this.offScreenTimer <= 0){
        // Store the off-screen position for animation
        const fromX = this.player.x;
        
        if(this.playerLane < 0){
          this.playerLane = 0;
        } else if(this.playerLane >= LANES){
          this.playerLane = LANES - 1;
        }
        
        const targetX = this._laneX(this.playerLane);
        
        // Rubber band snap animation - overshoot then settle
        this.tweens.add({
          targets: this.player,
          x: targetX,
          duration: 300,
          ease: 'Back.easeOut', // Elastic overshoot effect
          onStart: () => {
            // Stretch effect during snap
            this.player.setScale(1.5, 0.7); // Stretch horizontally, squash vertically
          },
          onComplete: () => {
            // Bounce settle animation
            this.tweens.add({
              targets: this.player,
              scaleX: 1,
              scaleY: 1,
              duration: 200,
              ease: 'Bounce.easeOut'
            });
          }
        });
        
        // Spin the player during snap-back
        this.tweens.add({
          targets: this.player,
          angle: 360,
          duration: 300,
          ease: 'Power2'
        });
        
        this.player.clearTint();
        this.player.setAlpha(1); // Restore full opacity
        // Rubber band snap sound
        try {
          gameSounds.move.triggerAttackRelease("C3", "16n");
        } catch(e) {}
      }
    } else {
      // Clear any warning tint and effects when back in bounds
      if(!this.rapidFire) this.player.clearTint();
      // Reset camera effects
      this.cameras.main.resetPostPipeline();
    }
    
    // Jump mechanic - UP or W key
    if(Phaser.Input.Keyboard.JustDown(this.keys.UP) || Phaser.Input.Keyboard.JustDown(this.keys.W)){
      this.jump();
    }
    
    // Firing - keyboard space or touch hold
    if(this.keys.SPACE.isDown || this.isTouchFiring) this._fire();

    // Update enemies with perspective
    const vanishY = HEIGHT * 0.15;
    for(let i=this.enemies.length-1; i>=0; i--){
      const e=this.enemies[i]; 
      
      // Move along perspective curve - add pulse shift
      e.progress += (e.vy * dt/1000) / (HEIGHT * 0.8) + pulseShift;
      
      // Handle drifting enemies
      if(e.isDrifter){
        e.driftTimer += dt;
        if(e.driftTimer > 1000){ // Change lane every second
          e.driftTimer = 0;
          e.targetLane = Phaser.Math.Between(0, LANES-1);
        }
        // Smoothly interpolate to target lane
        const laneDiff = e.targetLane - e.lane;
        if(Math.abs(laneDiff) > 0.1){
          e.lane += laneDiff * 0.05;
        }
      }
      
      // Calculate position on exponential curve (same as grid)
      const y = vanishY + (HEIGHT - vanishY) * Math.pow(e.progress, 2.5);
      e.y = y;
      
      // Update X position along perspective lane + pulse shift
      e.x = this._laneX(e.lane, e.progress) + pulseXShift;
      
      // Add position to trail history
      if(!e.trailPoints) e.trailPoints = [];
      e.trailPoints.push({x: e.x, y: e.y, alpha: 1.0});
      if(e.trailPoints.length > 8) e.trailPoints.shift(); // Keep trail short
      
      // Scale based on distance
      const scale = 0.1 + e.progress * 1.2; // Start tiny, grow to normal size
      e.setScale(scale);
      
      // Update collision box
      e.w = e.baseSize * scale;
      e.h = e.baseSize * scale;
      
      // Remove or check collision (can't hit while jumping or moving)
      if(e.progress > 1.1){ e.destroy(); this.enemies.splice(i,1); }
      else if(e.progress > 0.9 && !this.isJumping && !this.isMoving && this._aabb(e, this.player)){ 
        // Save highscore before restarting
        if(this.score > sessionHighScore) {
          sessionHighScore = this.score;
        }
        
        // Create dramatic explosion for enemy hit
        this._createDeathExplosion(this.player.x, this.player.y, e.x, e.y);
        
        try {
          // Player death sound - descending pitch
          const now = Tone.now();
          gameSounds.obstacleHit.triggerAttackRelease("G2", "16n", now);
          gameSounds.obstacleHit.triggerAttackRelease("D2", "16n", now + 0.05);
          gameSounds.obstacleHit.triggerAttackRelease("G1", "16n", now + 0.1);
          gameSounds.explosion.triggerAttackRelease("8n", now + 0.02);
        } catch(e) {}
        
        // Hide player and enemy immediately
        this.player.setVisible(false);
        e.destroy();
        
        // Delay restart to show animation
        this.time.delayedCall(800, () => {
          this.scene.restart();
        });
      }
    }
    
    // Update obstacles
    for(let i=this.obstacles.length-1; i>=0; i--){
      const o=this.obstacles[i];
      o.progress += (o.vy * dt/1000) / (HEIGHT * 0.8) + pulseShift;
      const y = vanishY + (HEIGHT - vanishY) * Math.pow(o.progress, 2.5);
      o.y = y;
      o.x = this._laneX(o.lane, o.progress) + pulseXShift;
      const scale = 0.1 + o.progress * 1.2;
      o.setScale(scale, scale * 0.3); // Flatten vertically
      o.w = o.baseSize * scale;
      o.h = 16 * scale; // Height for collision
      
      // Check collision with player (can jump over obstacles!)
      // Check when obstacle is near player Y position  
      if(Math.abs(o.y - this.player.y) < 40 && o.lane === this.playerLane && !this.isJumping && !this.isMoving) {
        // Save highscore before restarting
        if(this.score > sessionHighScore) {
          sessionHighScore = this.score;
        }
        
        // Create splat effect for hitting wall
        this._createSplatEffect(this.player.x, this.player.y);
        
        try {
          // Low impact thud with pitch bend down
          gameSounds.obstacleHit.triggerAttackRelease("C2", "8n");
          gameSounds.explosion.triggerAttackRelease("8n");
        } catch(e) {}
        
        // Delay restart to show animation
        this.time.delayedCall(500, () => {
          this.scene.restart();
        });
      }
      else if(o.progress > 1.1){ 
        o.destroy(); 
        this.obstacles.splice(i,1); 
      }
    }
    
    // Update power-ups
    for(let i=this.powerUps.length-1; i>=0; i--){
      const p=this.powerUps[i];
      p.progress += (p.vy * dt/1000) / (HEIGHT * 0.8) + pulseShift;
      const y = vanishY + (HEIGHT - vanishY) * Math.pow(p.progress, 2.5);
      p.y = y;
      p.x = this._laneX(p.lane, p.progress) + pulseXShift;
      const scale = 0.1 + p.progress * 1.2;
      p.setScale(scale);
      p.angle += dt * 0.2; // Rotate
      
      // Check collection
      if(p.progress > 0.9 && p.lane === this.playerLane){
        p.destroy();
        this.powerUps.splice(i,1);
        this.rapidFire = true;
        this.rapidFireTimer = 5000; // 5 seconds
        this.player.setTint(0x00ff00); // Green tint
        // Play quick arpeggio for power-up
        try {
          const now = Tone.now();
          gameSounds.powerUp.triggerAttackRelease("C5", "32n", now + 0.01);
          gameSounds.powerUp.triggerAttackRelease("E5", "32n", now + 0.05);
          gameSounds.powerUp.triggerAttackRelease("G5", "32n", now + 0.09);
        } catch(e) {}
      } else if(p.progress > 1.1){
        p.destroy();
        this.powerUps.splice(i,1);
      }
    }
    
    // Update rapid fire timer
    if(this.rapidFire){
      this.rapidFireTimer -= dt;
      if(this.rapidFireTimer <= 0){
        this.rapidFire = false;
        this.player.clearTint();
      }
    }

    // Update bullets with perspective
    for(let i=this.bullets.length-1; i>=0; i--){
      const b=this.bullets[i]; 
      
      // Move backward along perspective curve
      b.progress -= (Math.abs(b.vy) * dt/1000) / (HEIGHT * 0.8);
      
      // Calculate base position on exponential curve
      let y = vanishY + (HEIGHT - vanishY) * Math.pow(b.progress, 2.5);
      
      // Apply arc trajectory if this is a jump shot
      if(b.isArcShot) {
        // Update arc physics
        b.arcVelocity += b.gravity * (dt/1000);
        b.arcHeight += b.arcVelocity * (dt/1000);
        
        // Calculate arc offset - negative arcHeight means bullet is above base trajectory
        // The arc starts negative (going up) then becomes positive (falling down)
        y += b.arcHeight; // Add the arc offset to Y (negative = higher on screen)
        
        // Rotate bullet to show trajectory
        b.setRotation(Math.atan2(b.arcVelocity, -b.vy) * 0.5);
        
      }
      
      b.y = y;
      
      // Update X position along perspective lane
      b.x = this._laneX(b.lane, b.progress);
      
      // Add bullet trail
      if(!b.trailPoints) b.trailPoints = [];
      b.trailPoints.push({x: b.x, y: b.y, alpha: 1.0});
      if(b.trailPoints.length > 6) b.trailPoints.shift();
      
      // Scale based on distance
      const scale = 0.1 + b.progress * 1.2;
      b.setScale(scale);
      
      if(b.progress < 0){ b.destroy(); this.bullets.splice(i,1); continue; }
      
      // Check collision with obstacles first
      let hitObstacle = false;
      for(let j=this.obstacles.length-1; j>=0; j--){
        const o = this.obstacles[j];
        if(o.lane === b.lane && Math.abs(o.progress - b.progress) < 0.05){
          // Arc shots can go over obstacles if high enough
          // Obstacles are 8 pixels tall, so check if bullet is clearly above
          if(b.isArcShot && b.y < (o.y - o.h/2 - 10)) {
            continue; // Bullet is flying over the obstacle, don't collide
          }
          
          // Bullet hits obstacle - small spark effect
          this._createExplosion(b.x, b.y, 0xffff00, 4);
          b.destroy(); 
          this.bullets.splice(i,1);
          hitObstacle = true;
          
          // Obstacle block sound - metallic ping
          try {
            gameSounds.move.triggerAttackRelease("C7", "64n");
          } catch(e) {}
          break; // Obstacle blocks the shot
        }
      }
      
      // Check collision with enemies if not blocked
      if(!hitObstacle){
        for(let j=this.enemies.length-1; j>=0; j--){
          const e = this.enemies[j];
          // Check if in same lane and close in progress
          if(Math.abs(e.lane - b.lane) < 0.5 && Math.abs(e.progress - b.progress) < 0.05){
            // Create explosion at enemy position
            const explosionColor = e.isDrifter ? 0x9966ff : (e.enemyType === 'fastEnemyTex' ? 0xffff00 : 0xff3366);
            this._createExplosion(e.x, e.y, explosionColor, e.isDrifter ? 12 : 8);
            
            b.destroy(); this.bullets.splice(i,1);
            e.destroy(); this.enemies.splice(j,1);
            const points = e.isDrifter ? 30 : 10;
            this.score += points; 
            this.scoreText.setText('score '+this.score);
            // Update highscore if beaten
            if(this.score > sessionHighScore) {
              sessionHighScore = this.score;
              this.highScoreText.setText('high ' + sessionHighScore);
              this.highScoreText.setColor('#0ff'); // Cyan when beating high score
            }
            
            // Play destruction sound based on enemy type with pitch variation
            try {
              const now = Tone.now();
              if(e.isDrifter){
                // Drifter destruction - descending stab chord
                gameSounds.powerUp.triggerAttackRelease("G4", "32n", now);
                gameSounds.powerUp.triggerAttackRelease("D4", "32n", now + 0.02);
                gameSounds.powerUp.triggerAttackRelease("A3", "32n", now + 0.04);
              } else if(e.enemyType === 'fastEnemyTex'){
                // Fast enemy - high pitched noise burst
                gameSounds.explosion.triggerAttackRelease("32n", now);
                gameSounds.enemyDestroy.triggerAttackRelease("G5", "32n", now + 0.01);
              } else {
                // Regular enemy - distorted kick-like sound with random note from scale
                const noteIndex = Math.floor(Math.random() * 7);
                // Add tiny random offset to each sound to prevent exact timing conflicts
                const offset = Math.random() * 0.005;
                gameSounds.enemyDestroy.triggerAttackRelease(getGameNote(noteIndex) + "3", "16n", now + offset);
                gameSounds.explosion.triggerAttackRelease("32n", now + 0.015 + offset);
              }
            } catch(err) {
              // Timing conflict - sounds will be skipped this frame
            }
            break;
          }
        }
      }
    }

  }
  
  updateTrails(dt) {
    this.trailGraphics.clear();
    
    // Draw enemy trails
    for(let enemy of this.enemies) {
      if(enemy.trailPoints && enemy.trailPoints.length > 1) {
        for(let i = 0; i < enemy.trailPoints.length - 1; i++) {
          const point = enemy.trailPoints[i];
          const nextPoint = enemy.trailPoints[i + 1];
          
          // Fade trail based on position in array
          const alpha = (i / enemy.trailPoints.length) * 0.5;
          point.alpha = alpha;
          
          // Choose color based on enemy type
          let color = 0xff3366; // Default red
          if(enemy.enemyType === 'fastEnemyTex') color = 0xffff00;
          else if(enemy.isDrifter) color = 0xff00ff;
          
          this.trailGraphics.lineStyle(2, color, alpha);
          this.trailGraphics.lineBetween(point.x, point.y, nextPoint.x, nextPoint.y);
        }
      }
    }
    
    // Draw bullet trails
    for(let bullet of this.bullets) {
      if(bullet.trailPoints && bullet.trailPoints.length > 1) {
        for(let i = 0; i < bullet.trailPoints.length - 1; i++) {
          const point = bullet.trailPoints[i];
          const nextPoint = bullet.trailPoints[i + 1];
          
          const alpha = (i / bullet.trailPoints.length) * 0.7;
          
          // Cyan trails for bullets, yellow if arc shot
          const color = bullet.isArcShot ? 0xffff00 : 0x00ffff;
          
          this.trailGraphics.lineStyle(1, color, alpha);
          this.trailGraphics.lineBetween(point.x, point.y, nextPoint.x, nextPoint.y);
        }
      }
    }
  }
}

// Initialize Phaser game
const game = new Phaser.Game({
  type: Phaser.AUTO,
  width: WIDTH,
  height: HEIGHT,
  parent: 'gameContainer',
  scene: [StartupScene, Main]
});
</script>
</body>
</html>