<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Beatrider</title>
  
  <!-- PWA Meta Tags -->
  <meta name="theme-color" content="#000000">
  <meta name="description" content="A retro lane-based rhythm shooter game">
  <link rel="manifest" href="manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Beatrider">
  <link rel="apple-touch-icon" href="icon-192.png">
  
  <script src="https://cdn.jsdelivr.net/npm/tone@latest/build/Tone.min.js"></script>
  <script src="https://unpkg.com/@tonejs/unmute@latest/build/unmute.min.js" data-add-button="true"></script>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-6SQJ9NR8SD"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-6SQJ9NR8SD', {
      send_page_view: true
    });
    
    // Track control type (will be updated when controls are used)
    window.controlType = 'unknown';
    
    // Helper function for safe GA event tracking
    window.trackEvent = function(eventName, parameters) {
      if (typeof gtag !== 'undefined') {
        gtag('event', eventName, parameters);
      }
    };
    
    // Track session start
    window.addEventListener('load', () => {
      trackEvent('session_start', {
        platform: /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ? 'mobile' : 'desktop',
        screen_size: `${window.innerWidth}x${window.innerHeight}`,
        orientation: window.innerWidth > window.innerHeight ? 'landscape' : 'portrait'
      });
    });
    
    // Track time engagement automatically (GA4 does this but we can enhance it)
    let engagementTime = 0;
    let lastActiveTime = Date.now();
    setInterval(() => {
      if (document.hasFocus()) {
        engagementTime += 10;
        // Track milestone engagement times
        if (engagementTime === 60) {
          trackEvent('engagement_1min', {});
        } else if (engagementTime === 300) {
          trackEvent('engagement_5min', {});
        } else if (engagementTime === 600) {
          trackEvent('engagement_10min', {});
        }
      }
    }, 10000); // Check every 10 seconds
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body { 
      background: #000; 
      color: #0f0; 
      font: 14px monospace; 
      text-shadow: 0 0 10px #0f0;
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }
    .container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    .left-panel {
      position: absolute;
      top: 70px;
      left: 10px;
      width: 380px;
      max-height: 0;
      overflow: hidden;
      background: rgba(0, 0, 0, 0.95);
      border: 0px solid #0f0;
      border-radius: 0 0 8px 8px;
      border-top: none;
      z-index: 9;
      backdrop-filter: blur(5px);
      transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), padding 0.4s, opacity 0.3s ease, border-width 0.4s;
      padding: 0 10px;
      opacity: 0.15; /* Very transparent by default */
    }
    
    .left-panel:hover,
    .left-panel.touched {
      opacity: 1; /* Fully opaque when interacted with */
    }
    
    .left-panel.expanded {
      max-height: calc(100vh - 140px); /* Leave room for score at bottom */
      padding: 10px;
      border-width: 1px;
      overflow-y: auto;
      opacity: 1 !important; /* Always fully visible when expanded */
    }
    
    /* Custom scrollbar styling for expanded panel */
    .left-panel.expanded::-webkit-scrollbar {
      width: 6px;
    }
    
    .left-panel.expanded::-webkit-scrollbar-track {
      background: rgba(0, 255, 0, 0.1);
      border-radius: 3px;
    }
    
    .left-panel.expanded::-webkit-scrollbar-thumb {
      background: rgba(0, 255, 0, 0.5);
      border-radius: 3px;
      border: 1px solid rgba(0, 255, 0, 0.3);
    }
    
    .left-panel.expanded::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 255, 0, 0.8);
      box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
    }
    #gameContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    button { 
      background: #111; 
      color: #0f0; 
      border: 1px solid #0f0; 
      padding: 10px 20px; 
      margin: 5px;
      cursor: pointer;
      text-shadow: 0 0 5px #0f0;
    }
    button:hover { 
      background: #222; 
      box-shadow: 0 0 10px #0f0;
    }
    .controls { 
      margin: 20px 0; 
    }
    .slider-row {
      display: flex;
      align-items: center;
      margin: 10px 0;
      gap: 10px;
    }
    .slider-label {
      min-width: 80px;
      text-align: right;
      color: #0f0;
    }
    .slider {
      flex: 1;
      max-width: 200px;
    }
    
    /* Special styling for sensitivity slider - no fill gradient */
    .sensitivity-slider {
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      outline: none;
      flex: 1;
      max-width: 200px;
    }
    
    .sensitivity-slider::-webkit-slider-track {
      background: #333;
      height: 4px;
      border-radius: 2px;
    }
    
    .sensitivity-slider::-moz-range-track {
      background: #333;
      height: 4px;
      border-radius: 2px;
    }
    
    .sensitivity-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #0f0;
      border-radius: 50%;
      cursor: pointer;
      margin-top: -6px;
    }
    
    .sensitivity-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #0f0;
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }
    
    /* Show tick marks */
    .sensitivity-slider::-webkit-slider-runnable-track {
      background: #333;
    }
    .slider-value {
      min-width: 40px;
      color: #ff0;
      font-weight: bold;
    }
    .sound-select {
      flex: 1;
      max-width: 200px;
      background: #111;
      color: #0f0;
      border: 1px solid #0f0;
      padding: 4px;
      font-family: monospace;
    }
    h1 { 
      color: #ff0; 
      text-shadow: 0 0 20px #ff0;
      font-size: 18px;
      margin: 10px 0;
    }
    .track-row {
      margin: 5px 0;
      display: flex;
      align-items: center;
    }
    .track-name {
      width: 80px;
      text-align: right;
      margin-right: 10px;
    }
    .beat-indicator {
      display: inline-block;
      width: 20px;
      height: 20px;
      background: #030;
      border: 1px solid #0f0;
      margin-right: 5px;
    }
    .pattern-display {
      display: inline-block;
      margin-left: 10px;
      font-size: 10px;
      color: #0a0;
    }
    .mute-btn {
      width: 40px;
      height: 20px;
      padding: 2px;
      margin: 0 5px;
      font-size: 10px;
      background: #030;
      color: #0f0;
      border: 1px solid #0f0;
      cursor: pointer;
    }
    .mute-btn.muted {
      background: #300;
      color: #f00;
      border-color: #f00;
    }
    #progression {
      margin: 20px 0;
      padding: 10px;
      border: 1px solid #0f0;
      background: #010;
    }
    
    /* Minimized music controls */
    .music-controls {
      position: fixed;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid #0f0;
      border-radius: 8px;
      padding: 10px;
      z-index: 10;
      backdrop-filter: blur(5px);
      opacity: 0.15; /* Very transparent by default */
      transition: opacity 0.3s ease;
      max-width: calc(100vw - 20px);
      overflow: hidden; /* Prevent any scrolling */
      flex-wrap: wrap;
      touch-action: none; /* Disable touch scrolling */
    }
    
    .music-controls:hover,
    .music-controls.touched,
    .music-controls.settings-open {
      opacity: 1; /* Fully opaque when interacted with or settings open */
    }
    
    .control-btn {
      width: 40px;
      height: 40px;
      background: #111;
      color: #0f0;
      border: 1px solid #0f0;
      border-radius: 4px;
      cursor: pointer;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      position: relative;
    }
    
    
    .control-btn:hover {
      background: #222;
      box-shadow: 0 0 10px #0f0;
    }
    
    .control-btn.inactive svg {
      stroke: #666 !important;
    }
    
    .control-btn.active svg {
      stroke: #0f0 !important;
    }
    
    .track-squares {
      display: flex;
      gap: 8px;
      padding: 0 10px;
      border-left: 1px solid #0f0;
      border-right: 1px solid #0f0;
      flex-wrap: nowrap;
    }
    
    .track-square {
      width: 30px;
      height: 30px;
      background: #030;
      border: 2px solid #0f0;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .track-square.active {
      background: #0f0;
      box-shadow: 0 0 15px #0f0;
    }
    
    .track-square.muted {
      background: #300;
      border-color: #f00;
      opacity: 0.5;
    }
    
    .track-square.flash {
      animation: flash 0.1s;
    }
    
    @keyframes flash {
      0% { background: #0f0; box-shadow: 0 0 20px #0f0; }
      100% { background: #030; box-shadow: none; }
    }
    
    /* Mobile-specific styles - applied via JavaScript */
    body.mobile {
      font-size: 18px;
    }
    
    body.mobile .music-controls {
      padding: 8px;
      gap: 8px;
      max-width: calc(100vw - 16px);
    }
    
    body.mobile .control-btn {
      width: 45px;
      height: 45px;
      font-size: 24px;
      border-width: 2px;
    }
    
    /* Small screen adjustments */
    @media (max-width: 480px) and (orientation: portrait) {
      .music-controls {
        padding: 2px;
        gap: 2px;
        flex-wrap: nowrap;
        max-height: 40px;
      }
      
      .control-btn {
        width: 26px;
        height: 26px;
        font-size: 14px;
      }
      
      .track-squares {
        flex-wrap: nowrap;
        gap: 1px;
        padding: 0 3px;
      }
      
      .track-square {
        width: 18px;
        height: 18px;
      }
      
      body.mobile .control-btn {
        width: 28px;
        height: 28px;
        font-size: 16px;
      }
      
      body.mobile .track-squares {
        gap: 1px;
        padding: 0 3px;
      }
    }
    
    @media (max-width: 480px) and (orientation: landscape) {
      .music-controls {
        padding: 5px;
        gap: 5px;
      }
      
      .control-btn {
        width: 35px;
        height: 35px;
        font-size: 18px;
      }
      
      .track-square {
        width: 25px;
        height: 25px;
      }
    }
    
    body.mobile .track-square {
      width: 45px;
      height: 45px;
      border-width: 3px;
    }
    
    body.mobile .track-squares {
      gap: 12px;
      padding: 0 15px;
    }
    
    body.mobile .left-panel {
      width: 90%;
      max-width: 500px;
      font-size: 18px;
    }
    
    body.mobile .left-panel.expanded {
      max-height: calc(100vh - 120px); /* Leave room for score on mobile */
      padding: 20px;
    }
    
    body.mobile button {
      padding: 15px 30px;
      font-size: 18px;
      border-width: 2px;
    }
    
    body.mobile .slider-label {
      min-width: 120px;
      font-size: 18px;
    }
    
    body.mobile .sound-select {
      padding: 8px;
      font-size: 18px;
      border-width: 2px;
    }
    
    body.mobile h1 {
      font-size: 24px;
    }
    
    body.mobile .slider-row {
      margin: 15px 0;
      gap: 15px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="gameContainer"></div>
    
    <!-- Minimized music controls -->
    <div id="musicControls" class="music-controls">
      <button id="playPauseBtn" class="control-btn" title="Play/Pause">▶</button>
      <button id="expandBtn" class="control-btn" title="Settings">☰</button>
      <button id="gridToggleBtn" class="control-btn" title="Toggle Grid">⊞</button>
    </div>
    
    <!-- Expanded panel (hidden by default) -->
    <div class="left-panel" id="expandedPanel">
      <h1>MELODIC TECHNO ENGINE</h1>
      
      <!-- Track indicators -->
      <div class="track-squares" style="margin: 10px 0; display: flex; gap: 5px; justify-content: center;">
        <div class="track-square" id="kickSquare" data-track="kick" title="Kick"></div>
        <div class="track-square" id="snareSquare" data-track="snare" title="Snare"></div>
        <div class="track-square" id="hatSquare" data-track="hat" title="Hi-hat"></div>
        <div class="track-square" id="acidSquare" data-track="acid" title="Acid"></div>
        <div class="track-square" id="stabSquare" data-track="stab" title="Stab"></div>
        <div class="track-square" id="subSquare" data-track="sub" title="Sub"></div>
      </div>
      
      <div class="controls">
        <div class="slider-row">
          <label class="slider-label">MOOD:</label>
          <select id="musicPresetSelector" class="sound-select">
            <option value="">Custom</option>
            <option value="chill">Chill</option>
            <option value="driving" selected>Driving</option>
            <option value="peak">Peak Time</option>
            <option value="acid">Acid Storm</option>
            <option value="dark">Dark</option>
            <option value="hypnotic">Hypnotic</option>
            <option value="anthem">Anthem</option>
          </select>
          <span id="musicPresetDisplay" class="slider-value" style="font-size: 10px; width: 100px;">Classic techno</span>
        </div>
        <div class="slider-row">
          <label class="slider-label">DIFFICULTY:</label>
          <select id="difficultySelector" class="sound-select">
            <option value="zen">Zen Mode</option>
            <option value="normal" selected>Normal</option>
            <option value="intense">Intense</option>
            <option value="chaos">Chaos</option>
          </select>
          <span id="difficultyDisplay" class="slider-value" style="font-size: 10px; width: 100px;">Standard</span>
        </div>
        <hr style="border-color: #0f0; margin: 15px 0; opacity: 0.3;">
        <div style="margin-bottom: 15px;">
          <label class="slider-label">Genre:</label>
          <div style="display: flex; gap: 3px; margin-top: 5px; flex-wrap: wrap;">
            <button id="genreTechno" class="preset-btn" style="flex: 1; min-width: 45px; padding: 4px 2px; font-size: 16px;">Techno</button>
            <button id="genreDnb" class="preset-btn" style="flex: 1; min-width: 45px; padding: 4px 2px; font-size: 16px;">D&B</button>
            <button id="genreTropical" class="preset-btn" style="flex: 1; min-width: 45px; padding: 4px 2px; font-size: 16px;">Tropical</button>
            <button id="genreDubstep" class="preset-btn" style="flex: 1; min-width: 45px; padding: 4px 2px; font-size: 16px;">Dubstep</button>
            <button id="genreTrance" class="preset-btn" style="flex: 1; min-width: 45px; padding: 4px 2px; font-size: 16px;">Trance</button>
          </div>
        </div>
        <div class="slider-row">
          <label class="slider-label">BPM:</label>
          <input type="range" id="bpmSlider" min="120" max="150" value="132" class="slider">
          <span id="bpmDisplay" class="slider-value">132</span>
        </div>
        <div class="slider-row">
          <label class="slider-label">ENERGY:</label>
          <input type="range" id="energySlider" min="0" max="100" value="50" class="slider">
          <span id="energyDisplay" class="slider-value">50</span>
        </div>
        <div class="slider-row">
          <label class="slider-label">TENSION:</label>
          <input type="range" id="tensionSlider" min="0" max="100" value="30" class="slider">
          <span id="tensionDisplay" class="slider-value">30</span>
        </div>
        <div class="slider-row">
          <label class="slider-label">SHOT:</label>
          <select id="soundSelector" class="sound-select">
            <option value="0">Triangle</option>
            <option value="1">Acid</option>
            <option value="2">Chord</option>
            <option value="3">Echo</option>
            <option value="4">Pluck</option>
            <option value="5">Pew Pew</option>
          </select>
          <span id="soundDisplay" class="slider-value">Triangle</span>
        </div>
        <div class="slider-row" id="touchSensitivityRow" style="display: none;">
          <label class="slider-label" title="Size of center deadzone - smaller = more responsive">DEADZONE:</label>
          <input type="range" id="touchSensitivitySlider" min="0" max="5" value="2" step="1" class="slider sensitivity-slider" list="touchSensitivitySteps" title="Adjust the size of the center deadzone">
          <datalist id="touchSensitivitySteps">
            <option value="0"></option>
            <option value="1"></option>
            <option value="2"></option>
            <option value="3"></option>
            <option value="4"></option>
            <option value="5"></option>
          </datalist>
          <span id="touchSensitivityDisplay" class="slider-value">Normal</span>
        </div>
      </div>
  
  <div id="progression">
    <div>SECTION: <span id="section">INTRO</span></div>
    <div>BAR: <span id="bar">0</span> / 64</div>
    <div>CHORD: <span id="chord">Cm</span></div>
    <div>NEXT: <span id="nextSection">BUILD in 8 bars</span></div>
  </div>
  
      <div id="status">READY</div>
    </div>
  </div>

<script>
// ============================================
// STORAGE SYSTEM - MUST BE FIRST
// ============================================
const STORAGE_KEY = 'beatrider_data';
const STORAGE_VERSION = 2; // Version number for migrations

// Default settings structure
const DEFAULT_SETTINGS = {
  version: STORAGE_VERSION,
  highScore: 0,
  settings: {
    gridEnabled: true,
    difficulty: 'normal',
    touchSensitivity: 30,
    laserSound: 0,
    musicPreset: 'driving',
    customMusic: {
      bpm: 128,
      energy: 60,
      tension: 40
    },
    trackMutes: {
      kick: false,
      snare: false,
      hat: false,
      acid: false,
      stab: false,
      sub: false
    }
  }
};

// Deep merge helper for nested settings
function deepMerge(target, source) {
  const output = { ...target };
  if (isObject(target) && isObject(source)) {
    Object.keys(source).forEach(key => {
      if (isObject(source[key])) {
        if (!(key in target))
          output[key] = source[key];
        else
          output[key] = deepMerge(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}

function isObject(item) {
  return item && typeof item === 'object' && !Array.isArray(item);
}

// Migrate data from older versions
function migrateData(data) {
  // No version or version 1: flat structure to nested
  if (!data.version || data.version < 2) {
    const migrated = {
      version: STORAGE_VERSION,
      highScore: data.highScore || 0,
      settings: {
        gridEnabled: data.gridEnabled !== undefined ? data.gridEnabled : true,
        difficulty: 'normal',
        touchSensitivity: 30,
        laserSound: 0,
        musicPreset: 'driving',
        customMusic: {
          bpm: 128,
          energy: 60,
          tension: 40
        },
        trackMutes: {
          kick: false,
          snare: false,
          hat: false,
          acid: false,
          stab: false,
          sub: false
        }
      }
    };
    
    // Check for legacy touchSensitivity key
    const legacySensitivity = localStorage.getItem('touchSensitivity');
    if (legacySensitivity) {
      migrated.settings.touchSensitivity = parseInt(legacySensitivity) || 30;
      localStorage.removeItem('touchSensitivity');
    }
    
    return migrated;
  }
  
  return data;
}

function loadGameData() {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    if (data) {
      const parsed = JSON.parse(data);
      const migrated = migrateData(parsed);
      
      // Save migrated data if it changed
      if (migrated.version !== parsed.version) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(migrated));
      }
      
      // Merge with defaults to ensure all fields exist
      return deepMerge(DEFAULT_SETTINGS, migrated);
    }
  } catch (e) {
    console.warn('Failed to load game data, using defaults:', e);
  }
  return { ...DEFAULT_SETTINGS }; // Return a copy of defaults
}

function saveGameData(data) {
  try {
    const current = loadGameData();
    const updated = deepMerge(current, data);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
  } catch (e) {
    console.warn('Failed to save game data:', e);
    // Continue with session-only settings
  }
}

// Debounced save to prevent excessive writes
let saveTimer = null;
let pendingData = {};

function saveGameDataDebounced(data) {
  // Accumulate changes
  pendingData = deepMerge(pendingData, data);
  
  // Clear existing timer
  clearTimeout(saveTimer);
  
  // Set new timer (100ms delay)
  saveTimer = setTimeout(() => {
    saveGameData(pendingData);
    pendingData = {};
  }, 100);
}

// Load saved data IMMEDIATELY after defining storage functions
const savedData = loadGameData();
let sessionHighScore = savedData.highScore;

// ============================================
// AUDIO SETUP
// ============================================
// Master chain with sidechain compression
const masterLimiter = new Tone.Limiter(-3).toDestination();

// High-pass filter for tension building (cuts bass)
const masterHighpass = new Tone.Filter({
  frequency: 20,
  type: "highpass",
  rolloff: -24
}).connect(masterLimiter);

const sidechain = new Tone.Compressor({
  threshold: -20,
  ratio: 8,
  attack: 0.003,
  release: 0.1
}).connect(masterHighpass);

// Instruments
const kick = new Tone.MembraneSynth({
  pitchDecay: 0.05,
  octaves: 10,
  oscillator: { type: "sine" },
  envelope: {
    attack: 0.001,
    decay: 0.4,
    sustain: 0.01,
    release: 1.4
  }
}).connect(masterHighpass); // Kick bypasses sidechain to keep punch

const snare = new Tone.NoiseSynth({
  noise: { type: "white" },
  envelope: {
    attack: 0.001,
    decay: 0.15,
    sustain: 0
  }
}).connect(sidechain);

// Hi-hat using filtered noise for more realistic sound
const hihatFilter = new Tone.Filter({
  frequency: 10000,
  type: "highpass"
}).connect(sidechain);

const hihat = new Tone.NoiseSynth({
  noise: {
    type: "white"
  },
  envelope: {
    attack: 0.001,
    decay: 0.02,
    sustain: 0,
    release: 0.03
  },
  volume: -10
}).connect(hihatFilter);

// Acid with automated filter - trying to approximate 18dB slope with cascaded filters
const acidFilter1 = new Tone.Filter({
  frequency: 800,
  type: "lowpass",
  rolloff: -12,
  Q: 4
}).connect(sidechain);

const acidFilter2 = new Tone.Filter({
  frequency: 800,
  type: "lowpass", 
  rolloff: -12,  // Can't do -6, using -12 instead
  Q: 2
}).connect(acidFilter1);

// Add distortion for that overdriven 303 sound
const acidDistortion = new Tone.Distortion(0.3).connect(acidFilter2);

const acid = new Tone.MonoSynth({
  oscillator: { type: "sawtooth" },
  envelope: {
    attack: 0.003,  // Faster attack
    decay: 0.2,     // Shorter decay
    sustain: 0.1,   // Lower sustain for more plucky sound
    release: 0.1
  },
  filterEnvelope: {
    attack: 0.003,
    decay: 0.4,     // Longer filter decay for that sweep
    sustain: 0.2,
    release: 0.2,
    baseFrequency: 100,  // Start lower
    octaves: 4      // More dramatic sweep
  },
  portamento: 0.05  // Add glide between notes!
}).connect(acidDistortion);

// Rave stabs with filter and reverb for space
const stabReverb = new Tone.Reverb({
  decay: 2,
  wet: 0.3
}).connect(sidechain);

const stabFilter = new Tone.Filter({
  frequency: 3000,  // Open up the filter more
  type: "lowpass",
  rolloff: -12,
  Q: 2
}).connect(stabReverb);

// Genre-specific stab synths
const technoStab = new Tone.PolySynth(Tone.Synth, {
  oscillator: { 
    type: "sawtooth",
    partialCount: 3  // Fewer harmonics = softer sound
  },
  envelope: {
    attack: 0.01,    // Quick attack
    decay: 0.15,     // Slightly longer decay
    sustain: 0,      // No sustain - just decay/release
    release: 0.2     // Moderate release - musical but won't overlap too much
  },
  volume: -2       // Boost volume back up
}).connect(stabFilter);

// D&B Reese bass-style synth (detuned saws)
const dnbReese = new Tone.PolySynth(Tone.Synth, {
  oscillator: {
    type: "sawtooth",
    detune: 7  // Slight detune for movement
  },
  envelope: {
    attack: 0.05,
    decay: 0.3,
    sustain: 0.7,
    release: 0.5
  },
  volume: -4
}).connect(stabFilter);

// Tropical steel drum-style synth (metallic, bright attack)
const tropicalPluck = new Tone.PolySynth(Tone.Synth, {
  oscillator: {
    type: "sine",  // Pure tone like steel drum
    modulationType: "triangle",  // Add some metallic harmonics
    modulationIndex: 2
  },
  envelope: {
    attack: 0.001,   // Very quick attack for that steel drum "ping"
    decay: 0.4,      // Let it ring a bit
    sustain: 0.1,    // Small sustain
    release: 0.3     // Natural ring-out
  },
  volume: 2  // Boost for presence
}).connect(stabFilter);

// Current active stab synth (will switch based on genre)
let raveSynth = technoStab;  // Default to techno

// Sub bass with EQ to prevent mud
const subEQ = new Tone.EQ3({
  low: 3,        // Boost the deep sub frequencies
  mid: -6,       // Cut the muddy mids (100-200Hz)
  high: -12,     // Remove any high frequency content
  lowFrequency: 60,
  highFrequency: 200
}).connect(sidechain);  // Now goes through sidechain for ducking!

// Sub bass - controlled power
const subBass = new Tone.MonoSynth({
  oscillator: { type: "sine" },
  envelope: {
    attack: 0.01,   // Faster attack for more punch
    decay: 0.3,     // Longer decay
    sustain: 0.6,   // Bit less sustain
    release: 0.5
  },
  volume: -6      // Compromise between -12 and 0
}).connect(subEQ);

// Noise riser for tension
const noiseRiser = new Tone.Noise("white").connect(
  new Tone.Filter({
    frequency: 200,
    type: "highpass",
    rolloff: -24
  }).connect(
    new Tone.Volume(-20).connect(sidechain)
  )
);
const riserEnvelope = new Tone.Envelope({
  attack: 8,
  decay: 0,
  sustain: 1,
  release: 0.5
});

// Musical structures
const scale = {
  C: ["C", "D", "Eb", "F", "G", "Ab", "Bb"],
  indices: { C: 0, D: 1, Eb: 2, F: 3, G: 4, Ab: 5, Bb: 6 }
};

// Extended chord progression with variations
const chordProgressions = {
  main: [
    { root: "C", chord: ["C4", "Eb4", "G4"], bass: "C1", melodicFocus: ["C", "Eb", "G"] },
    { root: "C", chord: ["C4", "Eb4", "G4"], bass: "C1", melodicFocus: ["G", "Eb", "C"] },
    { root: "Bb", chord: ["Bb3", "D4", "F4"], bass: "Bb0", melodicFocus: ["Bb", "F", "D"] },
    { root: "Ab", chord: ["Ab3", "C4", "Eb4"], bass: "Ab0", melodicFocus: ["Ab", "Eb", "C"] }
  ],
  variation1: [
    { root: "C", chord: ["C4", "Eb4", "G4"], bass: "C1", melodicFocus: ["C", "G", "Eb"] },
    { root: "F", chord: ["F3", "Ab3", "C4"], bass: "F0", melodicFocus: ["F", "Ab", "C"] },
    { root: "G", chord: ["G3", "Bb3", "D4"], bass: "G0", melodicFocus: ["G", "D", "Bb"] },
    { root: "C", chord: ["C4", "Eb4", "G4"], bass: "C1", melodicFocus: ["C", "Eb", "G"] }
  ],
  variation2: [
    { root: "C", chord: ["C4", "Eb4", "G4", "Bb4"], bass: "C1", melodicFocus: ["C", "Bb", "G"] }, // Cm7
    { root: "Ab", chord: ["Ab3", "C4", "Eb4", "G4"], bass: "Ab0", melodicFocus: ["Ab", "Eb", "G"] }, // Abmaj7
    { root: "F", chord: ["F3", "Ab3", "C4", "Eb4"], bass: "F0", melodicFocus: ["F", "C", "Ab"] }, // Fm7
    { root: "G", chord: ["G3", "B3", "D4", "F4"], bass: "G0", melodicFocus: ["G", "B", "F"] } // G7
  ],
  breakdown: [
    { root: "C", chord: ["C3"], bass: "C1", melodicFocus: ["C"] }, // Just root
    { root: "C", chord: ["C3", "G3"], bass: "C1", melodicFocus: ["C", "G"] }, // Power chord
    { root: "Ab", chord: ["Ab2"], bass: "Ab0", melodicFocus: ["Ab"] }, // Just root
    { root: "G", chord: ["G2", "D3"], bass: "G0", melodicFocus: ["G", "D"] } // Power chord
  ]
};

// Select progression based on section
function getChordProgression(section) {
  if (section === 'BREAK') return chordProgressions.breakdown;
  if (section === 'DROP') return chordProgressions.variation2;
  if (currentBar % 16 < 8) return chordProgressions.main;
  return Math.random() > 0.5 ? chordProgressions.variation1 : chordProgressions.variation2;
}

// Genre configurations with appropriate BPM ranges and pattern sets
const GENRE_CONFIGS = {
  techno: {
    name: 'Techno/Acid',
    bpmMin: 120,
    bpmMax: 150,
    bpmDefault: 132,
    patterns: ['detroit', 'berlin', 'chicago', 'fourOnFloor', 'syncopated']
  },
  dnb: {
    name: 'Drum & Bass',
    bpmMin: 160,
    bpmMax: 180,
    bpmDefault: 174,
    patterns: ['dnb_basic', 'dnb_amen', 'dnb_jump', 'dnb_roll']
  },
  tropical: {
    name: 'Tropical/Kygo',
    bpmMin: 100,
    bpmMax: 115,
    bpmDefault: 110,
    patterns: ['kygo_basic', 'kygo_bounce', 'kygo_minimal', 'kygo_clap']
  },
  dubstep: {
    name: 'Dubstep',
    bpmMin: 138,
    bpmMax: 145,
    bpmDefault: 140,
    patterns: ['dubstep_basic', 'dubstep_half', 'dubstep_roll']
  },
  trance: {
    name: 'Trance',
    bpmMin: 135,
    bpmMax: 145,
    bpmDefault: 138,
    patterns: ['trance_kick', 'trance_build', 'trance_uplifting']
  }
};

// Current genre (can be changed via UI)
let currentGenre = 'techno';

// Pattern bank with classic techno/acid patterns
const patternBank = {
  kick: {
    fourOnFloor: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],
    halfTime: [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
    syncopated: [1,0,0,0, 1,0,0,1, 0,0,1,0, 1,0,0,0],
    minimal: [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
    // Classic 909 kick patterns
    detroit: [1,0,0,1, 1,0,0,0, 1,0,1,0, 1,0,0,0],  // Detroit techno style
    berlin: [1,0,0,0, 1,0,1,0, 1,0,0,0, 1,0,0,0],   // Berlin minimal
    chicago: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,1,0],  // Chicago acid house
    fill: [1,0,1,0, 1,0,1,1, 1,1,1,0, 1,1,1,1],
    // Drum & Bass patterns (breakbeat style)
    dnb_basic: [1,0,0,0, 0,0,1,0, 0,0,1,0, 0,0,0,0],  // Basic D&B kick
    dnb_amen: [1,0,0,1, 0,0,1,0, 0,1,0,0, 1,0,0,0],   // Amen-inspired
    dnb_jump: [1,0,0,0, 0,0,0,1, 0,0,1,0, 0,0,0,1],    // Jump-up style
    // Tropical/Kygo patterns (dembow/reggaeton influenced)
    kygo_basic: [1,0,0,1, 0,0,1,0, 1,0,0,1, 0,0,1,0],  // Basic tropical house
    kygo_bounce: [1,0,0,0, 0,1,0,0, 1,0,0,0, 0,1,0,0], // Bouncy Kygo style
    kygo_minimal: [1,0,0,0, 0,0,0,0, 0,0,1,0, 0,0,0,0], // Sparse tropical
    // Dubstep patterns (half-time feel at 140 BPM)
    dubstep_basic: [1,0,0,0, 0,0,0,0, 0,0,1,0, 0,0,0,0], // Classic dubstep
    dubstep_half: [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],  // Ultra minimal
    dubstep_roll: [1,0,0,0, 0,0,1,0, 0,0,1,0, 0,0,1,0],  // Rolling subs
    // Trance patterns (driving four-on-floor)
    trance_kick: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],   // Classic trance
    trance_build: [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0],  // Build-up pattern
    trance_uplifting: [1,0,0,1, 1,0,0,1, 1,0,0,1, 1,0,0,1] // Uplifting variation
  },
  snare: {
    backbeat: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
    ghost: [0,0,0,0, 1,0,0,1, 0,0,0,0, 1,0,0,0],
    detroit: [0,0,0,0, 1,0,0,0, 0,0,1,0, 1,0,0,0],  // Off-beat snare
    fill: [0,0,0,0, 1,0,1,0, 1,0,1,1, 1,1,1,1],
    minimal: [0,0,0,0, 0,0,0,0, 0,0,0,0, 1,0,0,0],
    // Drum & Bass snare patterns (heavy on 2 and 4)
    dnb_basic: [0,0,1,0, 1,0,0,0, 0,1,0,0, 1,0,0,0],   // Classic D&B snare
    dnb_amen: [0,0,1,0, 1,0,0,1, 0,0,1,0, 1,0,1,0],    // Amen break style
    dnb_roll: [0,0,1,0, 1,0,1,1, 0,0,1,0, 1,1,1,1],    // Rolling snares
    // Tropical/Kygo snare patterns (lighter, more sparse)
    kygo_clap: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],   // Simple clap on 2&4
    kygo_snap: [0,0,0,0, 0,0,1,0, 0,0,0,0, 0,0,1,0],   // Finger snaps
    kygo_rim: [0,0,0,0, 1,0,0,0, 0,0,0,0, 0,0,1,0],    // Rimshot pattern
    // Dubstep snare patterns (heavy on the 3)
    dubstep_basic: [0,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0], // Classic dubstep snare
    dubstep_trap: [0,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,1,0],  // Trap-influenced
    dubstep_roll: [0,0,0,0, 0,0,0,0, 1,0,1,1, 0,0,0,0],  // Snare rolls
    // Trance snare patterns (uplifting, driving)
    trance_clap: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],   // Standard clap
    trance_build: [0,0,0,0, 1,0,0,1, 0,0,1,0, 1,0,1,1],  // Building energy
    trance_uplift: [0,0,0,0, 1,0,0,0, 0,0,1,0, 1,0,0,0]  // Uplifting pattern
  },
  // Classic acid bassline patterns (rhythm only, notes added later)
  acid: {
    // Phuture - Acid Tracks style
    phuture: [1,0,1,0, 1,0,0,1, 1,0,1,0, 0,1,0,1],
    // Josh Wink - Higher State of Consciousness style  
    wink: [1,1,0,1, 0,1,1,0, 1,0,1,1, 0,0,1,0],
    // Hardfloor style
    hardfloor: [1,0,0,1, 1,0,1,0, 0,1,0,1, 1,0,0,0],
    // DJ Pierre style
    pierre: [1,0,1,1, 0,0,1,0, 1,1,0,1, 0,0,1,0],
    // Minimal acid
    minimal: [1,0,0,0, 0,0,1,0, 0,0,0,0, 1,0,0,0],
    // Random busy pattern
    busy: [1,1,0,1, 1,0,1,1, 0,1,1,0, 1,0,1,1]
  }
};

// State
let currentBar = 0;
window.currentBar = 0; // Expose globally for game
let currentChordIndex = 0;
let currentProgression = null;
let acidSequence = [];
let energyLevel = 50;
let tensionLevel = 30;
let lastSection = '';
let isTransitioning = false;
let riserActive = false;

// Mute states - initialized from saved data
const muteStates = {
  kick: savedData.settings?.trackMutes?.kick || false,
  snare: savedData.settings?.trackMutes?.snare || false,
  hat: savedData.settings?.trackMutes?.hat || false,
  acid: savedData.settings?.trackMutes?.acid || false,
  stab: savedData.settings?.trackMutes?.stab || false,
  sub: savedData.settings?.trackMutes?.sub || false
};

// Humanization - adds micro-timing variations
function humanize(time, amount = 0.01) {
  // Add random timing offset between -amount and +amount seconds
  return time + (Math.random() - 0.5) * amount * 2;
}

// Visual feedback
function flashIndicator(id) {
  // Flash the minimized track square
  const trackName = id.replace('Indicator', '');
  const square = document.getElementById(trackName + 'Square');
  if (square && !muteStates[trackName]) {
    square.classList.add('flash');
    setTimeout(() => square.classList.remove('flash'), 100);
  }
}

// Generate melodic acid sequence using classic patterns
function generateMelodicAcidSequence(chordInfo, section, previousSequence = []) {
  const sequence = [];
  const octave = section === 'DROP' ? 3 : 2;
  
  // Select rhythm pattern based on section
  let rhythmPattern;
  if (section === 'DROP') {
    // Use classic acid patterns for drops
    const patterns = [patternBank.acid.phuture, patternBank.acid.wink, patternBank.acid.hardfloor];
    rhythmPattern = patterns[Math.floor(Math.random() * patterns.length)];
  } else if (section === 'BUILD') {
    rhythmPattern = patternBank.acid.pierre;
  } else if (section === 'BREAK') {
    rhythmPattern = patternBank.acid.minimal;
  } else {
    // Main section varies
    rhythmPattern = Math.random() > 0.5 ? patternBank.acid.hardfloor : patternBank.acid.phuture;
  }
  
  // Use chord tones as anchors
  const chordTones = chordInfo.melodicFocus;
  let lastNote = previousSequence.length > 0 ? previousSequence[previousSequence.length - 1] : null;
  
  for (let i = 0; i < 16; i++) {
    if (rhythmPattern[i]) {
      let note;
      
      // Strong beats (0, 4, 8, 12) favor chord tones
      if (i % 4 === 0) {
        note = chordTones[Math.floor(Math.random() * chordTones.length)] + octave;
      } else if (lastNote && Math.random() > 0.3) {
        // Stepwise motion from last note for that 303 feel
        const lastPitch = lastNote.replace(/\d/, '');
        const lastOctave = parseInt(lastNote.replace(/\D/g, ''));
        const scaleIndex = scale.indices[lastPitch];
        
        if (scaleIndex !== undefined) {
          // Classic 303 often moves in small steps
          const direction = Math.random() > 0.5 ? 1 : -1;
          const stepSize = Math.random() > 0.7 ? 2 : 1; // Occasionally jump a third
          const newIndex = (scaleIndex + direction * stepSize + 7) % 7;
          note = scale.C[newIndex] + lastOctave;
        } else {
          note = chordTones[Math.floor(Math.random() * chordTones.length)] + octave;
        }
      } else {
        // Random scale note
        note = scale.C[Math.floor(Math.random() * scale.C.length)] + octave;
      }
      
      sequence.push(note);
      lastNote = note;
    } else {
      sequence.push(null);
    }
  }
  
  return sequence;
}

// Generate drum fill
function generateDrumFill() {
  return {
    kick: patternBank.kick.fill,
    snare: patternBank.snare.fill,
    hihat: new Array(16).fill(1) // Rapid hi-hats
  };
}

// Get section
function getSection(bar) {
  const pos = bar % 64;
  if (pos < 8) return 'INTRO';
  if (pos < 16) return 'BUILD';
  if (pos < 32) return 'MAIN';
  if (pos < 40) return 'BREAK';
  if (pos < 56) return 'DROP';
  return 'OUTRO';
}

// Check if we're approaching a section change
function isApproachingTransition(bar) {
  const pos = bar % 64;
  const transitionBars = [7, 15, 31, 39, 55, 63];
  return transitionBars.includes(pos);
}

// Generate patterns based on section and energy
function generatePatterns(section, bar, energy) {
  const patterns = {};
  const isFill = isApproachingTransition(bar);
  
  if (isFill) {
    // Drum fill before section change
    const fill = generateDrumFill();
    patterns.kick = fill.kick;
    patterns.snare = fill.snare;
    patterns.hihat = fill.hihat;
  } else {
    // Use genre-specific patterns based on section
    const genreConfig = GENRE_CONFIGS[currentGenre];
    
    if (section === 'DROP') {
      // Drop section - use genre-specific intense patterns
      if (currentGenre === 'dnb') {
        patterns.kick = patternBank.kick.dnb_jump;
        patterns.snare = patternBank.snare.dnb_roll;
      } else if (currentGenre === 'tropical') {
        patterns.kick = patternBank.kick.kygo_bounce;
        patterns.snare = patternBank.snare.kygo_clap;
      } else {
        patterns.kick = Math.random() > 0.5 ? patternBank.kick.chicago : patternBank.kick.detroit;
        patterns.snare = energy > 70 ? patternBank.snare.detroit : patternBank.snare.backbeat;
      }
    } else if (section === 'MAIN') {
      // Main section - rotate through genre patterns
      if (currentGenre === 'dnb') {
        const dnbKicks = [patternBank.kick.dnb_basic, patternBank.kick.dnb_amen];
        patterns.kick = dnbKicks[Math.floor((bar / 4) % dnbKicks.length)];
        patterns.snare = patternBank.snare.dnb_basic;
      } else if (currentGenre === 'tropical') {
        patterns.kick = patternBank.kick.kygo_basic;
        patterns.snare = patternBank.snare.kygo_rim;
      } else if (currentGenre === 'dubstep') {
        patterns.kick = patternBank.kick.dubstep_basic;
        patterns.snare = patternBank.snare.dubstep_basic;
      } else if (currentGenre === 'trance') {
        patterns.kick = patternBank.kick.trance_kick;
        patterns.snare = patternBank.snare.trance_clap;
      } else {
        const kickStyles = [patternBank.kick.fourOnFloor, patternBank.kick.berlin, patternBank.kick.detroit];
        patterns.kick = kickStyles[Math.floor((bar / 4) % kickStyles.length)];
        patterns.snare = patternBank.snare.backbeat;
      }
    } else if (section === 'BUILD') {
      patterns.kick = patternBank.kick.halfTime;
      patterns.snare = patternBank.snare.minimal;
    } else if (section === 'BREAK') {
      patterns.kick = patternBank.kick.minimal;
      patterns.snare = new Array(16).fill(0);
    } else {
      patterns.kick = patternBank.kick.halfTime;
      patterns.snare = patternBank.snare.minimal;
    }
    
    // Hi-hat patterns based on genre
    if (currentGenre === 'dnb') {
      // D&B has rapid, intricate hi-hats
      if (tensionLevel > 70) {
        patterns.hihat = new Array(16).fill(1); // Constant ride at high tension
      } else {
        patterns.hihat = [1,0,1,1, 1,0,1,1, 1,0,1,1, 1,0,1,1]; // D&B shuffle
      }
    } else if (currentGenre === 'tropical') {
      // Tropical has sparse, laid-back hi-hats
      if (section === 'DROP') {
        patterns.hihat = [0,1,0,1, 0,1,0,1, 0,1,0,1, 0,1,0,1]; // Shaker pattern
      } else {
        patterns.hihat = [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0]; // Quarter notes
      }
    } else if (currentGenre === 'dubstep') {
      // Dubstep has minimal, sparse hi-hats
      patterns.hihat = [0,0,1,0, 0,0,0,0, 0,0,1,0, 0,0,0,0]; // Very sparse
    } else if (currentGenre === 'trance') {
      // Trance has steady, driving hi-hats
      patterns.hihat = [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0]; // Steady 8ths
    } else {
      // Techno - dynamic based on energy AND tension
      patterns.hihat = [];
      const hihatDensity = (energy / 100) * 0.5 + (tensionLevel / 100) * 0.5;
      for (let i = 0; i < 16; i++) {
        // More rapid hits at high tension
        if (tensionLevel > 70 && i % 2 === 1) {
          patterns.hihat[i] = 1; // Constant 16ths at high tension
        } else {
          patterns.hihat[i] = Math.random() < hihatDensity ? 1 : 0;
        }
      }
    }
  }
  
  // Stab patterns that complement the acid line
  // Look at where acid pattern has gaps and fill them
  const acidDensity = acidSequence ? acidSequence.filter(n => n).length : 8;
  
  const stabPatterns = [
    [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0], // Single hit on downbeat
    [0,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0], // Single hit midway
    [0,0,0,0, 0,0,0,1, 0,0,0,0, 0,0,0,0], // Single hit on upbeat
    new Array(16).fill(0) // Rest
  ];
  
  // Simplified - sparse stabs for impact
  if (section === 'BREAK') {
    patterns.stab = stabPatterns[3]; // No stabs in break
  } else if (section === 'DROP') {
    // Hit on first bar of drop for impact
    patterns.stab = (bar % 4 === 0) ? stabPatterns[0] : stabPatterns[3];
  } else if (section === 'BUILD') {
    // Occasional stab to build tension
    patterns.stab = (bar % 2 === 1) ? stabPatterns[2] : stabPatterns[3];
  } else if (section === 'MAIN') {
    // Every other bar
    patterns.stab = (bar % 2 === 0) ? stabPatterns[1] : stabPatterns[3];
  } else {
    // INTRO/OUTRO - very minimal
    patterns.stab = (bar % 4 === 0) ? stabPatterns[1] : stabPatterns[3];
  }
  
  return patterns;
}

// Sequences
let kickLoop, snareLoop, hihatLoop, acidLoop, chordLoop, subLoop;

function updatePatterns() {
  const section = getSection(currentBar);
  
  // Update progression if needed
  if (!currentProgression || currentBar % 8 === 0) {
    currentProgression = getChordProgression(section);
  }
  const chordInfo = currentProgression[currentChordIndex % currentProgression.length];
  
  // Generate melodic acid sequence FIRST
  if (currentBar % 2 === 0) {
    acidSequence = generateMelodicAcidSequence(chordInfo, section, acidSequence);
    // Pattern displays were removed with minimized UI
  }
  
  // THEN generate patterns (so stabs can respond to acid)
  const patterns = generatePatterns(section, currentBar, energyLevel);
  
  // Clear and recreate sequences
  if (kickLoop) kickLoop.dispose();
  if (snareLoop) snareLoop.dispose();
  if (hihatLoop) hihatLoop.dispose();
  if (acidLoop) acidLoop.dispose();
  if (chordLoop) chordLoop.dispose();
  if (subLoop) subLoop.dispose();
  
  // Kick with micro-timing
  kickLoop = new Tone.Sequence((time, note) => {
    if (note && !muteStates.kick) {
      // Slight timing variation, but keep kick more stable
      const humanTime = humanize(time, 0.003);
      kick.triggerAttackRelease("C1", "8n", humanTime);
      sidechain.ratio.setValueAtTime(20, humanTime);
      sidechain.ratio.linearRampToValueAtTime(8, humanTime + 0.1);
      Tone.Draw.schedule(() => {
        flashIndicator('kickIndicator');
        // Trigger game beat event
        if (window.GameAPI && window.GameAPI.onBeat) {
          window.GameAPI.onBeat();
        }
      }, humanTime);
    }
  }, patterns.kick, "16n");
  
  // Snare with more looseness
  snareLoop = new Tone.Sequence((time, note) => {
    if (note && !muteStates.snare) {
      const humanTime = humanize(time, 0.005);
      snare.triggerAttackRelease("8n", humanTime);
      Tone.Draw.schedule(() => {
        flashIndicator('snareIndicator');
        // Trigger different enemy type on snare
        if (window.GameAPI && window.GameAPI.onSnare) {
          window.GameAPI.onSnare();
        }
      }, humanTime);
    }
  }, patterns.snare, "16n");
  
  // Hi-hat with most variation
  hihatLoop = new Tone.Sequence((time, note) => {
    if (note && !muteStates.hat) {
      const humanTime = humanize(time, 0.008);
      // Vary between closed and open hi-hats
      const velocity = 0.3 + Math.random() * 0.4;
      const duration = Math.random() > 0.8 ? "16n" : "32n"; // Occasional longer hat
      hihat.triggerAttackRelease(duration, humanTime);
      hihat.volume.setValueAtTime(-15 + (velocity * 10), humanTime); // Subtle volume variation
      Tone.Draw.schedule(() => {
        flashIndicator('hatIndicator');
        // Spawn obstacles on some hi-hat hits
        if (Math.random() < 0.2 && window.GameAPI && window.GameAPI.onHihat) {
          window.GameAPI.onHihat();
        }
      }, humanTime);
    }
  }, patterns.hihat, "16n");
  
  // Acid with melodic sequence - slight timing variations and accent
  acidLoop = new Tone.Sequence((time, note, index) => {
    if (note && !muteStates.acid) {
      const humanTime = humanize(time, 0.004);
      // Add accent to some notes (first beat of each group and random others)
      const isAccent = index % 4 === 0 || (Math.random() > 0.85 && tensionLevel > 50);
      
      if (isAccent) {
        // Accent: louder with more filter modulation
        acid.volume.value = 3;
        acid.filterEnvelope.octaves = 5;
        acidDistortion.wet.value = 0.7;
      } else {
        acid.volume.value = 0;
        acid.filterEnvelope.octaves = 4;
        acidDistortion.wet.value = 0.5;
      }
      
      acid.triggerAttackRelease(note, "16n", humanTime);
      Tone.Draw.schedule(() => {
        flashIndicator('acidIndicator');
        // Spawn power-up occasionally
        if (Math.random() < 0.1 && window.GameAPI && window.GameAPI.onAcid) {
          window.GameAPI.onAcid();
        }
      }, humanTime);
    }
  }, acidSequence, "16n");
  
  // Stabs with slight spread and filter variation
  chordLoop = new Tone.Sequence((time, hit, index) => {
    if (hit && !muteStates.stab) {
      const humanTime = humanize(time, 0.006);
      
      // Vary the filter based on section
      const currentSection = getSection(currentBar);
      if (currentSection === 'DROP') {
        stabFilter.frequency.setValueAtTime(3500, humanTime);
      } else if (currentSection === 'BUILD') {
        // Gradually open filter in builds
        stabFilter.frequency.exponentialRampToValueAtTime(2500, humanTime + 0.2);
      } else {
        stabFilter.frequency.setValueAtTime(2000, humanTime);
      }
      
      // Choose chord voicing based on what acid is doing
      // If acid is playing high, play stabs lower and vice versa
      const acidNote = acidSequence[index];
      let chordToPlay = chordInfo.chord;
      
      if (acidNote && acidNote.includes('3')) {
        // Acid is high, play stabs an octave lower
        chordToPlay = chordInfo.chord.map(note => 
          note.replace(/(\d)/, (match) => parseInt(match) - 1)
        );
      }
      
      // Simple - just play the chord once with slight strum
      chordToPlay.forEach((note, i) => {
        const noteTime = humanTime + i * 0.015; // Slight strum
        raveSynth.triggerAttackRelease(note, "4n", noteTime); // Longer note for reverb tail
      });
      
      Tone.Draw.schedule(() => {
        flashIndicator('stabIndicator');
        // Spawn drifter enemy
        if (window.GameAPI && window.GameAPI.onStab) {
          window.GameAPI.onStab();
        }
      }, humanTime);
    }
  }, patterns.stab, "16n");
  
  // Sub bass pattern - genre-specific
  let subPattern;
  if (currentGenre === 'dnb') {
    // D&B: Long sustained sub-bass notes, often sliding
    subPattern = [
      chordInfo.bass, null, null, null,
      null, null, null, null,
      null, null, null, null,
      chordInfo.bass, null, null, null
    ];
  } else if (currentGenre === 'tropical') {
    // Tropical: Bouncing, syncopated bass following dembow rhythm
    subPattern = [
      chordInfo.bass, null, null, chordInfo.bass,
      null, null, chordInfo.bass, null,
      chordInfo.bass, null, null, chordInfo.bass,
      null, null, chordInfo.bass, null
    ];
  } else {
    // Techno: Offset from kick to avoid mud
    subPattern = [
      null, chordInfo.bass, null, null,  // Offset by one 16th
      null, null, null, null,
      null, chordInfo.bass, null, null,  // Offset by one 16th
      null, null, null, null
    ];
  }
  subLoop = new Tone.Sequence((time, note) => {
    if (note && !muteStates.sub) {
      const humanTime = humanize(time, 0.002); // Very slight timing variation
      // Play longer note that sustains
      subBass.triggerAttackRelease(note, "2n", humanTime);
      // Add a subtle octave above for presence (only in drops)
      const currentSection = getSection(currentBar);
      if (currentSection === 'DROP' || currentSection === 'MAIN') {
        const octaveUp = note.replace(/\d/, (match) => parseInt(match) + 1);
        subBass.triggerAttackRelease(octaveUp, "2n", humanTime + 0.01, 0.3); // Quieter octave
      }
      Tone.Draw.schedule(() => {
        flashIndicator('subIndicator');
        // Pulse the grid
        if (window.GameAPI && window.GameAPI.onSub) {
          window.GameAPI.onSub();
        }
      }, humanTime);
    }
  }, subPattern, "16n");
  
  kickLoop.start(0);
  snareLoop.start(0);
  hihatLoop.start(0);
  acidLoop.start(0);
  chordLoop.start(0);
  subLoop.start(0);
}

// Apply tension to parameters
function applyTension() {
  const now = Tone.now();
  
  // Both acid filters open with tension
  const baseFreq = 300 + (tensionLevel * 15);
  const targetFreq = baseFreq + (tensionLevel * 25);
  acidFilter1.frequency.linearRampToValueAtTime(targetFreq, now + 0.5);
  acidFilter2.frequency.linearRampToValueAtTime(targetFreq * 0.9, now + 0.5);  // Slightly offset
  acidFilter1.Q.value = 4 + (tensionLevel / 100) * 12;
  acidFilter2.Q.value = 2 + (tensionLevel / 100) * 4;
  
  // Increase distortion with tension
  acidDistortion.distortion = 0.3 + (tensionLevel / 100) * 0.4;
  
  // Master highpass rises with extreme tension
  if (tensionLevel > 80) {
    masterHighpass.frequency.exponentialRampToValueAtTime(100 + (tensionLevel - 80) * 10, now + 0.5);
  } else {
    masterHighpass.frequency.exponentialRampToValueAtTime(20, now + 0.5);
  }
  
  // Sidechain gets more aggressive
  sidechain.ratio.value = 8 + (tensionLevel / 100) * 12;
  
  // Start/stop noise riser
  if (tensionLevel > 60 && !riserActive) {
    noiseRiser.start();
    riserEnvelope.triggerAttack();
    riserActive = true;
  } else if (tensionLevel <= 60 && riserActive) {
    riserEnvelope.triggerRelease();
    setTimeout(() => noiseRiser.stop(), 500);
    riserActive = false;
  }
  
  // Riser volume follows tension
  if (riserActive) {
    noiseRiser.volume.value = -40 + (tensionLevel - 60) * 0.5;
  }
}

// Automation curves for smooth transitions
function applyAutomation(section, prevSection) {
  const now = Tone.now();
  
  // Filter automation for both cascaded filters
  if (section === 'DROP' && prevSection !== 'DROP') {
    acidFilter1.frequency.exponentialRampToValueAtTime(2000, now + 2);
    acidFilter2.frequency.exponentialRampToValueAtTime(1800, now + 2);
    acidFilter1.Q.linearRampToValueAtTime(15, now + 2);
    acidDistortion.distortion = 0.6;
  } else if (section === 'BREAK') {
    acidFilter1.frequency.exponentialRampToValueAtTime(400, now + 1);
    acidFilter2.frequency.exponentialRampToValueAtTime(400, now + 1);
    acidFilter1.Q.linearRampToValueAtTime(5, now + 1);
    acidDistortion.distortion = 0.2;
  } else if (section === 'BUILD') {
    acidFilter1.frequency.exponentialRampToValueAtTime(1200, now + 4);
    acidFilter2.frequency.exponentialRampToValueAtTime(1100, now + 4);
  }
}

// Main evolution function
function evolve() {
  const section = getSection(currentBar);
  const nextBar = (currentBar + 1) % 64;
  const nextSection = getSection(nextBar);
  
  // Update displays
  document.getElementById('section').textContent = section;
  document.getElementById('bar').textContent = currentBar;
  const currentChord = currentProgression ? currentProgression[currentChordIndex % currentProgression.length] : { root: 'C' };
  document.getElementById('chord').textContent = currentChord.root + (currentChord.chord.length > 3 ? '7' : 'm');
  
  // Calculate next transition
  const barsUntilNext = nextSection !== section ? 1 : 
    nextBar < 8 ? 8 - nextBar :
    nextBar < 16 ? 16 - nextBar :
    nextBar < 32 ? 32 - nextBar :
    nextBar < 40 ? 40 - nextBar :
    nextBar < 56 ? 56 - nextBar :
    64 - nextBar;
  document.getElementById('nextSection').textContent = 
    nextSection !== section ? `${nextSection} next bar` : 
    `${getSection(currentBar + barsUntilNext)} in ${barsUntilNext} bars`;
  
  // Apply automation on section changes
  if (section !== lastSection) {
    applyAutomation(section, lastSection);
    lastSection = section;
  }
  
  // Update patterns every bar
  if (currentBar % 1 === 0) {
    updatePatterns();
  }
  
  // Apply tension continuously
  applyTension();
  
  // Vary chord progression rate based on section (already declared above)
  if (section === 'DROP' || section === 'MAIN') {
    // Change chord every 2 bars for more movement
    if (currentBar % 2 === 0) {
      currentChordIndex = (currentChordIndex + 1) % (currentProgression ? currentProgression.length : 4);
    }
  } else if (section === 'BREAK') {
    // Stay on same chord for whole break - hypnotic
    currentChordIndex = 0;
  } else {
    // Normal progression every 4 bars
    if (currentBar % 4 === 0) {
      currentChordIndex = (currentChordIndex + 1) % (currentProgression ? currentProgression.length : 4);
    }
  }
  
  currentBar = (currentBar + 1) % 64;
  window.currentBar = currentBar;
}

// Schedule evolution
Tone.Transport.scheduleRepeat(() => evolve(), "1m");

// UI State Management
const uiState = {
  isPlaying: false,
  settingsOpen: false,
  gridVisible: false
};

function updatePlayPauseButton() {
  const btn = document.getElementById('playPauseBtn');
  if (!btn) return;
  
  // Use simple text that won't render as emojis
  if (uiState.isPlaying) {
    btn.textContent = '||';
    btn.title = 'Pause';
  } else {
    btn.textContent = '▶';
    btn.title = 'Play';
  }
}

function updateSettingsButton() {
  const btn = document.getElementById('expandBtn');
  if (!btn) return;
  
  if (uiState.settingsOpen) {
    btn.textContent = 'X';
    btn.title = 'Close Settings';
  } else {
    btn.textContent = '☰';
    btn.title = 'Settings';
  }
}

function updateGridButton() {
  const btn = document.getElementById('gridToggleBtn');
  if (!btn) return;
  
  btn.textContent = '⊞';
  
  if (uiState.gridVisible) {
    btn.style.color = '#0f0';
  } else {
    btn.style.color = '#666';
  }
}


// Controls
const playPauseBtn = document.getElementById('playPauseBtn');
if (playPauseBtn) {
  playPauseBtn.addEventListener('click', async () => {
    await Tone.start();
    
    // Check if game is running and handle game pause
    const gameScene = window.gameScene;
    if (gameScene && gameScene.scene.isActive()) {
      if (Tone.Transport.state === 'started') {
        // Pause both music and game
        gameScene.pauseGame();
      } else {
        // Resume both music and game
        gameScene.resumeGame();
      }
    } else {
      // No game running, just handle music
      if (Tone.Transport.state !== 'started') {
        // Play
        currentBar = 0;
        window.currentBar = 0;
        currentChordIndex = 0;
        lastSection = '';
        updatePatterns();
        Tone.Transport.start();
        document.getElementById('status').textContent = 'PLAYING';
        uiState.isPlaying = true;
        updatePlayPauseButton();
      } else {
        // Pause
        Tone.Transport.pause();
        document.getElementById('status').textContent = 'PAUSED';
        uiState.isPlaying = false;
        updatePlayPauseButton();
      }
    }
  });
}

document.getElementById('bpmSlider').addEventListener('input', (e) => {
  const bpm = parseInt(e.target.value);
  Tone.Transport.bpm.value = bpm;
  document.getElementById('bpmDisplay').textContent = bpm;
  // Mark as custom and save
  markCustomPreset();
  saveGameDataDebounced({ 
    settings: { 
      musicPreset: 'custom',
      customMusic: { bpm: bpm }
    }
  });
});

document.getElementById('energySlider').addEventListener('input', (e) => {
  energyLevel = parseInt(e.target.value);
  document.getElementById('energyDisplay').textContent = energyLevel;
  // Mark as custom and save
  markCustomPreset();
  saveGameDataDebounced({ 
    settings: { 
      musicPreset: 'custom',
      customMusic: { energy: energyLevel }
    }
  });
});

document.getElementById('tensionSlider').addEventListener('input', (e) => {
  tensionLevel = parseInt(e.target.value);
  document.getElementById('tensionDisplay').textContent = tensionLevel;
  // Apply tension immediately when slider moves
  if (Tone.Transport.state === 'started') {
    applyTension();
  }
  // Mark as custom and save
  markCustomPreset();
  saveGameDataDebounced({ 
    settings: { 
      musicPreset: 'custom',
      customMusic: { tension: tensionLevel }
    }
  });
});

// Sound selector
document.getElementById('soundSelector').addEventListener('change', (e) => {
  gameSounds.currentLaserSound = parseInt(e.target.value);
  document.getElementById('soundDisplay').textContent = e.target.options[e.target.selectedIndex].text;
  // Save laser sound selection
  saveGameDataDebounced({ settings: { laserSound: gameSounds.currentLaserSound } });
});

// Music preset definitions
const MUSIC_PRESETS = {
  'chill': { energy: 30, tension: 20, description: 'Laid back minimal' },
  'driving': { energy: 60, tension: 40, description: 'Classic driving' },
  'peak': { energy: 85, tension: 70, description: 'Peak time energy' },
  'acid': { energy: 75, tension: 90, description: '303 madness' },
  'dark': { energy: 40, tension: 80, description: 'Dark & brooding' },
  'hypnotic': { energy: 50, tension: 60, description: 'Repetitive & hypnotic' },
  'anthem': { energy: 90, tension: 60, description: 'Stadium anthem' }
};

// Difficulty preset definitions
const DIFFICULTY_PRESETS = {
  'zen': { speedMult: 0.5, fireMult: 2.0, spawnMult: 0.5, description: 'Relaxed' },
  'normal': { speedMult: 1.0, fireMult: 1.0, spawnMult: 1.0, description: 'Standard' },
  'intense': { speedMult: 1.5, fireMult: 0.8, spawnMult: 1.3, description: 'Challenging' },
  'chaos': { speedMult: 2.0, fireMult: 0.5, spawnMult: 2.0, description: 'Maximum chaos' }
};

let currentDifficulty = DIFFICULTY_PRESETS.normal;

// Difficulty will be applied after savedData is loaded

// Music preset selector
document.getElementById('musicPresetSelector')?.addEventListener('change', (e) => {
  const presetKey = e.target.value;
  if (presetKey && MUSIC_PRESETS[presetKey]) {
    const preset = MUSIC_PRESETS[presetKey];
    
    // Apply preset values (no BPM - let genre control that)
    energyLevel = preset.energy;
    tensionLevel = preset.tension;
    
    // Update sliders (energy and tension only)
    document.getElementById('energySlider').value = preset.energy;
    document.getElementById('energyDisplay').textContent = preset.energy;
    document.getElementById('tensionSlider').value = preset.tension;
    document.getElementById('tensionDisplay').textContent = preset.tension;
    
    // Update description
    document.getElementById('musicPresetDisplay').textContent = preset.description;
    
    // Apply tension if playing
    if (Tone.Transport.state === 'started') {
      applyTension();
    }
    
    // Save preset selection
    saveGameDataDebounced({ settings: { musicPreset: presetKey } });
  } else {
    document.getElementById('musicPresetDisplay').textContent = 'Custom settings';
    // Save custom preset marker
    saveGameDataDebounced({ settings: { musicPreset: 'custom' } });
  }
});

// Difficulty selector
document.getElementById('difficultySelector')?.addEventListener('change', (e) => {
  const diffKey = e.target.value;
  if (DIFFICULTY_PRESETS[diffKey]) {
    currentDifficulty = DIFFICULTY_PRESETS[diffKey];
    document.getElementById('difficultyDisplay').textContent = currentDifficulty.description;
    
    // Save difficulty setting
    saveGameDataDebounced({ settings: { difficulty: diffKey } });
    
    // Track difficulty change
    trackEvent('settings_change', {
      setting_type: 'difficulty',
      difficulty_level: diffKey,
      multiplier: currentDifficulty.multiplier
    });
  }
});

// Update sliders to set preset to custom
const markCustomPreset = () => {
  document.getElementById('musicPresetSelector').value = '';
  document.getElementById('musicPresetDisplay').textContent = 'Custom settings';
};

// Note: markCustomPreset is now called within each slider's event handler

// Genre switching handlers
document.getElementById('genreTechno').addEventListener('click', () => switchGenre('techno'));
document.getElementById('genreDnb').addEventListener('click', () => switchGenre('dnb'));
document.getElementById('genreTropical').addEventListener('click', () => switchGenre('tropical'));
document.getElementById('genreDubstep').addEventListener('click', () => switchGenre('dubstep'));
document.getElementById('genreTrance').addEventListener('click', () => switchGenre('trance'));

function switchGenre(genre) {
  const previousGenre = currentGenre;
  currentGenre = genre;
  const config = GENRE_CONFIGS[genre];
  
  // Track genre change (only if actually changed)
  if (previousGenre && previousGenre !== genre) {
    trackEvent('settings_change', {
      setting_type: 'genre',
      genre_from: previousGenre,
      genre_to: genre,
      bpm: config.bpmDefault
    });
  }
  
  // Update BPM slider range and value
  const bpmSlider = document.getElementById('bpmSlider');
  bpmSlider.min = config.bpmMin;
  bpmSlider.max = config.bpmMax;
  bpmSlider.value = config.bpmDefault;
  
  // Update BPM
  Tone.Transport.bpm.value = config.bpmDefault;
  document.getElementById('bpmDisplay').textContent = config.bpmDefault;
  
  // Switch stab synth based on genre
  if (genre === 'dnb') {
    raveSynth = dnbReese;
  } else if (genre === 'tropical') {
    raveSynth = tropicalPluck;
  } else if (genre === 'dubstep') {
    raveSynth = dnbReese; // Use Reese for dubstep wobbles
  } else if (genre === 'trance') {
    raveSynth = technoStab; // Use saw stabs for trance
  } else {
    raveSynth = technoStab;
  }
  
  // Adjust kick tuning for genre (only if instruments are loaded)
  if (typeof kick !== 'undefined') {
    if (genre === 'tropical') {
      // 808-style deeper kick for tropical
      kick.oscillator.frequency.value = 50;
      kick.octaves = 6;
    } else if (genre === 'dnb') {
      // Punchy, tight kick for D&B
      kick.oscillator.frequency.value = 65;
      kick.octaves = 3;
    } else if (genre === 'dubstep') {
      // Deep sub kick for dubstep
      kick.oscillator.frequency.value = 45;
      kick.octaves = 7;
    } else if (genre === 'trance') {
      // Punchy trance kick
      kick.oscillator.frequency.value = 60;
      kick.octaves = 4;
    } else {
      // Classic 909 kick for techno
      kick.oscillator.frequency.value = 60;
      kick.octaves = 4;
    }
  }
  
  // Update button styles
  const genreButtonMap = {
    'techno': 'genreTechno',
    'dnb': 'genreDnb',
    'tropical': 'genreTropical', 
    'dubstep': 'genreDubstep',
    'trance': 'genreTrance'
  };
  
  Object.keys(genreButtonMap).forEach(g => {
    const btn = document.getElementById(genreButtonMap[g]);
    if (btn) {
      btn.style.setProperty('background', genre === g ? '#0f0' : '#333', 'important');
      btn.style.setProperty('color', genre === g ? '#000' : '#0f0', 'important');
    }
  });
  
  // Force pattern update on next bar
  updatePatterns();
}

// Initial BPM and genre - will be overridden by saved settings if they exist
Tone.Transport.bpm.value = 132;
// Set initial genre button highlighting
switchGenre('techno');

// Apply saved music settings after page loads
window.addEventListener('load', () => {
  if (savedData.settings) {
    // Apply saved music preset or custom values
    if (savedData.settings.musicPreset === 'custom' && savedData.settings.customMusic) {
      // Apply custom BPM/energy/tension
      const custom = savedData.settings.customMusic;
      if (custom.bpm) {
        Tone.Transport.bpm.value = custom.bpm;
        document.getElementById('bpmSlider').value = custom.bpm;
        document.getElementById('bpmDisplay').textContent = custom.bpm;
      }
      if (custom.energy !== undefined) {
        energyLevel = custom.energy;
        document.getElementById('energySlider').value = custom.energy;
        document.getElementById('energyDisplay').textContent = custom.energy;
      }
      if (custom.tension !== undefined) {
        tensionLevel = custom.tension;
        document.getElementById('tensionSlider').value = custom.tension;
        document.getElementById('tensionDisplay').textContent = custom.tension;
      }
      // Set preset selector to custom
      document.getElementById('musicPresetSelector').value = '';
      document.getElementById('musicPresetDisplay').textContent = 'Custom settings';
    } else if (savedData.settings.musicPreset && MUSIC_PRESETS[savedData.settings.musicPreset]) {
      // Apply preset
      const preset = MUSIC_PRESETS[savedData.settings.musicPreset];
      energyLevel = preset.energy;
      tensionLevel = preset.tension;
      document.getElementById('musicPresetSelector').value = savedData.settings.musicPreset;
      document.getElementById('musicPresetDisplay').textContent = preset.description;
      document.getElementById('energySlider').value = preset.energy;
      document.getElementById('energyDisplay').textContent = preset.energy;
      document.getElementById('tensionSlider').value = preset.tension;
      document.getElementById('tensionDisplay').textContent = preset.tension;
    }
    
    // Apply saved difficulty UI
    if (savedData.settings.difficulty) {
      document.getElementById('difficultySelector').value = savedData.settings.difficulty;
      document.getElementById('difficultyDisplay').textContent = currentDifficulty.description;
    }
    
    // Apply saved laser sound UI
    if (savedData.settings.laserSound !== undefined) {
      document.getElementById('soundSelector').value = savedData.settings.laserSound;
      const soundNames = ['Triangle', 'Acid', 'Chord', 'Echo', 'Pluck', 'Pew Pew'];
      document.getElementById('soundDisplay').textContent = soundNames[savedData.settings.laserSound];
    }
    
    // Apply mute states to UI
    Object.keys(muteStates).forEach(track => {
      const square = document.getElementById(track + 'Square');
      if (square) {
        if (muteStates[track]) {
          square.classList.remove('active');
          square.classList.add('muted');
        } else {
          square.classList.add('active');
          square.classList.remove('muted');
        }
      }
    });
  }
});

// Track square handlers for minimized controls
['kick', 'snare', 'hat', 'acid', 'stab', 'sub'].forEach(track => {
  const square = document.getElementById(track + 'Square');
  if (square) {
    // Initialize as active (not muted)
    square.classList.add('active');
    
    square.addEventListener('click', () => {
      muteStates[track] = !muteStates[track];
      if (muteStates[track]) {
        square.classList.remove('active');
        square.classList.add('muted');
      } else {
        square.classList.add('active');
        square.classList.remove('muted');
      }
      // Save track mute state
      saveGameDataDebounced({ settings: { trackMutes: { [track]: muteStates[track] } } });
    });
  }
});

// Expand/minimize panel with smooth animation
const expandBtn = document.getElementById('expandBtn');
const expandedPanel = document.getElementById('expandedPanel');
const musicControls = document.getElementById('musicControls');

// Handle touch events for transparency
function addTouchHandlers(element) {
  if (!element) return;
  
  let touchTimeout;
  
  // Only add touch handlers on actual touch devices
  if ('ontouchstart' in window) {
    element.addEventListener('touchstart', () => {
      element.classList.add('touched');
      clearTimeout(touchTimeout);
    });
    
    element.addEventListener('touchend', () => {
      // Keep opaque for a bit after touch ends
      touchTimeout = setTimeout(() => {
        element.classList.remove('touched');
      }, 3000); // Stay visible for 3 seconds after touch
    });
  }
  
  // For desktop, ensure touched class is removed on mouse leave
  element.addEventListener('mouseleave', () => {
    // Remove immediately on desktop
    element.classList.remove('touched');
  });
}

// Add touch handlers to both panels
addTouchHandlers(musicControls);
addTouchHandlers(expandedPanel);

// Grid toggle button handler
const gridToggleBtn = document.getElementById('gridToggleBtn');
if (gridToggleBtn) {
  // Don't set initial color here - wait for game to initialize
  gridToggleBtn.addEventListener('click', () => {
    // Trigger grid toggle in the game
    if (window.GameAPI && window.GameAPI.toggleGrid) {
      window.GameAPI.toggleGrid();
    }
  });
}

if (expandBtn) {
  expandBtn.addEventListener('click', (e) => {
    e.stopPropagation(); // Prevent document click from firing
    const musicControls = document.getElementById('musicControls');
    
    if (expandedPanel.classList.contains('expanded')) {
      // Panel is open, close it
      expandedPanel.classList.remove('expanded');
      musicControls.classList.remove('settings-open');
      uiState.settingsOpen = false;
      updateSettingsButton();
      
      // Make player vulnerable again
      const mainScene = game?.scene?.getScene('Main');
      if (mainScene && mainScene.player) {
        mainScene.isInvincible = false;
      }
    } else {
      // Panel is closed, open it
      expandedPanel.classList.add('expanded');
      musicControls.classList.add('settings-open');
      uiState.settingsOpen = true;
      updateSettingsButton();
      
      // Make player invincible and flash
      const mainScene = game?.scene?.getScene('Main');
      if (mainScene && mainScene.player) {
        mainScene.isInvincible = true;
        
        // Flash effect
        mainScene.player.setTint(0xffff00);
        mainScene.time.delayedCall(100, () => {
          mainScene.player.setTint(0xffffff);
          mainScene.time.delayedCall(100, () => {
            mainScene.player.setTint(0xffff00);
            mainScene.time.delayedCall(100, () => {
              mainScene.player.clearTint();
            });
          });
        });
      }
    }
  });
}

// Close menu when clicking outside
document.addEventListener('click', (e) => {
  if (!uiState.settingsOpen) return;
  
  const panel = document.getElementById('expandedPanel');
  const btn = document.getElementById('expandBtn');
  const musicControls = document.getElementById('musicControls');
  
  // Check if click is outside panel, button, and music controls
  if (!panel.contains(e.target) && !btn.contains(e.target) && !musicControls.contains(e.target)) {
    panel.classList.remove('expanded');
    musicControls.classList.remove('settings-open');
    uiState.settingsOpen = false;
    updateSettingsButton();
    
    // Make player vulnerable again
    const mainScene = game?.scene?.getScene('Main');
    if (mainScene && mainScene.player) {
      mainScene.isInvincible = false;
    }
  }
});

// Close menu when game control keys are pressed
document.addEventListener('keydown', (e) => {
  if (!uiState.settingsOpen) return;
  
  // Game control keys that should close the menu
  const gameKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 
                    'a', 'd', 'w', 's', ' ', 'Escape'];
  
  if (gameKeys.includes(e.key) || gameKeys.includes(e.key.toLowerCase())) {
    const panel = document.getElementById('expandedPanel');
    const musicControls = document.getElementById('musicControls');
    panel.classList.remove('expanded');
    musicControls.classList.remove('settings-open');
    uiState.settingsOpen = false;
    updateSettingsButton();
    
    // Make player vulnerable again
    const mainScene = game?.scene?.getScene('Main');
    if (mainScene && mainScene.player) {
      mainScene.isInvincible = false;
    }
  }
});


// Game sounds that blend with the music - route through sidechain for cohesion
const gameReverb = new Tone.Reverb({
  decay: 0.5,
  wet: 0.2
}).connect(sidechain);

// Game sound effects - musical and in-key
// Create off-screen distortion effect chain
const offScreenDistortion = new Tone.Distortion(0.8).connect(sidechain);
const offScreenFilter = new Tone.AutoFilter({
  frequency: "8n",
  baseFrequency: 200,
  octaves: 3,
  depth: 0.8
}).connect(offScreenDistortion);
offScreenFilter.start();

const gameSounds = {
  // Movement - subtle filter sweep in key
  move: new Tone.MonoSynth({
    oscillator: { type: "sine" },
    envelope: { attack: 0.001, decay: 0.02, sustain: 0, release: 0.01 },
    filter: { frequency: 2000, rolloff: -12, Q: 5 },
    filterEnvelope: { attack: 0.001, decay: 0.02, sustain: 0, release: 0.01, baseFrequency: 800, octaves: 1 },
    volume: -18
  }).connect(gameReverb),
  
  // Off-screen womp effect
  offScreenWomp: new Tone.MonoSynth({
    oscillator: { type: "sawtooth" },
    envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.5 },
    filter: { frequency: 100, rolloff: -24, Q: 10 },
    filterEnvelope: { 
      attack: 0.01, 
      decay: 0.3, 
      sustain: 0.2, 
      release: 0.5, 
      baseFrequency: 100, 
      octaves: 4 
    },
    volume: -8
  }).connect(offScreenFilter),
  
  // Jump charge sound - rising pitch
  jumpCharge: new Tone.MonoSynth({
    oscillator: { type: "sawtooth" },
    envelope: { attack: 0.5, decay: 0, sustain: 1, release: 0.1 },
    filter: { frequency: 200, rolloff: -24, Q: 8 },
    filterEnvelope: { attack: 0, decay: 0, sustain: 1, release: 0.1 },
    volume: -12
  }).connect(gameReverb),
  
  // Multiple laser sounds that complement the music
  laserSounds: [
    // 0: Original - Triangle wave with filter sweep
    new Tone.MonoSynth({
      oscillator: { type: "triangle" },
      envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.01 },
      filter: { frequency: 3000, rolloff: -12 },
      filterEnvelope: { attack: 0.001, decay: 0.03, sustain: 0, release: 0.01, baseFrequency: 1500, octaves: -1 },
      volume: -12
    }).connect(sidechain),
    
    // 1: Acid stab - mimics the 303 acid line
    new Tone.MonoSynth({
      oscillator: { type: "sawtooth" },
      envelope: { attack: 0.001, decay: 0.03, sustain: 0, release: 0.02 },
      filter: { frequency: 2000, rolloff: -24, Q: 8 },
      filterEnvelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.02, baseFrequency: 800, octaves: 2 },
      volume: -10
    }).connect(acidFilter1), // Route through acid filter for consistency
    
    // 2: Chord stab - harmonizes with the techno stabs
    new Tone.PolySynth(Tone.Synth, {
      oscillator: { type: "square4" },
      envelope: { attack: 0.001, decay: 0.02, sustain: 0, release: 0.01 },
      volume: -14
    }).connect(stabReverb), // Use the stab reverb for space
    
    // 3: Echo Pulse - metallic sound with delay
    new Tone.MonoSynth({
      oscillator: { type: "pulse", width: 0.2 },
      envelope: { attack: 0.001, decay: 0.04, sustain: 0.2, release: 0.05 },
      filter: { frequency: 4000, rolloff: -12, Q: 3 },
      filterEnvelope: { attack: 0.001, decay: 0.02, sustain: 0.5, release: 0.02, baseFrequency: 2000, octaves: 2 },
      volume: -8
    }).connect(new Tone.FeedbackDelay("16n", 0.5).connect(gameReverb)), // Add echo effect
    
    // 4: Pluck - organic melodic sound
    new Tone.PluckSynth({
      attackNoise: 0.8,
      dampening: 4000,
      resonance: 0.9,
      volume: -10
    }).connect(gameReverb),
    
    // 5: Pew Pew - classic laser with pitch sweep
    new Tone.MonoSynth({
      oscillator: { type: "sine" },
      envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.05 },
      portamento: 0.08, // Glide between pitches
      volume: -6
    }).connect(sidechain)
  ],
  
  currentLaserSound: savedData.settings?.laserSound || 0, // Load saved laser sound preference
  
  // Explosion - filtered noise burst that sounds like a snare hit
  explosion: new Tone.NoiseSynth({
    noise: { type: "pink" },
    envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.02 },
    volume: -8
  }).connect(new Tone.Filter(1200, "highpass").connect(sidechain)),
  
  // Enemy destroy - distorted version of the enemy spawn sound
  enemyDestroy: new Tone.MonoSynth({
    oscillator: { type: "sawtooth" },
    envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1 },
    filter: { frequency: 800, rolloff: -24, Q: 8 },
    filterEnvelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1, baseFrequency: 200, octaves: 2 },
    volume: -10
  }).connect(new Tone.Distortion(0.8).connect(sidechain)),
  
  // Obstacle hit - low thud with pitch bend
  obstacleHit: new Tone.MonoSynth({
    oscillator: { type: "sine" },
    envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.05 },
    portamento: 0.01,
    volume: -8
  }).connect(new Tone.Filter(400, "lowpass").connect(sidechain)),
  
  // Power-up - use same synth style as acid for consistency
  powerUp: new Tone.MonoSynth({
    oscillator: { type: "sawtooth" },
    envelope: { attack: 0.001, decay: 0.1, sustain: 0.1, release: 0.2 },
    filter: { frequency: 2000, rolloff: -12, Q: 3 },
    filterEnvelope: { attack: 0.001, decay: 0.2, sustain: 0.3, release: 0.2, baseFrequency: 400, octaves: 3 },
    volume: -10
  }).connect(acidFilter1) // Route through acid filter for consistency
};

// Helper to get notes in current scale
function getGameNote(index) {
  const scales = {
    minor: ["C", "D", "Eb", "F", "G", "Ab", "Bb"],
    dorian: ["C", "D", "Eb", "F", "G", "A", "Bb"],
    phrygian: ["C", "Db", "Eb", "F", "G", "Ab", "Bb"]
  };
  const scale = scales.minor; // Default to minor
  return scale[index % scale.length];
}

// Check if mobile device
const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || 
                 ('ontouchstart' in window) || 
                 (navigator.maxTouchPoints > 0);

// Initialize grid setting from saved data
let gridEnabled = savedData.settings?.gridEnabled !== undefined ? savedData.settings.gridEnabled : true;

// Apply mobile class to body for CSS styling
if (isMobile) {
  document.body.classList.add('mobile');
  
  // Initialize touch sensitivity selector (deferred until DOM is ready)
  window.addEventListener('DOMContentLoaded', () => {
    const touchSensitivityRow = document.getElementById('touchSensitivityRow');
    if (touchSensitivityRow) {
      touchSensitivityRow.style.display = 'flex';
      
      // Map slider positions to actual pixel values
      const deadzoneValues = [17, 25, 30, 35, 40, 48];
      const deadzoneLabels = ['Tight', 'Snappy', 'Normal', 'Relaxed', 'Loose', 'Lazy'];
      
      // Load saved sensitivity and convert to slider index
      const savedPixels = savedData.settings?.touchSensitivity || 30;
      let savedIndex = deadzoneValues.indexOf(savedPixels);
      if (savedIndex === -1) savedIndex = 2; // Default to Normal (30px)
      
      const touchSlider = document.getElementById('touchSensitivitySlider');
      const touchDisplay = document.getElementById('touchSensitivityDisplay');
      
      if (touchSlider && touchDisplay) {
        touchSlider.value = savedIndex;
        
        // Set up display with fixed width to prevent jitter
        touchDisplay.style.width = '60px';
        touchDisplay.style.textAlign = 'center';
        touchDisplay.style.display = 'inline-block';
        
        // Show text label based on slider index
        const updateSensitivityDisplay = (index) => {
          touchDisplay.textContent = deadzoneLabels[index] || 'Normal';
        };
        
        updateSensitivityDisplay(savedIndex);
        
        // Handle both input (while sliding) and change (on release) events
        const updateTouchSensitivity = (e) => {
          const index = parseInt(e.target.value);
          const newDeadzone = deadzoneValues[index];
          
          // Update the game's deadzone if a game scene is active
          if (window.currentGameScene) {
            window.currentGameScene.zoneDeadRadius = newDeadzone;
          }
          // Update display with text label
          updateSensitivityDisplay(index);
        };
        
        touchSlider.addEventListener('input', updateTouchSensitivity);
        touchSlider.addEventListener('change', (e) => {
          updateTouchSensitivity(e);
          // Save actual pixel value
          const pixels = deadzoneValues[parseInt(e.target.value)];
          saveGameDataDebounced({ settings: { touchSensitivity: pixels } });
        });
      }
    }
  });
}

// Initialize game dimensions - use visualViewport for accurate mobile sizing
let WIDTH = window.visualViewport ? window.visualViewport.width : window.innerWidth;
let HEIGHT = window.visualViewport ? window.visualViewport.height : window.innerHeight;
const LANES = 5;
let LANE_W = WIDTH/LANES;

// Storage management section has been moved to the beginning of the script

// Settings are now applied where each variable is defined
// Game dimensions initialized based on viewport - adjust for mobile
let PLAYER_Y = HEIGHT - (isMobile ? 90 : 60); // More space from bottom on mobile
const ENEMY_SPEED_BASE = isMobile ? 150 : 200; // Slower on mobile for easier play
const BULLET_SPEED = 520;
const FIRE_COOLDOWN = 110;
const HORIZONTAL_SHOOTING = true; // Enable horizontal shooting across lanes

// Arc shot tuning parameters
const ARC_SHOT_BASE_SAFE_DISTANCE = 0.4; // Base 40% of path immune to obstacles
const ARC_SHOT_HEIGHT_BONUS = 0.3; // Additional 30% max based on jump height
const ARC_SHOT_MAX_JUMP_HEIGHT = 360; // Reference for calculating height percentage
// Smart scaling based on device and orientation
let isLandscape = window.innerWidth > window.innerHeight;
let MOBILE_SCALE = isMobile ? (isLandscape ? 1.2 : 1.5) : 1; // Smaller scale in landscape

// PLAYER ANIMATION & CONTROL CONFIG
// Critical: These timings affect gameplay - isMoving blocks shooting/collision during animations
const PLAYER_CONFIG = {
  // Ground movement animations (jello stretch effect)
  movement: {
    ground: {
      // Phase 1: Anticipation stretch
      stretch: {
        scaleX: 1.8,      // Horizontal stretch factor
        scaleY: 0.5,      // Vertical compression
        duration: 60      // ms - CRITICAL: affects responsiveness
      },
      // Phase 2: Slingshot to position
      slingshot: {
        overshoot: 15,    // Pixels past target
        scaleX: 0.6,      // Squash on arrival
        scaleY: 1.5,      // Stretch vertically
        duration: 80      // ms - CRITICAL: main movement time
      },
      // Phase 3: Bounce back
      bounce: {
        offset: 8,        // Pixels to bounce back
        scaleX: 1.2,
        scaleY: 0.85,
        duration: 80      // ms
      },
      // Phase 4: Settle with wobble
      settle: {
        duration: 200,    // ms - CRITICAL: total time before can move again
        elasticity: [0.4, 0.3]  // Elastic.easeOut params for wobbles
      },
      // Wobble physics
      wobble: {
        damping: 0.92,    // How quickly wobble settles
        reactiveForce: 12 // Force applied opposite to movement
      }
    },
    // Air movement (during jump)
    air: {
      duration: 200,      // ms - faster than ground movement
      barrelRoll: {
        angle: 360,       // Degrees of rotation
        duration: 300     // ms - overlaps with movement
      },
      scalePulse: {
        x: 1.5,
        y: 0.7,
        duration: 100     // ms
      }
    }
  },
  
  // Jump animations
  jump: {
    regular: {
      height: 120,        // Pixels above PLAYER_Y
      duration: 250,      // ms - up phase (total is 2x with yoyo)
      scaleX: 1.2,
      scaleY: 1.2,
      spinAngle: 360,     // Forward flip
      spinDuration: 500   // ms - matches total jump time
    },
    // Super jump (charge mechanic)
    super: {
      chargeTime: 1000,   // ms - max charge duration
      minHeight: 120,     // Minimum jump height (no charge)
      maxHeight: 360,     // Maximum jump height (full charge)
      // Charge animation
      crouch: {
        scaleX: 1.4,
        scaleY: 0.6,
        duration: 100     // ms to enter crouch
      },
      // Launch preparation
      prelaunch: {
        scaleX: 1.6,
        scaleY: 0.3,
        duration: 150     // ms before launch
      },
      // Variable based on charge
      jumpDurationBase: 300,     // ms - base duration
      jumpDurationPerCharge: 200, // ms - added per charge percent
      // Landing sequence
      landing: {
        squashX: 2,
        squashY: 0.3,
        bounceHeight: 20,
        bounceDuration: 100,
        settleDuration: 400,
        elasticParams: [0.2, 0.15]
      }
    }
  },
  
  // Dash mechanics
  dash: {
    doubleTapWindow: 250,  // ms - window for double-tap detection
    duration: 60,           // ms - same as stretch phase for consistency
    trailCount: 2,          // Number of trail images
    trailAlpha: [0.5, 0.3], // Alpha for each trail
    trailFadeDuration: 200  // ms
  },
  
  // Collision detection
  collision: {
    yThreshold: 40          // Pixels - how close obstacles need to be to player Y to trigger collision
  },
  
  // Off-screen mechanics
  offScreen: {
    gracePeriod: 800,       // ms before rubber band kicks in
    warningThreshold: 300,  // ms - when to show red warning
    alpha: 0.7,             // Transparency when off-screen
    snapBack: {
      duration: 300,        // ms for rubber band animation
      stretchX: 1.5,
      stretchY: 0.7,
      spinAngle: 360,
      settleDuration: 200
    }
  },
  
  // Idle animations (jello physics)
  idle: {
    wobble: {
      breathSpeed: 0.003,   // Phase increment per ms
      breathScale: 0.03,    // Max scale change
      squishScale: 0.02,    // Secondary frequency scale
      randomImpulse: {
        chance: 0.02,       // Per frame chance
        force: 2            // Random force strength
      }
    }
  },
  
  // Reaction animations (collecting power-ups, etc)
  reactions: {
    powerUp: {
      wobbleX: 20,          // Random X force range
      wobbleY: -15,         // Upward force
      bounceCount: 2,
      bounceScaleX: 1.4,
      bounceScaleY: 0.7,
      bounceDuration: 100,
      settleDuration: 200
    },
    recoil: {               // When firing
      wobbleY: 3,
      scaleX: 0.9,
      scaleY: 1.1,
      duration: 50
    }
  }
};

// Startup screen scene
class StartupScene extends Phaser.Scene {
  constructor() {
    super({ key: 'StartupScene' });
  }
  
  create() {
    // Use global WIDTH and HEIGHT which are updated on resize
    // Ensure they're current
    WIDTH = this.cameras.main.width;
    HEIGHT = this.cameras.main.height;
    
    // Register resize handler with proper binding
    this.scale.on('resize', this.resize, this);
    
    
    // Black background
    this.cameras.main.setBackgroundColor('#000');
    
    // Create grid effect in background
    this.gridGraphics = this.add.graphics();
    this.drawGrid();
    
    // Animated scan line effect
    this.scanline = this.add.rectangle(0, 0, WIDTH, 3, 0x00ff00, 0.5);
    this.scanlineTween = this.tweens.add({
      targets: this.scanline,
      y: HEIGHT,
      duration: 3000,
      repeat: -1,
      ease: 'Linear'
    });
    
    // Title with glow effect
    const titleStyle = {
      font: 'bold 72px monospace',
      fill: '#00ffcc',
      stroke: '#00ffcc',
      strokeThickness: 2,
      shadow: {
        offsetX: 0,
        offsetY: 0,
        color: '#00ffcc',
        blur: 20,
        fill: true
      }
    };
    
    this.title = this.add.text(WIDTH/2, HEIGHT/3, 'BEATRIDER', titleStyle);
    this.title.setOrigin(0.5);
    
    // Pulsing glow animation for title
    this.tweens.add({
      targets: this.title,
      scaleX: 1.05,
      scaleY: 1.05,
      duration: 1000,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });
    
    // Subtitle with typewriter effect
    const subtitleText = 'ENDLESS BEAT SURVIVOR';
    this.subtitle = this.add.text(WIDTH/2, HEIGHT/3 + 80, '', {
      font: '24px monospace',
      fill: '#ff00ff',
      stroke: '#ff00ff',
      strokeThickness: 1
    });
    this.subtitle.setOrigin(0.5);
    
    // Typewriter effect
    let charIndex = 0;
    this.time.addEvent({
      delay: 100,
      callback: () => {
        if(charIndex < subtitleText.length) {
          this.subtitle.text += subtitleText[charIndex];
          charIndex++;
        }
      },
      repeat: subtitleText.length - 1
    });
    
    // Instructions - different for mobile vs desktop
    const instructions = isMobile ? [
      'DRAG LEFT/RIGHT - MOVE',
      'DRAG UP - JUMP', 
      'DRAG DOWN THEN RELEASE - SUPER JUMP',
      'HOLD SCREEN - AUTO FIRE'
    ] : [
      'ARROWS/A/D - MOVE',
      'W/UP - JUMP',
      'SPACE - FIRE',
      'G - TOGGLE GRID'
    ];
    
    this.instructions = [];
    instructions.forEach((text, index) => {
      const instruction = this.add.text(WIDTH/2, HEIGHT/2 + 40 + index * 30, text, {
        font: '18px monospace',
        fill: '#00ff00'
      });
      instruction.setOrigin(0.5);
      instruction.setAlpha(0);
      this.instructions.push(instruction);
      
      // Fade in with delay
      this.tweens.add({
        targets: instruction,
        alpha: 1,
        delay: 1500 + index * 200,
        duration: 500
      });
    });
    
    // Check if tutorial has been completed
    const tutorialCompleted = localStorage.getItem('beatrider_tutorial_completed') === 'true';
    
    // Press start message - different for mobile
    const startMessage = isMobile ? 'TAP TO START' : 'PRESS SPACE TO START';
    const startY = (WIDTH > HEIGHT) ? HEIGHT - 100 : HEIGHT - 150; // Move up more for tutorial button
    this.startText = this.add.text(WIDTH/2, startY, startMessage, {
      font: 'bold 28px monospace',
      fill: '#ffff00',
      stroke: '#ffff00',
      strokeThickness: 1
    });
    this.startText.setOrigin(0.5);
    
    // Blinking effect
    this.tweens.add({
      targets: this.startText,
      alpha: 0,
      duration: 500,
      yoyo: true,
      repeat: -1
    });
    
    // Tutorial button - place it above the start text, not below
    const tutorialY = startY - 50;  // Above the start text
    const tutorialMessage = tutorialCompleted ? '[REPLAY TUTORIAL]' : '[TUTORIAL MODE]';
    this.tutorialText = this.add.text(WIDTH/2, tutorialY, tutorialMessage, {
      font: '18px monospace',  // Slightly smaller
      fill: '#00ff00',
      stroke: '#00ff00',
      strokeThickness: 1
    });
    this.tutorialText.setOrigin(0.5);
    // Make the tutorial text interactive with a larger hit area
    this.tutorialText.setInteractive({ useHandCursor: true });
    this.tutorialText.setDepth(1000); // Ensure it's on top
    
    // Hover effect for tutorial button
    this.tutorialText.on('pointerover', () => {
      this.tutorialText.setScale(1.1);
      this.tutorialText.setFill('#ffffff');
    });
    
    this.tutorialText.on('pointerout', () => {
      this.tutorialText.setScale(1.0);
      this.tutorialText.setFill('#00ff00');
    });
    
    // Subtle pulsing for tutorial button if not completed
    if (!tutorialCompleted) {
      this.tweens.add({
        targets: this.tutorialText,
        alpha: 0.6,
        duration: 800,
        yoyo: true,
        repeat: -1
      });
    }
    
    // Retro computer boot sequence text
    const bootLines = [
      'INITIALIZING BEAT DETECTION SYSTEM...',
      'LOADING MELODIC ALGORITHMS...',
      'CALIBRATING PERSPECTIVE MATRIX...',
      'SYNTHESIZERS ONLINE',
      'SYSTEM READY'
    ];
    
    this.bootTexts = [];
    const bootY = 60;
    bootLines.forEach((line, index) => {
      this.time.delayedCall(index * 300, () => {
        const bootText = this.add.text(40, bootY + index * 20, '> ' + line, {
          font: '14px monospace',
          fill: '#0f0'
        });
        
        // Type-in effect for boot text
        bootText.setAlpha(0);
        this.bootTexts.push(bootText);
        this.tweens.add({
          targets: bootText,
          alpha: 1,
          duration: 200
        });
        
        // Add a blinking cursor after the last line
        if(index === bootLines.length - 1) {
          const cursor = this.add.text(bootText.x + bootText.width + 5, bootText.y, '_', {
            font: '14px monospace',
            fill: '#0f0'
          });
          this.tweens.add({
            targets: cursor,
            alpha: 0,
            duration: 400,
            yoyo: true,
            repeat: -1
          });
        }
      });
    });
    
    // Floating particles in background
    this.particles = [];
    for(let i = 0; i < 30; i++) {
      const particle = this.add.circle(
        Math.random() * WIDTH,
        Math.random() * HEIGHT,
        Math.random() * 2 + 1,
        0x00ff00,
        Math.random() * 0.3 + 0.1
      );
      
      this.particles.push(particle);
      
      this.tweens.add({
        targets: particle,
        y: particle.y - HEIGHT - 100,
        duration: Math.random() * 10000 + 10000,
        repeat: -1,
        delay: Math.random() * 5000
      });
    }
    
    // Start handler function
    const startGame = async (tutorialMode = false) => {
      // Start Tone.js from user gesture
      if (typeof Tone !== 'undefined') {
        await Tone.start();
      }
      
      // Transition to game with optional tutorial mode
      this.cameras.main.fadeOut(500, 0, 0, 0);
      this.time.delayedCall(500, () => {
        this.scene.start('Main', { tutorialMode: tutorialMode });
      });
    };
    
    // Start normal game handler (or tutorial if never completed)
    const startNormalGame = async () => {
      // Default to tutorial for first-time players
      const shouldPlayTutorial = !tutorialCompleted;
      await startGame(shouldPlayTutorial);
    };
    
    // Tutorial button handler - always starts tutorial
    this.tutorialText.on('pointerdown', async (pointer) => {
      pointer.event.stopPropagation(); // Stop this click from triggering other handlers
      await startGame(true);
    });
    
    // Listen for space key to start normal game (or tutorial if first time)
    this.input.keyboard.once('keydown-SPACE', startNormalGame);
    
    // Touch/click handler that checks if tutorial was clicked
    const handleStartClick = async (pointer) => {
      // Check if click was on tutorial text
      const bounds = this.tutorialText.getBounds();
      if (bounds.contains(pointer.x, pointer.y)) {
        return; // Tutorial text will handle this
      }
      await startNormalGame();
    };
    
    // Touch/click to start - using pointerdown for better mobile support
    this.input.on('pointerdown', handleStartClick);
  }
  
  drawGrid() {
    this.gridGraphics.clear();
    this.gridGraphics.lineStyle(1, 0x00ff00, 0.1);
    
    // Vertical lines
    for(let x = 0; x < WIDTH; x += 40) {
      this.gridGraphics.lineBetween(x, 0, x, HEIGHT);
    }
    // Horizontal lines  
    for(let y = 0; y < HEIGHT; y += 40) {
      this.gridGraphics.lineBetween(0, y, WIDTH, y);
    }
  }
  
  resize(gameSize, baseSize, displaySize, resolution) {
    // Check if cameras exist before accessing
    if (!this.cameras || !this.cameras.main) {
      return;
    }
    
    // Update global dimensions using the actual camera dimensions
    WIDTH = this.cameras.main.width;
    HEIGHT = this.cameras.main.height;
    
    // Only update if we're the active scene
    if (this.scene.isActive()) {
      // Redraw grid with new dimensions
      if (this.gridGraphics) {
        this.drawGrid();
      }
      
      // Update scanline
      if (this.scanline) {
        this.scanline.width = WIDTH;
        // Reset scanline tween
        if (this.scanlineTween) {
          this.scanlineTween.remove();
        }
        this.scanlineTween = this.tweens.add({
          targets: this.scanline,
          y: HEIGHT,
          duration: 3000,
          repeat: -1,
          ease: 'Linear'
        });
      }
      
      // Update title position
      if (this.title) {
        this.title.x = WIDTH / 2;
        this.title.y = HEIGHT / 3;
      }
      
      // Update subtitle position
      if (this.subtitle) {
        this.subtitle.x = WIDTH / 2;
        this.subtitle.y = HEIGHT / 3 + 80;
      }
      
      // Update instructions positions
      if (this.instructions) {
        this.instructions.forEach((instruction, index) => {
          instruction.x = WIDTH / 2;
          instruction.y = HEIGHT / 2 + 40 + index * 30;
        });
      }
      
      // Update start text position
      if (this.startText) {
        this.startText.x = WIDTH / 2;
        const startY = (WIDTH > HEIGHT) ? HEIGHT - 50 : HEIGHT - 100; // Closer to bottom in landscape
        this.startText.y = startY;
      }
      
      // Update invisible button size
      if (this.invisibleButton) {
        this.invisibleButton.x = WIDTH / 2;
        this.invisibleButton.y = HEIGHT / 2;
        this.invisibleButton.width = WIDTH;
        this.invisibleButton.height = HEIGHT;
      }
      
      // Reposition particles
      if (this.particles) {
        this.particles.forEach(particle => {
          // Stop current tween and restart with new dimensions
          this.tweens.killTweensOf(particle);
          particle.x = Math.random() * WIDTH;
          particle.y = Math.random() * HEIGHT;
          
          this.tweens.add({
            targets: particle,
            y: particle.y - HEIGHT - 100,
            duration: Math.random() * 10000 + 10000,
            repeat: -1,
            delay: Math.random() * 5000
          });
        });
      }
    }
  }
}

// Pulse pattern definitions for grid movement
// Logic: In non-chaos modes, grid pulses follow predictable patterns that players can learn.
// Each musical section (INTRO, BUILD, MAIN, etc.) has a pattern intensity that matches its energy.
// Patterns are applied to the existing sub bass hits (2 per bar) rather than creating new timing.
// This creates a "dancing" grid that feels musical rather than random, while chaos mode stays unpredictable.
// Patterns cycle every 8 bars within a section for variety without being overwhelming.
// -1 = skip pulse, 0 = forward, 1 = left, 2 = right
const pulsePatternPool = {
  gentle: [
    [1, 2],           // left, right
    [2, 1],           // right, left  
    [-1, 1],          // skip, left
    [2, -1],          // right, skip
    [1, -1],          // left, skip
    [-1, 2]           // skip, right
  ],
  building: [
    [0, 1],           // forward, left
    [0, 2],           // forward, right
    [1, 0],           // left, forward
    [2, 0],           // right, forward
    [0, -1],          // forward, skip
    [1, 2]            // left, right
  ],
  intense: [
    [0, 1, 2, 1],     // forward, left, right, left
    [0, 2, 1, 2],     // forward, right, left, right
    [1, 0, 2, 0],     // left, forward, right, forward
    [2, 0, 1, 0],     // right, forward, left, forward
    [1, 2, 0, 1],     // left, right, forward, left
    [2, 1, 0, 2]      // right, left, forward, right
  ]
};

// Map sections to pattern types
const sectionPatternMap = {
  'INTRO': 'gentle',
  'BUILD': 'building', 
  'MAIN': 'intense',
  'BREAK': 'gentle',
  'DROP': 'intense',
  'OUTRO': 'gentle'
};

class Main extends Phaser.Scene {
  constructor() {
    super({ key: 'Main' });
    
    // Break section state
    this.isBreakSection = false;
    this.floatingStars = [];
  }
  updateSoundDisplay() {
    const soundNames = ['Triangle', 'Acid', 'Chord', 'Sub', 'Pluck', 'Pew Pew'];
    const display = document.getElementById('soundDisplay');
    if (display) {
      display.textContent = soundNames[gameSounds.currentLaserSound];
    }
  }
  
  createStarfield() {
    // Clean up existing starfield graphics if they exist
    if (this.starGraphics) {
      this.starGraphics.destroy();
    }
    
    // Create three layers of stars for parallax effect
    this.stars = [
      [], // Far stars (slow)
      [], // Medium stars
      []  // Near stars (fast)
    ];
    
    const starColors = [0x666666, 0x999999, 0xbbbbbb];
    const starCounts = [100, 50, 25];
    const starSizes = [1, 1.5, 2];
    
    this.starGraphics = this.add.graphics();
    
    // Generate random stars for each layer - they start at random positions along their path
    for(let layer = 0; layer < 3; layer++) {
      for(let i = 0; i < starCounts[layer]; i++) {
        this.stars[layer].push({
          // Stars spread across the whole screen area
          baseX: Math.random() * WIDTH * 2 - WIDTH/2, // Can be off-screen horizontally
          baseY: Math.random() * HEIGHT * 2 - HEIGHT, // Can go above and below screen
          progress: Math.random(), // Random starting position along path
          speed: (layer + 1) * 0.3, // Different speeds for parallax
          size: starSizes[layer],
          color: starColors[layer],
          twinkle: Math.random() * Math.PI * 2 // Random twinkle phase
        });
      }
    }
  }
  
  updateStarfield(dt) {
    if (!this.starGraphics) return; // Safety check
    this.starGraphics.clear();
    const vanishY = HEIGHT * 0.15;
    const vanishX = WIDTH / 2;
    
    // Update and draw each star layer
    for(let layer = 0; layer < 3; layer++) {
      for(let star of this.stars[layer]) {
        // Move stars along perspective (increase progress)
        star.progress += star.speed * (dt/1000);
        
        // Wrap around when star passes the player
        if(star.progress > 1.2) {
          star.progress = 0;
          star.baseX = Math.random() * WIDTH * 2 - WIDTH/2; // New random X spread
          star.baseY = Math.random() * HEIGHT * 2 - HEIGHT; // New random Y spread
        }
        
        // Calculate positions - stars follow same exponential curve as grid
        const curvedProgress = Math.pow(star.progress, 2.5); // Same curve as grid/objects
        const y = vanishY + (star.baseY - vanishY) * curvedProgress;
        const x = vanishX + (star.baseX - vanishX) * curvedProgress;
        
        // Skip stars that are off-screen
        if(x < -50 || x > WIDTH + 50) continue;
        
        // Scale based on distance (smaller when far)
        const size = star.size * (0.1 + star.progress * 1.5);
        
        // Add subtle twinkling and fade based on distance
        star.twinkle += dt * 0.003;
        const twinkleAlpha = 0.8 + Math.sin(star.twinkle) * 0.2;
        const distanceAlpha = Math.min(1, star.progress * 2); // Fade in as they approach
        const alpha = twinkleAlpha * distanceAlpha * 0.85;
        
        // Draw star
        this.starGraphics.fillStyle(star.color, alpha);
        this.starGraphics.fillCircle(x, y, size);
      }
    }
  }
  
  create(data){
    // Check if we're in tutorial mode
    this.isTutorial = data?.tutorialMode || false;
    this.tutorialWave = 0;
    this.tutorialText = null;
    this.tutorialProgress = {
      shotsHit: 0,
      movementsMade: 0,
      jumpsMade: 0,
      dashesMade: 0,
      starsCollected: 0
    };
    this.tutorialWaveStarted = false;
    
    // Initialize vanishing point
    this.vanishX = WIDTH / 2;
    this.vanishY = HEIGHT * 0.15;
    
    // Track session start time and metrics
    this.sessionStartTime = Date.now();
    this.maxComboReached = 0;
    
    // Initialize game timer for survival tracking
    this.gameStartTime = this.time.now;
    
    // Initialize adaptive difficulty system
    this.recentDeaths = [];
    this.adaptiveState = {
      isAssisting: false,
      assistStartTime: null,
      currentSpawnMultiplier: 1.0,
      currentSpeedMultiplier: 1.0
    };
    
    // Track game start
    trackEvent('game_start', {
      difficulty: currentDifficulty?.name || 'normal',
      genre: currentGenre || 'techno',
      grid_enabled: gridEnabled,
      high_score: sessionHighScore,
      tutorial_mode: this.isTutorial
    });
    
    // Initialize pause state
    this.isPaused = false;
    this.pauseOverlay = null;
    this.pauseText = null;
    this.wasAutoPaused = false; // Track if pause was triggered by visibility change
    this.pauseScoreText = null;
    this.pauseHighScoreText = null;
    
    // Initialize death/invincibility state
    this.isShowingGameOver = false;
    this.isInvincible = false;
    this.playerCanControl = true;
    
    // Store reference for external access
    window.gameScene = this;
    window.currentGameScene = this; // For touch sensitivity settings
    
    // Set up visibility change listener for auto-pause when tab/app goes to background
    if (!this.visibilityHandler) {
      this.visibilityHandler = () => {
        // Check if document is hidden (tab switched or app went to background)
        if (document.hidden) {
          // Auto-pause if game is active and not already paused
          if (!this.isPaused && !this.isShowingGameOver) {
            this.pauseGame();
            this.wasAutoPaused = true; // Track that this was an auto-pause
          }
        } else {
          // When coming back to foreground, don't auto-resume
          // The user will see the pause screen and can resume manually
          if (this.wasAutoPaused) {
            this.wasAutoPaused = false;
            // Ensure pause screen is visible
            if (this.isPaused && this.pauseOverlay) {
              this.pauseOverlay.setVisible(true);
              this.pauseText.setVisible(true);
            }
          }
        }
      };
      
      document.addEventListener('visibilitychange', this.visibilityHandler);
      
      // Clean up the event listener when scene shuts down
      this.events.once('shutdown', () => {
        if (this.visibilityHandler) {
          document.removeEventListener('visibilitychange', this.visibilityHandler);
        }
      });
    }
    
    // Scene is already created, no need to wait for ready event
    
    this.cameras.main.setBackgroundColor('#000');
    
    // Create starfield background FIRST
    this.createStarfield();
    
    // Tutorial mode setup
    if (this.isTutorial) {
      // Slow down the tempo for tutorial
      Tone.Transport.bpm.value = 90; // 75% of normal 120 BPM
      
      // Create tutorial text overlay
      this.tutorialText = this.add.text(WIDTH/2, 100, '', {
        font: 'bold 24px monospace',
        fill: '#ffff00',
        stroke: '#000000',
        strokeThickness: 4,
        align: 'center'
      }).setOrigin(0.5).setDepth(1000);
      
      // Tutorial progress text
      this.tutorialProgressText = this.add.text(WIDTH/2, 140, '', {
        font: '18px monospace',
        fill: '#00ff00',
        stroke: '#000000',
        strokeThickness: 3,
        align: 'center'
      }).setOrigin(0.5).setDepth(1000);
      
      // Skip tutorial button in upper right
      this.skipTutorialButton = this.add.text(WIDTH - 20, 20, '[SKIP >>]', {
        font: '20px monospace',
        fill: '#ffffff',
        stroke: '#000000',
        strokeThickness: 3,
        align: 'right'
      }).setOrigin(1, 0).setDepth(1001);
      
      // Make skip button interactive
      this.skipTutorialButton.setInteractive({ useHandCursor: true });
      
      // Hover effects
      this.skipTutorialButton.on('pointerover', () => {
        this.skipTutorialButton.setScale(1.1);
        this.skipTutorialButton.setFill('#ffff00');
      });
      
      this.skipTutorialButton.on('pointerout', () => {
        this.skipTutorialButton.setScale(1.0);
        this.skipTutorialButton.setFill('#ffffff');
      });
      
      // Click to skip tutorial
      this.skipTutorialButton.on('pointerdown', () => {
        this.skipTutorial();
      });
    }
    
    // Start the music automatically when game starts
    if (typeof Tone !== 'undefined' && Tone.Transport.state !== 'started') {
      // Tone should already be started from the startup screen
      currentBar = 0;
      window.currentBar = 0;
      currentChordIndex = 0;
      lastSection = '';
      updatePatterns();
      Tone.Transport.start();
      if (document.getElementById('status')) {
        document.getElementById('status').textContent = 'PLAYING';
      }
      uiState.isPlaying = true;
      updatePlayPauseButton();
    }
    
    // Initialize trail system
    this.trails = [];
    this.trailGraphics = this.add.graphics();
    
    const gfx=this.make.graphics({x:0,y:0,add:false});
    
    // Calculate sizes based on screen dimensions
    // Use smaller dimension as reference for consistent scaling
    const screenReference = Math.min(WIDTH, HEIGHT);
    const screenScale = screenReference / 800; // 800px as reference size
    
    // Base sizes scale with screen, with mobile getting a slight boost
    const mobileBoost = isMobile ? 1.2 : 1.0;
    const basePlayerSize = Math.floor(36 * screenScale * mobileBoost);
    const baseEnemySize = Math.floor(32 * screenScale * mobileBoost);
    const baseBulletW = Math.floor(8 * screenScale * mobileBoost);
    const baseBulletH = Math.floor(16 * screenScale * mobileBoost);
    const baseObstacleW = Math.floor(80 * screenScale * mobileBoost);
    const baseObstacleH = Math.floor(22 * screenScale * mobileBoost);
    const basePowerUpSize = Math.floor(28 * screenScale * mobileBoost);
    
    const playerSize = Math.floor(basePlayerSize * MOBILE_SCALE);
    const enemySize = Math.floor(baseEnemySize * MOBILE_SCALE);
    const bulletW = Math.floor(baseBulletW * MOBILE_SCALE);
    const bulletH = Math.floor(baseBulletH * MOBILE_SCALE);
    const obstacleW = Math.floor(baseObstacleW * MOBILE_SCALE);
    const obstacleH = Math.floor(baseObstacleH * MOBILE_SCALE);
    const powerUpSize = Math.floor(basePowerUpSize * MOBILE_SCALE);
    
    // Store sizes for use in spawn functions
    this.enemyBaseSize = enemySize;
    this.fastEnemyBaseSize = Math.floor(enemySize * 1.25); // Fast enemies 25% larger
    
    gfx.fillStyle(0x00ffcc,1).fillRect(0,0,playerSize,playerSize).generateTexture('playerTex',playerSize,playerSize).clear();
    gfx.fillStyle(0xff3366,1).fillRect(0,0,enemySize,enemySize).generateTexture('enemyTex',enemySize,enemySize).clear();
    gfx.fillStyle(0xffff00,1).fillTriangle(enemySize/2,0,0,enemySize,enemySize,enemySize).generateTexture('fastEnemyTex',enemySize,enemySize).clear();
    gfx.fillStyle(0xffffff,1).fillRect(0,0,bulletW,bulletH).generateTexture('bulletTex',bulletW,bulletH).clear();
    // Energy shield with poles - all in one texture
    const poleWidth = Math.floor(obstacleW * 0.15); // Poles are 15% of total width
    const shieldGap = 2; // Small gap between pole and shield
    
    // Dark purple poles on the sides
    gfx.fillStyle(0xbf40ff, 1); // Solid dark purple
    gfx.fillRect(0, 0, poleWidth, obstacleH); // Left pole
    gfx.fillRect(obstacleW - poleWidth, 0, poleWidth, obstacleH); // Right pole
    
    // Energy shield barrier in between - lighter and translucent
    const shieldX = poleWidth + shieldGap;
    const shieldWidth = obstacleW - (poleWidth * 2) - (shieldGap * 2);
    
    // Multi-layer shield effect for depth
    gfx.fillStyle(0xff99ff, 0.15); // Outermost glow
    gfx.fillRect(shieldX - 2, 0, shieldWidth + 4, obstacleH);
    
    gfx.fillStyle(0xffccff, 0.25); // Middle layer
    gfx.fillRect(shieldX, 2, shieldWidth, obstacleH - 4);
    
    gfx.fillStyle(0xffd4ff, 0.4); // Inner bright core
    gfx.fillRect(shieldX + 2, 4, shieldWidth - 4, obstacleH - 8);
    
    // Add some vertical energy lines for texture
    gfx.lineStyle(1, 0xffffff, 0.2);
    for(let i = 0; i < 3; i++) {
      const lineX = shieldX + shieldGap + (shieldWidth / 4) * (i + 1);
      gfx.lineBetween(lineX, 2, lineX, obstacleH - 2);
    }
    
    gfx.generateTexture('obstacleTex',obstacleW,obstacleH).clear();
    gfx.fillStyle(0x00ff00,1).fillCircle(powerUpSize/2,powerUpSize/2,powerUpSize/2).generateTexture('powerUpTex',powerUpSize,powerUpSize).clear(); // Green power-up
    
    // Create star texture for break section collectibles
    const starSize = Math.floor(40 * MOBILE_SCALE);
    const spikes = 5;
    const outerRadius = starSize / 2;
    const innerRadius = outerRadius * 0.4;
    
    gfx.fillStyle(0xffdd00, 1); // Golden yellow
    gfx.beginPath();
    
    for(let i = 0; i < spikes * 2; i++) {
      const angle = (Math.PI * 2 * i) / (spikes * 2) - Math.PI / 2;
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      const x = starSize/2 + Math.cos(angle) * radius;
      const y = starSize/2 + Math.sin(angle) * radius;
      
      if(i === 0) {
        gfx.moveTo(x, y);
      } else {
        gfx.lineTo(x, y);
      }
    }
    
    gfx.closePath();
    gfx.fillPath();
    gfx.generateTexture('starTex', starSize, starSize).clear();
    // Create diamond-shaped drifter
    const halfSize = enemySize / 2;
    gfx.fillStyle(0xff00ff, 1);
    gfx.beginPath();
    gfx.moveTo(halfSize, 2); // Top point
    gfx.lineTo(enemySize - 2, halfSize); // Right point
    gfx.lineTo(halfSize, enemySize - 2); // Bottom point
    gfx.lineTo(2, halfSize); // Left point
    gfx.closePath();
    gfx.fillPath();
    gfx.generateTexture('drifterTex',enemySize,enemySize).destroy(); // Diamond drifter

    this.playerLane=2; 
    this.player=this.add.image(this._laneX(this.playerLane), PLAYER_Y, 'playerTex');
    this.player.w = playerSize; // Add collision dimensions (scaled)
    this.player.h = playerSize;
    this.player.setDepth(500); // Much higher depth to ensure on top
    
    // Create charge glow effect
    this.chargeGlow = this.add.graphics();
    this.chargeGlow.setDepth(-1); // Behind player
    this.chargeGlow.setVisible(false);
    this.enemies=[]; 
    this.bullets=[]; 
    this.obstacles = [];
    this.powerUps = [];
    this.lastShotAt=0;
    this.rapidFire = false;
    this.rapidFireTimer = 0;
    this.offScreenTimer = 0; // Timer for rubber band effect
    this.offScreenShotCount = 0; // Track shots fired while off-screen
    this.offScreenTurnDelay = 0; // Delay before can fire when off-screen
    this.isMoving = false; // Prevent shooting while transitioning
    this.isStretching = false; // Track stretch phase for collision immunity
    this.isJumping = false; // Track jump state
    this.isCrouching = false; // Track crouch state for super jump
    this.crouchTimer = 0; // Timer for crouch charge
    this.maxChargeTime = 1000; // Max charge time in ms for full power
    this.releaseGraceTime = 150; // Grace period after releasing down to still trigger super jump
    this.queuedSuperJumpCharge = 0; // Queue super jump charge when jumping
    this.keyboardJumpQueuedWhileAirborne = false; // Track if keyboard jump queued while airborne
    this.queuedCrouchOnLanding = false; // Track if crouch was queued while airborne
    this.usingTimeBasedCharge = false; // Whether using time-based charge (for queued touch)
    this.touchChargeStartTime = 0; // When time-based charge started
    
    // Jello physics for idle animation
    this.idleWobblePhase = 0; // For idle breathing animation
    this.wobbleVelocity = { x: 0, y: 0 }; // For reactive wobble
    this.wobbleDamping = 0.92; // How quickly wobble settles
    
    // Dash mechanics
    this.isDashing = false;
    this.lastLeftPress = 0;
    this.lastRightPress = 0;
    this.doubleTapWindow = PLAYER_CONFIG.dash.doubleTapWindow; // ms window for double-tap
    this.keys=this.input.keyboard.addKeys('LEFT,RIGHT,UP,DOWN,A,D,W,S,SPACE,G,ONE,TWO,THREE,FOUR,FIVE,SIX,ESC');
    this.score=0; 
    this.beats=0;
    // Combo system variables
    this.combo = 1;
    this.comboTimer = 0;
    this.lastKillTime = 0;
    this.maxCombo = 8; // Maximum combo multiplier
    this.comboWindow = 2000; // 2 seconds to maintain combo
    
    const scoreFontSize = isMobile ? '24px' : '16px';
    const gridFontSize = isMobile ? '18px' : '12px';
    const scoreY = isMobile ? HEIGHT-36 : HEIGHT-24;
    const highScoreY = isMobile ? HEIGHT-72 : HEIGHT-48;
    const comboY = isMobile ? HEIGHT-108 : HEIGHT-72;
    
    // Create score labels and values separately for alignment
    const labelOffset = 10;
    const valueOffset = 80; // Position for right-aligned numbers - reduced to prevent overlap
    
    // High score (on top)
    this.highScoreLabel = this.add.text(labelOffset, highScoreY, 'high', {font:`${scoreFontSize} monospace`, fill:'#ff0'});
    this.highScoreText = this.add.text(valueOffset, highScoreY, sessionHighScore.toString(), {font:`${scoreFontSize} monospace`, fill:'#ff0'});
    this.highScoreText.setOrigin(0, 0); // Left align the number after the label
    
    // Current score (below)
    this.scoreLabel = this.add.text(labelOffset, scoreY, 'score', {font:`${scoreFontSize} monospace`, fill:'#0f0'});
    this.scoreText = this.add.text(valueOffset, scoreY, '0', {font:`${scoreFontSize} monospace`, fill:'#0f0'});
    this.scoreText.setOrigin(0, 0); // Left align the number after the label
    // Combo display
    this.comboText=this.add.text(10, comboY, '', {font:`${scoreFontSize} monospace`, fill:'#ff00ff'});
    this.comboText.setAlpha(0);
    
    // Combo meter bar
    const meterY = comboY + 30;
    this.comboMeterBg = this.add.graphics();
    this.comboMeterBg.fillStyle(0x333333, 0.5);
    this.comboMeterBg.fillRect(10, meterY, 200, 8);
    this.comboMeterBg.setVisible(false);
    
    this.comboMeter = this.add.graphics();
    this.comboMeterY = meterY;
    
    this.gridVisible = gridEnabled; // Use persistent grid setting
    
    // Sync initial grid UI state
    uiState.gridVisible = gridEnabled;
    updateGridButton();

    // Mobile controls setup
    this.setupMobileControls();

    // GameAPI is triggered by our drums
    window.GameAPI = {
      onBeat: ()=>{ 
        this.beats++;
        
        // Tutorial mode custom spawning
        if (this.isTutorial) {
          this.handleTutorialSpawn();
          // For wave 7 (full game), also continue with normal spawning
          if (this.tutorialWave < 7) {
            return;
          }
        }
        
        // Apply adaptive difficulty spawn chance
        if (this.adaptiveState.isAssisting) {
          if (Math.random() > this.adaptiveState.currentSpawnMultiplier) {
            // Skip this spawn due to adaptive assistance
            return;
          }
        }
        
        // Apply adaptive difficulty speed multiplier
        const baseSpeed = (ENEMY_SPEED_BASE + Math.floor(this.beats/16)*30) * currentDifficulty.speedMult;
        const speed = baseSpeed * this.adaptiveState.currentSpeedMultiplier;
        
        // Always spawn on kick (if not skipped by adaptive difficulty)
        const lane = Phaser.Math.Between(0,LANES-1);
        this._spawnEnemy(lane, speed, 'enemyTex'); 
        
        // Pulse all existing red enemies
        for(let enemy of this.enemies) {
          if(enemy.enemyType === 'enemyTex') {
            enemy.pulseTime = this.time.now;
          }
        }
      },
      onSnare: ()=>{ 
        // Skip all tutorial waves except final practice (wave 7)
        if (this.isTutorial && this.tutorialWave < 7) return;
        
        // Apply adaptive difficulty spawn chance
        if (this.adaptiveState.isAssisting) {
          if (Math.random() > this.adaptiveState.currentSpawnMultiplier) {
            // Skip this spawn due to adaptive assistance
            return;
          }
        }
        
        // Fast yellow enemies on snare hits - apply adaptive speed
        const baseSpeed = (ENEMY_SPEED_BASE * 1.5 + Math.floor(this.beats/16)*30) * currentDifficulty.speedMult;
        const speed = baseSpeed * this.adaptiveState.currentSpeedMultiplier;
        const lane = Phaser.Math.Between(0,LANES-1);
        this._spawnEnemy(lane, speed, 'fastEnemyTex'); 
        
        // Pulse all existing yellow enemies
        for(let enemy of this.enemies) {
          if(enemy.enemyType === 'fastEnemyTex') {
            enemy.pulseTime = this.time.now;
          }
        }
      },
      onHihat: ()=>{
        // Skip all tutorial waves except final practice (wave 7)
        if (this.isTutorial && this.tutorialWave < 7) return;
        
        // Apply adaptive difficulty spawn chance for obstacles (lower reduction)
        if (this.adaptiveState.isAssisting) {
          // Obstacles get 70% of their normal reduction (so 20% * 0.7 = 14% chance)
          if (Math.random() > this.adaptiveState.currentSpawnMultiplier) {
            // Skip this spawn due to adaptive assistance
            return;
          }
        }
        
        // Spawn obstacles that block shots
        const lane = Phaser.Math.Between(0,LANES-1);
        this._spawnObstacle(lane);
        
        // Pulse all existing obstacles with electric effect
        for(let obstacle of this.obstacles) {
          obstacle.pulseTime = this.time.now;
        }
      },
      onAcid: ()=>{
        // Skip during tutorial
        if (this.isTutorial && this.tutorialWave < 5) return;
        
        // Spawn power-up for rapid fire
        const lane = Phaser.Math.Between(0,LANES-1);
        this._spawnPowerUp(lane);
      },
      onStab: ()=>{
        // Skip during tutorial
        if (this.isTutorial) return;
        
        // Spawn lane-changing enemy
        const lane = Phaser.Math.Between(0,LANES-1);
        this._spawnDrifter(lane);
        
        // Pulse all existing purple drifting enemies
        for(let enemy of this.enemies) {
          if(enemy.isDrifter) {
            enemy.pulseTime = this.time.now;
          }
        }
      },
      onSub: ()=>{
        // Always pulse the grid for visual effect
        this._pulseGrid();
        
        // Skip break section logic during tutorial
        if (this.isTutorial) return;
        
        // Track if we're in break section for star spawning
        const section = getSection(window.currentBar || 0);
        this.isBreakSection = (section === 'BREAK');
      },
      toggleGrid: ()=>{ 
        // Toggle grid from external button - match G key behavior
        this.gridVisible = !this.gridVisible;
        gridEnabled = this.gridVisible;
        saveGameData({ settings: { gridEnabled: gridEnabled } });
        
        // Track grid toggle
        trackEvent('settings_change', {
          setting_type: 'grid',
          grid_enabled: gridEnabled
        });
        
        if (this.gridText) {
          const gridTextContent = isMobile ? 'GRID: ' + (this.gridVisible ? 'ON' : 'OFF') : 'GRID: ' + (this.gridVisible ? 'ON' : 'OFF') + ' [G]';
          this.gridText.setText(gridTextContent);
        }
        // Immediately clear graphics when hiding, just like G key does
        if(!this.gridVisible && this.gridGraphics) {
          this.gridGraphics.clear();
        } else if(this.gridVisible && this.isPaused) {
          // When paused and turning grid on, we need to draw it manually
          this._drawPerspectiveGrid();
        }
        // Update button visual state
        uiState.gridVisible = this.gridVisible;
        updateGridButton();
      },
      reset: ()=>{ this.scene.restart(); }
    };
  }

  updateZoneVisuals() {
    if (!this.zoneVisuals) return;
    
    this.zoneVisuals.clear();
    
    // Draw dead zone circle (center)
    this.zoneVisuals.lineStyle(2, 0x00aaff, 0.4);
    this.zoneVisuals.fillStyle(0x00aaff, 0.1);
    this.zoneVisuals.fillCircle(this.touchStartX, this.touchStartY, this.zoneDeadRadius);
    this.zoneVisuals.strokeCircle(this.touchStartX, this.touchStartY, this.zoneDeadRadius);
    
    // Draw outer radius circle
    this.zoneVisuals.lineStyle(1, 0xffffff, 0.2);
    this.zoneVisuals.strokeCircle(this.touchStartX, this.touchStartY, this.zoneRadius);
    
    // Draw zone boundary lines based on actual angles
    const cx = this.touchStartX;
    const cy = this.touchStartY;
    const r = this.zoneRadius;
    
    // Convert angles to radians and draw boundary lines
    const angle60 = 60 * Math.PI / 180;
    const angle120 = 120 * Math.PI / 180;
    
    this.zoneVisuals.lineStyle(1, 0xffffff, 0.3);
    // Right zone boundaries (±60°)
    this.zoneVisuals.lineBetween(cx, cy, cx + r * Math.cos(-angle60), cy + r * Math.sin(-angle60));
    this.zoneVisuals.lineBetween(cx, cy, cx + r * Math.cos(angle60), cy + r * Math.sin(angle60));
    
    // Left zone boundaries (±120°)
    this.zoneVisuals.lineBetween(cx, cy, cx + r * Math.cos(-angle120), cy + r * Math.sin(-angle120));
    this.zoneVisuals.lineBetween(cx, cy, cx + r * Math.cos(angle120), cy + r * Math.sin(angle120));
    
    // Add colored arcs to show zones more clearly
    // Jump zone (top) - green
    this.zoneVisuals.lineStyle(3, 0x00ff00, 0.4);
    this.zoneVisuals.arc(cx, cy, r * 0.8, -angle120, -angle60, false);
    
    // Crouch zone (bottom) - blue
    this.zoneVisuals.lineStyle(3, 0x0088ff, 0.4);
    this.zoneVisuals.arc(cx, cy, r * 0.8, angle60, angle120, false);
    
    // Movement zones (left/right) - orange
    this.zoneVisuals.lineStyle(3, 0xff8800, 0.4);
    this.zoneVisuals.arc(cx, cy, r * 0.8, -angle60, angle60, false); // Right
    this.zoneVisuals.arc(cx, cy, r * 0.8, angle120, Math.PI, false); // Left part 1
    this.zoneVisuals.arc(cx, cy, r * 0.8, -Math.PI, -angle120, false); // Left part 2
  }

  setupMobileControls() {
    // Zone-based control state
    this.touchStartX = 0;
    this.touchStartY = 0;
    this.touchZoneActive = false;
    this.isTouchFiring = false;
    
    // Zone configuration - based on comfortable thumb reach
    this.zoneRadius = 100; // Radius from touch point to edge
    // Load saved touch sensitivity or use default
    this.zoneDeadRadius = savedData.settings?.touchSensitivity || 30;
    
    // We'll use angle-based detection for the 4 directional zones
    // No need to pre-define boundaries, we'll calculate on the fly
    
    // Movement state tracking
    this.currentZone = 'center';
    this.lastMoveTime = 0;
    this.moveCooldown = 150; // ms between lane changes
    this.laneBeforeMove = null; // Track lane position before any move starts
    this.zoneHoldTimer = 0; // Track how long we've been in a zone
    this.zoneRepeatDelay = 300; // ms before first repeat
    this.zoneRepeatRate = 150; // ms between repeats after first
    this.lastZoneCheckTime = 0;
    
    // Jump charge tracking
    this.jumpChargeAmount = 0;
    this.maxPullDistance = 0; // Track the furthest pull distance
    this.isChargingJump = false;
    this.jumpThreshold = 40; // pixels up for jump
    
    // Visual debug indicator (optional)
    this.touchIndicator = this.add.circle(0, 0, 15, 0x00ff00, 0.3);
    this.touchIndicator.setVisible(false);
    
    // Zone visualization (for debugging - remove in production)
    if (true) { // Set to false in production
      this.zoneVisuals = this.add.graphics();
      this.zoneVisuals.setDepth(1000);
    }
    
    // Touch start - anywhere on screen
    this.input.on('pointerdown', (pointer) => {
      // Edge constraint - keep control center within screen bounds with padding
      const edgePadding = this.zoneRadius * 0.7; // Allow 30% of zone to go off-screen
      this.touchStartX = Phaser.Math.Clamp(pointer.x, edgePadding, WIDTH - edgePadding);
      this.touchStartY = Phaser.Math.Clamp(pointer.y, edgePadding, HEIGHT - edgePadding);
      this.touchZoneActive = true;
      
      // Reset state
      this.currentZone = 'center';
      this.isChargingJump = false;
      this.jumpChargeAmount = 0;
      this.maxPullDistance = 0;
      this.queuedCrouchOnLanding = false;
      this.usingTimeBasedCharge = false;
      
      // Show touch indicator at clamped position
      this.touchIndicator.setPosition(this.touchStartX, this.touchStartY);
      this.touchIndicator.setVisible(true);
      this.touchIndicator.setAlpha(0.5);
      
      // Start firing immediately
      this.isTouchFiring = true;
      
      // Check if we started in a movement zone (edge case)
      const dx = pointer.x - this.touchStartX;
      const dy = pointer.y - this.touchStartY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > this.zoneDeadRadius) {
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        let startZone = 'center';
        
        if (angle >= -60 && angle < 60) {
          startZone = distance > this.zoneRadius ? 'rightDash' : 'rightMove';
        } else if (angle >= 60 && angle < 120) {
          startZone = 'crouch';
        } else if (angle >= -120 && angle < -60) {
          startZone = 'jump';
        } else {
          startZone = distance > this.zoneRadius ? 'leftDash' : 'leftMove';
        }
        
        if (startZone === 'leftMove' || startZone === 'rightMove') {
          // Trigger immediate movement
          if (startZone === 'leftMove') {
            this.moveLeft();
          } else {
            this.moveRight();
          }
          this.lastMoveTime = this.time.now;
          this.currentZone = startZone;
        }
      }
      
      // Visualize zones if enabled
      if (this.zoneVisuals) {
        this.updateZoneVisuals();
      }
    });
    
    // Touch move - zone-based movement detection
    this.input.on('pointermove', (pointer) => {
      if (!pointer.isDown || !this.touchZoneActive) return;
      
      // Update touch indicator position
      if (this.touchIndicator && this.touchIndicator.visible) {
        this.touchIndicator.setPosition(pointer.x, pointer.y);
      }
      
      const currentTime = this.time.now;
      const dx = pointer.x - this.touchStartX;
      const dy = pointer.y - this.touchStartY;
      
      // Update jump charge if in crouch zone or after leaving it (elastic pull)
      if (this.isChargingJump && !this.usingTimeBasedCharge) {
        // Normal distance-based charge tracking (not time-based)
        const currentPullDistance = Math.max(0, dy); // Only positive (downward) distance
        this.maxPullDistance = Math.max(this.maxPullDistance, currentPullDistance);
        
        // Charge based on the furthest pull, not current position
        const maxPullThreshold = this.zoneRadius * 2.25; // Pull to 225% of zone radius for max charge (1.5x original)
        this.jumpChargeAmount = Math.min(this.maxPullDistance / maxPullThreshold, 1.0); // 0 to 1 based on max pull
        
        // Update charge glow effect (same as keyboard)
        this.chargeGlow.clear();
        this.chargeGlow.setPosition(this.player.x, this.player.y);
        
        // Pulsing glow effect that grows with charge
        const pulseSpeed = 10 + this.jumpChargeAmount * 20; // Faster pulse as charge increases
        const pulse = Math.sin(currentTime * pulseSpeed * 0.001) * 0.2 + 0.8;
        const glowRadius = 30 + this.jumpChargeAmount * 50 * pulse;
        const glowAlpha = 0.3 + this.jumpChargeAmount * 0.5 * pulse;
        
        // Color transitions from blue to yellow to purple
        const glowColor = this.jumpChargeAmount < 0.3 ? 
          { r: 0, g: 136, b: 255 } : // Blue
          this.jumpChargeAmount < 0.7 ? 
          { r: 255, g: 255, b: 0 } : // Yellow
          { r: 255, g: 0, b: 255 };  // Purple
        
        const hexColor = Phaser.Display.Color.GetColor(glowColor.r, glowColor.g, glowColor.b);
        
        this.chargeGlow.fillStyle(hexColor, glowAlpha);
        this.chargeGlow.fillCircle(0, 0, glowRadius);
        
        // Update pitch of charge sound
        try {
          const pitchShift = 1 + this.jumpChargeAmount * 2; // Rise up to 3x pitch
          gameSounds.jumpCharge.frequency.exponentialRampToValueAtTime(
            Tone.Frequency("C2").toFrequency() * pitchShift,
            Tone.now() + 0.05
          );
        } catch(e) {}
        
        // Visual feedback for charging on touch indicator too
        if (this.touchIndicator) {
          // Pulse and grow indicator based on charge
          const scale = 15 + this.jumpChargeAmount * 20;
          this.touchIndicator.setRadius(scale);
          this.touchIndicator.setFillStyle(hexColor, 0.5 + this.jumpChargeAmount * 0.3);
        }
      }
      
      // Determine which zone we're in using radial detection
      let newZone = 'center';
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance <= this.zoneDeadRadius) {
        newZone = 'center';
      } else {
        // Calculate angle from center (-180 to 180)
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        
        // Determine zone based on angle
        // Steeper angles for up/down (narrower zones)
        // Right: -60 to 60 degrees (wider)
        // Bottom: 60 to 120 degrees (narrower)
        // Left: 120 to -120 degrees (wider)
        // Top: -120 to -60 degrees (narrower)
        
        if (angle >= -60 && angle < 60) {
          // Right zone - move extends to full radius, dash beyond
          newZone = distance > this.zoneRadius ? 'rightDash' : 'rightMove';
        } else if (angle >= 60 && angle < 120) {
          // Bottom zone - narrower angle, harder to accidentally trigger
          newZone = 'crouch';
        } else if (angle >= -120 && angle < -60) {
          // Top zone - narrower angle for jump
          newZone = 'jump';
        } else {
          // Left zone (120 to 180 or -180 to -120)
          newZone = distance > this.zoneRadius ? 'leftDash' : 'leftMove';
        }
      }
      
      // Handle zone changes for horizontal movement
      if (newZone !== this.currentZone) {
        
        // Visual feedback for zone change
        if (this.touchIndicator) {
          switch(newZone) {
            case 'leftDash':
            case 'rightDash':
              this.touchIndicator.setFillStyle(0xff0000, 0.6); // Red for dash
              break;
            case 'leftMove':
            case 'rightMove':
              this.touchIndicator.setFillStyle(0xff8800, 0.5); // Orange for move
              break;
            case 'jump':
              this.touchIndicator.setFillStyle(0x00ff00, 0.5); // Green for jump
              break;
            case 'crouch':
              this.touchIndicator.setFillStyle(0x0088ff, 0.5); // Blue for crouch
              break;
            default:
              this.touchIndicator.setFillStyle(0x00aaff, 0.3); // Light blue for center
          }
        }
        
        // Check if we can execute movement - prevent rapid firing
        const timeSinceLastMove = currentTime - this.lastMoveTime;
        const canMove = !this.isMoving && !this.isDashing && timeSinceLastMove > this.moveCooldown;
        // Dash can always interrupt movement, just check we're not already dashing
        const canDash = !this.isDashing;
        
        // Execute actions based on zone entry
        switch(newZone) {
          case 'leftMove':
            if ((this.currentZone === 'center' || this.currentZone === 'jump') && canMove) {
              this.laneBeforeMove = this.playerLane; // Save position before move
              this.moveLeft();
              this.lastMoveTime = currentTime;
              
              // Schedule recentering after move completes (150ms)
              this.time.delayedCall(150, () => {
                if (this.touchZoneActive) {
                  // Get current pointer position
                  const activePointer = this.input.activePointer;
                  if (activePointer && activePointer.isDown) {
                    // Recenter with edge constraints
                    const edgePadding = this.zoneRadius * 0.7; // Allow 30% of zone to go off-screen
                    this.touchStartX = Phaser.Math.Clamp(activePointer.x, edgePadding, WIDTH - edgePadding);
                    this.touchStartY = Phaser.Math.Clamp(activePointer.y, edgePadding, HEIGHT - edgePadding);
                    
                    // Update visual zones at new position
                    if (this.zoneVisuals) {
                      this.updateZoneVisuals();
                    }
                  }
                }
              });
            }
            break;
            
          case 'rightMove':
            if ((this.currentZone === 'center' || this.currentZone === 'jump') && canMove) {
              this.laneBeforeMove = this.playerLane; // Save position before move
              this.moveRight();
              this.lastMoveTime = currentTime;
              
              // Schedule recentering after move completes (150ms)
              this.time.delayedCall(150, () => {
                if (this.touchZoneActive) {
                  // Get current pointer position
                  const activePointer = this.input.activePointer;
                  if (activePointer && activePointer.isDown) {
                    // Recenter with edge constraints
                    const edgePadding = this.zoneRadius * 0.7; // Allow 30% of zone to go off-screen
                    this.touchStartX = Phaser.Math.Clamp(activePointer.x, edgePadding, WIDTH - edgePadding);
                    this.touchStartY = Phaser.Math.Clamp(activePointer.y, edgePadding, HEIGHT - edgePadding);
                    
                    // Update visual zones at new position
                    if (this.zoneVisuals) {
                      this.updateZoneVisuals();
                    }
                  }
                }
              });
            }
            break;
            
          case 'leftDash':
            if (canDash) {
              // Check if we just moved (within 250ms like keyboard double-tap)
              if (this.laneBeforeMove !== null && currentTime - this.lastMoveTime < 250) {
                // Cancel the move and dash from original position
                // Kill ALL tweens to prevent any move animations from continuing
                this.tweens.killTweensOf(this.player);
                
                // Reset to original lane AND position
                this.playerLane = this.laneBeforeMove;
                this.player.x = this._laneX(this.playerLane);
                this.player.setScale(1, 1); // Reset scale
                
                // Clear the flag
                this.laneBeforeMove = null;
                this.isMoving = false; // Clear moving flag
              }
              
              // Dash 2 lanes
              this.dashLeft();
              this.lastMoveTime = currentTime;
            }
            break;
            
          case 'rightDash':
            if (canDash) {
              // Check if we just moved (within 250ms like keyboard double-tap)
              if (this.laneBeforeMove !== null && currentTime - this.lastMoveTime < 250) {
                // Cancel the move and dash from original position
                // Kill ALL tweens to prevent any move animations from continuing
                this.tweens.killTweensOf(this.player);
                
                // Reset to original lane AND position
                this.playerLane = this.laneBeforeMove;
                this.player.x = this._laneX(this.playerLane);
                this.player.setScale(1, 1); // Reset scale
                
                // Clear the flag
                this.laneBeforeMove = null;
                this.isMoving = false; // Clear moving flag
              }
              
              // Dash 2 lanes
              this.dashRight();
              this.lastMoveTime = currentTime;
            }
            break;
            
          case 'jump':
            // Simple jump zone - just do a regular jump
            if (this.currentZone !== 'jump' && !this.isJumping && !this.isChargingJump) {
              this.jump();
            }
            break;
            
          case 'crouch':
            // Queue charging if airborne, or start immediately if on ground
            if (!this.isChargingJump) {
              if (this.isJumping) {
                // Queue the charge to start when landing
                this.queuedCrouchOnLanding = true;
                // Don't start charging yet, just track that we're in crouch zone
              } else {
                // Start charging immediately if on ground
                this.isChargingJump = true;
                this.chargeGlow.setVisible(true);
                
                // Start charge sound
                try {
                  gameSounds.jumpCharge.triggerAttack("C2");
                } catch(e) {}
              }
            }
            break;
        }
        
        // If we left the crouch zone and went to a horizontal zone, cancel the charge or queue
        // But keep it active if going through center (which is part of the swipe path to jump)
        if (this.currentZone === 'crouch') {
          if (newZone === 'leftMove' || newZone === 'rightMove' || 
              newZone === 'leftDash' || newZone === 'rightDash') {
            // Cancelled by moving horizontally
            if (this.isChargingJump) {
              this.isChargingJump = false;
              this.jumpChargeAmount = 0;
              this.maxPullDistance = 0;
              this.chargeGlow.setVisible(false);
            }
            // Also cancel any queued crouch or time-based charge
            this.queuedCrouchOnLanding = false;
            this.usingTimeBasedCharge = false;
            // Stop charge sound
            try {
              gameSounds.jumpCharge.triggerRelease();
            } catch(e) {}
          }
          // Keep charge active when going through center or to jump
        }
        
        this.currentZone = newZone;
        this.zoneHoldTimer = 0; // Reset hold timer on zone change
      } else {
        // Same zone - check for auto-repeat for movement zones
        if (this.currentZone === 'leftMove' || this.currentZone === 'rightMove') {
          const currentTime = this.time.now;
          this.zoneHoldTimer += currentTime - (this.lastZoneCheckTime || currentTime);
          
          // Check if we should repeat the action
          const repeatThreshold = this.zoneHoldTimer > this.zoneRepeatDelay ? 
            this.zoneRepeatRate : this.zoneRepeatDelay;
          
          const timeSinceLastMove = currentTime - this.lastMoveTime;
          if (timeSinceLastMove > repeatThreshold && !this.isMoving && !this.isDashing) {
            if (this.currentZone === 'leftMove') {
              this.moveLeft();
            } else {
              this.moveRight();
            }
            this.lastMoveTime = currentTime;
          }
        }
      }
      
      this.lastZoneCheckTime = this.time.now;
    });
    
    // Touch end
    this.input.on('pointerup', (pointer) => {
      // Hide touch indicator
      if (this.touchIndicator) {
        this.touchIndicator.setVisible(false);
        this.touchIndicator.setFillStyle(0x00ff00, 0.3); // Reset color
      }
      
      // Clear zone visuals if enabled
      if (this.zoneVisuals) {
        this.zoneVisuals.clear();
      }
      
      // Stop time-based charging
      this.usingTimeBasedCharge = false;
      
      // Check if we should execute a charged jump on release
      if (this.isChargingJump && this.jumpChargeAmount > 0) {
        const chargePercent = this.jumpChargeAmount;
        if (chargePercent > 0.3) {
          // Super jump if charged enough, or queue if airborne
          if (!this.isJumping) {
            this.superJump(chargePercent);
          } else {
            // Queue the super jump to execute on landing
            this.queuedSuperJumpCharge = chargePercent;
          }
        } else {
          // Regular jump if barely charged (only if not already jumping)
          if (!this.isJumping) {
            this.jump();
          }
        }
        
        // Hide glow
        this.chargeGlow.setVisible(false);
        
        // Stop charge sound
        try {
          gameSounds.jumpCharge.triggerRelease();
        } catch(e) {}
      }
      
      // Reset state
      this.touchZoneActive = false;
      this.isTouchFiring = false;
      this.currentZone = 'center';
      this.isChargingJump = false;
      this.jumpChargeAmount = 0;
      this.maxPullDistance = 0;
      
      // Reset indicator size
      if (this.touchIndicator) {
        this.touchIndicator.setRadius(15);
      }
    });
  }

  moveLeft() {
    if(this.isMoving) return;
    // Block movement if already off-screen
    if(this.playerLane < 0 || this.playerLane >= LANES) return;
    const previousLane = this.playerLane;
    this.playerLane=Math.max(-1,this.playerLane-1); // Can go to -1 (off-screen left)
    const targetX = this._laneX(this.playerLane);
    
    // Play womp sound when entering off-screen
    if(this.playerLane === -1 && previousLane === 0) {
      try {
        gameSounds.offScreenWomp.triggerAttackRelease("C2", "4n");
      } catch(e) {}
    }
    
    // Check if we're jumping for special animation
    if(this.isJumping) {
      // Mid-air twirl animation
      this.isMoving = true;
      this.tweens.add({
        targets: this.player,
        x: targetX,
        duration: PLAYER_CONFIG.movement.air.duration,
        ease: 'Quad.easeOut',
        onComplete: () => {
          this.isMoving = false;
        }
      });
      
      // Add horizontal spin (barrel roll to the left)
      this.tweens.add({
        targets: this.player,
        angle: `-=${PLAYER_CONFIG.movement.air.barrelRoll.angle}`, // Spin counterclockwise
        duration: PLAYER_CONFIG.movement.air.barrelRoll.duration,
        ease: 'Cubic.easeOut'
      });
      
      // Add extra flair with scale pulse
      this.tweens.add({
        targets: this.player,
        scaleX: PLAYER_CONFIG.movement.air.scalePulse.x,
        scaleY: PLAYER_CONFIG.movement.air.scalePulse.y,
        duration: PLAYER_CONFIG.movement.air.scalePulse.duration,
        yoyo: true,
        ease: 'Sine.easeInOut'
      });
    } else {
      // Ground movement - jello stretchy animation
      this.isMoving = true;
      this.isStretching = true; // Only immune during stretch phase
      const cfg = PLAYER_CONFIG.movement.ground;
      
      // Add reactive wobble force
      this.wobbleVelocity.x = -cfg.wobble.reactiveForce; // Push wobble opposite to movement
      
      // First stretch towards the left with anticipation
      this.tweens.add({
        targets: this.player,
        scaleX: cfg.stretch.scaleX,
        scaleY: cfg.stretch.scaleY,
        duration: cfg.stretch.duration,
        ease: 'Cubic.easeOut',
        onComplete: () => {
          this.isStretching = false; // Stretch phase complete, no longer immune
          // Slingshot to position with overshoot
          this.tweens.add({
            targets: this.player,
            x: targetX - cfg.slingshot.overshoot, // Overshoot past target
            scaleX: cfg.slingshot.scaleX,
            scaleY: cfg.slingshot.scaleY,
            duration: cfg.slingshot.duration,
            ease: 'Power2',
            onComplete: () => {
              // Skip bounce if dash is starting or in progress
              if (this.isDashStarting || this.isDashing) {
                this.isMoving = false;
                return;
              }
              // Bounce back with secondary wobble
              this.tweens.add({
                targets: this.player,
                x: targetX + cfg.bounce.offset, // Bounce back
                scaleX: cfg.bounce.scaleX,
                scaleY: cfg.bounce.scaleY,
                duration: cfg.bounce.duration,
                ease: 'Sine.easeInOut',
                onComplete: () => {
                  this.isMoving = false; // Can shoot after bounce completes
                  // Final settle with jello wobbles (purely visual)
                  this.tweens.add({
                    targets: this.player,
                    x: targetX,
                    scaleX: 1,
                    scaleY: 1,
                    duration: cfg.settle.duration,
                    ease: 'Elastic.easeOut',
                    easeParams: cfg.settle.elasticity
                  });
                }
              });
            }
          });
        }
      });
    }
    
    // Reset rubber band timer when moving off-screen
    if(this.playerLane < 0 || this.playerLane >= LANES){
      this.offScreenTimer = PLAYER_CONFIG.offScreen.gracePeriod;
      this.player.setAlpha(PLAYER_CONFIG.offScreen.alpha);
      // Reset off-screen shooting counters when entering off-screen
      if(previousLane >= 0 && previousLane < LANES) {
        this.offScreenShotCount = 0;
        // Normal move: 800ms total, leave 220ms for firing
        this.offScreenTurnDelay = 580; // 800ms - 220ms
      }
    } else {
      this.player.setAlpha(1);
    }
    // Play movement sound
    try {
      const note = getGameNote(Math.max(0, Math.min(4, this.playerLane))) + "5";
      gameSounds.move.triggerAttackRelease(note, "32n");
    } catch(e) {}
  }

  moveRight() {
    if(this.isMoving) return;
    // Block movement if already off-screen
    if(this.playerLane < 0 || this.playerLane >= LANES) return;
    const previousLane = this.playerLane;
    this.playerLane=Math.min(LANES,this.playerLane+1); // Can go to 5 (off-screen right)
    const targetX = this._laneX(this.playerLane);
    
    // Play womp sound when entering off-screen
    if(this.playerLane === LANES && previousLane === LANES - 1) {
      try {
        gameSounds.offScreenWomp.triggerAttackRelease("C2", "4n");
      } catch(e) {}
    }
    
    // Check if we're jumping for special animation
    if(this.isJumping) {
      // Mid-air twirl animation
      this.isMoving = true;
      this.tweens.add({
        targets: this.player,
        x: targetX,
        duration: PLAYER_CONFIG.movement.air.duration,
        ease: 'Quad.easeOut',
        onComplete: () => {
          this.isMoving = false;
        }
      });
      
      // Add horizontal spin (barrel roll to the right)
      this.tweens.add({
        targets: this.player,
        angle: `+=${PLAYER_CONFIG.movement.air.barrelRoll.angle}`, // Spin clockwise
        duration: PLAYER_CONFIG.movement.air.barrelRoll.duration,
        ease: 'Cubic.easeOut'
      });
      
      // Add extra flair with scale pulse
      this.tweens.add({
        targets: this.player,
        scaleX: PLAYER_CONFIG.movement.air.scalePulse.x,
        scaleY: PLAYER_CONFIG.movement.air.scalePulse.y,
        duration: PLAYER_CONFIG.movement.air.scalePulse.duration,
        yoyo: true,
        ease: 'Sine.easeInOut'
      });
    } else {
      // Ground movement - jello stretchy animation
      this.isMoving = true;
      this.isStretching = true; // Only immune during stretch phase
      const cfg = PLAYER_CONFIG.movement.ground;
      
      // Add reactive wobble force
      this.wobbleVelocity.x = cfg.wobble.reactiveForce; // Push wobble opposite to movement
      
      // First stretch towards the right with anticipation
      this.tweens.add({
        targets: this.player,
        scaleX: cfg.stretch.scaleX,
        scaleY: cfg.stretch.scaleY,
        duration: cfg.stretch.duration,
        ease: 'Cubic.easeOut',
        onComplete: () => {
          this.isStretching = false; // Stretch phase complete, no longer immune
          // Slingshot to position with overshoot
          this.tweens.add({
            targets: this.player,
            x: targetX + cfg.slingshot.overshoot, // Overshoot past target
            scaleX: cfg.slingshot.scaleX,
            scaleY: cfg.slingshot.scaleY,
            duration: cfg.slingshot.duration,
            ease: 'Power2',
            onComplete: () => {
              // Skip bounce if dash is starting or in progress
              if (this.isDashStarting || this.isDashing) {
                this.isMoving = false;
                return;
              }
              // Bounce back with secondary wobble
              this.tweens.add({
                targets: this.player,
                x: targetX - cfg.bounce.offset, // Bounce back
                scaleX: cfg.bounce.scaleX,
                scaleY: cfg.bounce.scaleY,
                duration: cfg.bounce.duration,
                ease: 'Sine.easeInOut',
                onComplete: () => {
                  this.isMoving = false; // Can shoot after bounce completes
                  // Final settle with jello wobbles (purely visual)
                  this.tweens.add({
                    targets: this.player,
                    x: targetX,
                    scaleX: 1,
                    scaleY: 1,
                    duration: cfg.settle.duration,
                    ease: 'Elastic.easeOut',
                    easeParams: cfg.settle.elasticity
                  });
                }
              });
            }
          });
        }
      });
    }
    
    // Reset rubber band timer when moving off-screen
    if(this.playerLane < 0 || this.playerLane >= LANES){
      this.offScreenTimer = PLAYER_CONFIG.offScreen.gracePeriod;
      this.player.setAlpha(PLAYER_CONFIG.offScreen.alpha);
      // Reset off-screen shooting counters when entering off-screen
      if(previousLane >= 0 && previousLane < LANES) {
        this.offScreenShotCount = 0;
        // Normal move: 800ms total, leave 220ms for firing
        this.offScreenTurnDelay = 580; // 800ms - 220ms
      }
    } else {
      this.player.setAlpha(1);
    }
    // Play movement sound
    try {
      const note = getGameNote(Math.max(0, Math.min(4, this.playerLane))) + "5";
      gameSounds.move.triggerAttackRelease(note, "32n");
    } catch(e) {}
  }

  jump() {
    if(this.isJumping) return;
    this.isJumping = true;
    
    // Jump animation - higher jump to clear obstacles better
    this.tweens.add({
      targets: this.player,
      y: PLAYER_Y - 120, // Higher jump
      scaleX: 1.2,
      scaleY: 1.2,
      duration: 250,
      ease: 'Quad.easeOut',
      yoyo: true,
      onYoyo: () => {
        // Player has reached apex and is starting to fall - allow jumping again
      },
      onComplete: () => {
        this.isJumping = false;
        this.player.y = PLAYER_Y;
        // Animate rotation back to 0 if needed
        if(Math.abs(this.player.angle % 360) > 1) {
          this.tweens.add({
            targets: this.player,
            angle: 0,
            duration: 200,
            ease: 'Cubic.easeOut'
          });
        } else {
          this.player.angle = 0;
        }
        
        // Check if we should start charging based on queued crouch
        if (this.queuedCrouchOnLanding && this.currentZone === 'crouch') {
          this.isChargingJump = true;
          this.chargeGlow.setVisible(true);
          this.queuedCrouchOnLanding = false;
          
          // Start time-based charging like keyboard
          this.touchChargeStartTime = this.time.now;
          this.usingTimeBasedCharge = true;
          this.jumpChargeAmount = 0;
          this.maxPullDistance = 0;
          // Start charge sound
          try {
            gameSounds.jumpCharge.triggerAttack("C2");
          } catch(e) {}
          
          // Reset touch reference point
          const activePointer = this.input.activePointer;
          if (activePointer && activePointer.isDown) {
            const edgePadding = this.zoneRadius * 0.7;
            this.touchStartX = Phaser.Math.Clamp(activePointer.x, edgePadding, WIDTH - edgePadding);
            this.touchStartY = Phaser.Math.Clamp(activePointer.y, edgePadding, HEIGHT - edgePadding);
          }
          
          // Start charge sound
          try {
            gameSounds.jumpCharge.triggerAttack("C2");
          } catch(e) {}
          
          // Squash animation when starting crouch
          this.tweens.add({
            targets: this.player,
            scaleX: 1.4,
            scaleY: 0.6,
            duration: 100,
            ease: 'Power2'
          });
        }
        
        // Check for queued super jump (old system, keeping for compatibility)
        if (this.queuedSuperJumpCharge > 0) {
          const charge = this.queuedSuperJumpCharge;
          this.queuedSuperJumpCharge = 0;
          this.time.delayedCall(50, () => {
            this.superJump(charge);
          });
        }
      }
    });
    
    // Only do a simple forward flip if no directional input
    // Mid-air directional moves will override this
    this.jumpSpinTween = this.tweens.add({
      targets: this.player,
      angle: 360,
      duration: 500, // Match total jump time (250 * 2)
      ease: 'Linear'
    });
    
    // Jump sound effect
    try {
      const now = Tone.now();
      gameSounds.move.triggerAttackRelease("C6", "16n", now);
      gameSounds.move.triggerAttackRelease("G6", "16n", now + 0.05);
    } catch(e) {}
  }

  dashLeft() {
    if(this.isDashing) return;  // Only check isDashing, not isMoving
    // Block dashing if already off-screen
    if(this.playerLane < 0 || this.playerLane >= LANES) return;
    
    const startLane = this.playerLane;
    const targetLane = Math.max(-1, this.playerLane - 2);  // Dash 2 lanes total
    // Can't dash if already at leftmost position  
    if(startLane <= -1) return;  // Allow dashing from lane 0
    
    this.isDashing = true;
    this.isMoving = true;
    
    // Set a flag to prevent move animations from creating bounce tweens
    this.isDashStarting = true;
    
    // Store jump state before killing tweens
    const wasJumping = this.isJumping;
    const jumpY = this.player.y;
    
    // Kill ALL existing tweens to prevent move animations from continuing
    this.tweens.killTweensOf(this.player);
    
    // Restore jump if we were jumping
    if (wasJumping) {
      // Continue the jump animation
      this.tweens.add({
        targets: this.player,
        y: PLAYER_Y,
        duration: 250,
        ease: 'Quad.easeIn',
        onComplete: () => {
          this.isJumping = false;
          this.player.y = PLAYER_Y;
          // Animate rotation back to 0 if needed
          if(Math.abs(this.player.angle % 360) > 1) {
            this.tweens.add({
              targets: this.player,
              angle: 0,
              duration: 200,
              ease: 'Cubic.easeOut'
            });
          } else {
            this.player.angle = 0;
          }
        }
      });
    }
    
    // Always update X to start lane position before dashing
    const startX = this._laneX(startLane);
    if (!this.isJumping) {
      this.player.x = startX;
    }
    this.player.setScale(1, 1);  // Reset scale
    this.player.angle = 0;  // Reset rotation
    
    // Create dash trail effect at start position
    const trail1 = this.add.image(startX, this.player.y, 'playerTex');
    trail1.setAlpha(0.5);
    trail1.setTint(0x00ffff);
    
    const trail2 = this.add.image(startX, this.player.y, 'playerTex');
    trail2.setAlpha(0.3);
    trail2.setTint(0x00ffff);
    
    // Dash sound effect
    try {
      const now = Tone.now();
      gameSounds.move.triggerAttackRelease("C4", "32n", now);
      gameSounds.move.triggerAttackRelease("G3", "32n", now + 0.02);
      // Whoosh effect using filter sweep
      gameSounds.offScreenWomp.triggerAttackRelease("C3", "32n", now);
    } catch(e) {}
    
    // Update lane immediately so firing is in sync
    this.playerLane = targetLane;
    
    // Reset rubber band timer when dashing off-screen
    if(this.playerLane < 0 || this.playerLane >= LANES){
      // Give extra time when dashing from edge lanes (0 or 4) to off-screen
      const isDashingFromEdge = (startLane === 0 && this.playerLane < 0) || 
                                (startLane === LANES - 1 && this.playerLane >= LANES);
      this.offScreenTimer = isDashingFromEdge ? 
        PLAYER_CONFIG.offScreen.gracePeriod + 400 : // Extra 400ms for edge dash
        PLAYER_CONFIG.offScreen.gracePeriod;
      this.player.setAlpha(PLAYER_CONFIG.offScreen.alpha);
      
      // Set turn delay based on dash type and rapid fire status
      if(isDashingFromEdge) {
        // Outer lane dash: 1200ms total
        if(this.rapidFire) {
          // Rapid fire: leave 290ms for firing (~7-8 shots)
          this.offScreenTurnDelay = 910; // 1200ms - 290ms
        } else {
          // Normal: leave 330ms for firing (~3 shots)
          this.offScreenTurnDelay = 870; // 1200ms - 330ms
        }
      } else {
        // Inner lane dash: 800ms total, same as normal move
        // Leave 220ms for firing (~2 shots normal, ~5-6 rapid)
        this.offScreenTurnDelay = 580; // 800ms - 220ms
      }
      this.offScreenShotCount = 0; // Reset shot counter
    } else {
      this.player.setAlpha(1);
    }
    
    const targetX = this._laneX(targetLane);
    
    // Check collision in the starting lane (we're passing through it during dash)
    this.checkDashCollision();
    
    // Set player to start position explicitly
    this.player.x = startX;
    
    // Log what we're about to animate
    // Fast dash animation to the target
    this.tweens.add({
      targets: [this.player, trail1, trail2],
      x: targetX,  // Just animate to target, don't use from/to syntax
      duration: PLAYER_CONFIG.dash.duration,  // 60ms - same as stretch phase
      ease: 'Power2',
      onComplete: () => {
        this.isMoving = false;
        this.isDashing = false;
        // Clear the dash starting flag after dash completes
        this.isDashStarting = false;
        // Ensure visual position matches logical lane
        const expectedX = this._laneX(this.playerLane);
        this.player.x = expectedX;
        
        // Log position again after a frame to see if something changes it
        this.time.delayedCall(16, () => {
        });
        
        // Store the expected position and check if anything modifies it
        const correctX = expectedX;
        let checkCount = 0;
        const positionChecker = this.time.addEvent({
          delay: 1,
          repeat: 200,
          callback: () => {
            if (Math.abs(this.player.x - correctX) > 1) {
              // Log all active tweens
              const activeTweens = this.tweens.getTweensOf(this.player);
              if (activeTweens.length > 0) {
              }
              positionChecker.remove();
            }
            checkCount++;
          }
        });
        // Check collision at endpoint
        this.checkDashCollision();
        
        // Add jiggle animation after dash
        this.tweens.add({
          targets: this.player,
          scaleX: [0.7, 1.2, 1],
          scaleY: [1.3, 0.9, 1],
          duration: 120,
          ease: 'Sine.easeInOut'
        });
      }
    });
    
    // Fade out trails
    this.tweens.add({
      targets: trail1,
      alpha: 0,
      duration: 200,
      delay: 50,
      onComplete: () => trail1.destroy()
    });
    
    this.tweens.add({
      targets: trail2,
      alpha: 0,
      duration: 200,
      delay: 100,
      onComplete: () => trail2.destroy()
    });
  }
  
  dashRight() {
    if(this.isDashing) return;  // Only check isDashing, not isMoving
    // Block dashing if already off-screen
    if(this.playerLane < 0 || this.playerLane >= LANES) return;
    
    const startLane = this.playerLane;
    const targetLane = Math.min(LANES, this.playerLane + 2);  // Dash 2 lanes total
    // Can't dash if already at rightmost position
    if(startLane >= LANES) return;  // Allow dashing from lane 4 to off-screen
    
    this.isDashing = true;
    this.isMoving = true;
    
    // Set a flag to prevent move animations from creating bounce tweens
    this.isDashStarting = true;
    
    // Store jump state before killing tweens
    const wasJumping = this.isJumping;
    const jumpY = this.player.y;
    
    // Kill ALL existing tweens to prevent move animations from continuing
    this.tweens.killTweensOf(this.player);
    
    // Restore jump if we were jumping
    if (wasJumping) {
      // Continue the jump animation
      this.tweens.add({
        targets: this.player,
        y: PLAYER_Y,
        duration: 250,
        ease: 'Quad.easeIn',
        onComplete: () => {
          this.isJumping = false;
          this.player.y = PLAYER_Y;
          // Animate rotation back to 0 if needed
          if(Math.abs(this.player.angle % 360) > 1) {
            this.tweens.add({
              targets: this.player,
              angle: 0,
              duration: 200,
              ease: 'Cubic.easeOut'
            });
          } else {
            this.player.angle = 0;
          }
        }
      });
    }
    
    // Always update X to start lane position before dashing
    const startX = this._laneX(startLane);
    if (!this.isJumping) {
      this.player.x = startX;
    }
    this.player.setScale(1, 1);  // Reset scale
    this.player.angle = 0;  // Reset rotation
    
    // Create dash trail effect at start position
    const trail1 = this.add.image(startX, this.player.y, 'playerTex');
    trail1.setAlpha(0.5);
    trail1.setTint(0x00ffff);
    
    const trail2 = this.add.image(startX, this.player.y, 'playerTex');
    trail2.setAlpha(0.3);
    trail2.setTint(0x00ffff);
    
    // Dash sound effect
    try {
      const now = Tone.now();
      gameSounds.move.triggerAttackRelease("C4", "32n", now);
      gameSounds.move.triggerAttackRelease("G3", "32n", now + 0.02);
      // Whoosh effect using filter sweep
      gameSounds.offScreenWomp.triggerAttackRelease("C3", "32n", now);
    } catch(e) {}
    
    // Update lane immediately so firing is in sync
    this.playerLane = targetLane;
    
    // Reset rubber band timer when dashing off-screen
    if(this.playerLane < 0 || this.playerLane >= LANES){
      // Give extra time when dashing from edge lanes (0 or 4) to off-screen
      const isDashingFromEdge = (startLane === 0 && this.playerLane < 0) || 
                                (startLane === LANES - 1 && this.playerLane >= LANES);
      this.offScreenTimer = isDashingFromEdge ? 
        PLAYER_CONFIG.offScreen.gracePeriod + 400 : // Extra 400ms for edge dash
        PLAYER_CONFIG.offScreen.gracePeriod;
      this.player.setAlpha(PLAYER_CONFIG.offScreen.alpha);
      
      // Set turn delay based on dash type and rapid fire status
      if(isDashingFromEdge) {
        // Outer lane dash: 1200ms total
        if(this.rapidFire) {
          // Rapid fire: leave 290ms for firing (~7-8 shots)
          this.offScreenTurnDelay = 910; // 1200ms - 290ms
        } else {
          // Normal: leave 330ms for firing (~3 shots)
          this.offScreenTurnDelay = 870; // 1200ms - 330ms
        }
      } else {
        // Inner lane dash: 800ms total, same as normal move
        // Leave 220ms for firing (~2 shots normal, ~5-6 rapid)
        this.offScreenTurnDelay = 580; // 800ms - 220ms
      }
      this.offScreenShotCount = 0; // Reset shot counter
    } else {
      this.player.setAlpha(1);
    }
    
    const targetX = this._laneX(targetLane);
    
    // Check collision in the starting lane (we're passing through it during dash)
    this.checkDashCollision();
    
    // Set player to start position explicitly
    this.player.x = startX;
    
    // Log what we're about to animate
    // Fast dash animation to the target
    this.tweens.add({
      targets: [this.player, trail1, trail2],
      x: targetX,  // Just animate to target, don't use from/to syntax
      duration: PLAYER_CONFIG.dash.duration,  // 60ms - same as stretch phase
      ease: 'Power2',
      onComplete: () => {
        this.isMoving = false;
        this.isDashing = false;
        // Clear the dash starting flag after dash completes
        this.isDashStarting = false;
        // Ensure visual position matches logical lane
        const expectedX = this._laneX(this.playerLane);
        this.player.x = expectedX;
        
        // Log position again after a frame to see if something changes it
        this.time.delayedCall(16, () => {
        });
        
        // Store the expected position and check if anything modifies it
        const correctX = expectedX;
        let checkCount = 0;
        const positionChecker = this.time.addEvent({
          delay: 1,
          repeat: 200,
          callback: () => {
            if (Math.abs(this.player.x - correctX) > 1) {
              // Log all active tweens
              const activeTweens = this.tweens.getTweensOf(this.player);
              if (activeTweens.length > 0) {
              }
              positionChecker.remove();
            }
            checkCount++;
          }
        });
        // Check collision at endpoint
        this.checkDashCollision();
        
        // Add jiggle animation after dash
        this.tweens.add({
          targets: this.player,
          scaleX: [0.7, 1.2, 1],
          scaleY: [1.3, 0.9, 1],
          duration: 120,
          ease: 'Sine.easeInOut'
        });
      }
    });
    
    // Fade out trails
    this.tweens.add({
      targets: trail1,
      alpha: 0,
      duration: 200,
      delay: 50,
      onComplete: () => trail1.destroy()
    });
    
    this.tweens.add({
      targets: trail2,
      alpha: 0,
      duration: 200,
      delay: 100,
      onComplete: () => trail2.destroy()
    });
  }
  
  checkDashCollision() {
    // Check collision with obstacles during dash - using progress-based 3D collision
    for(let o of this.obstacles) {
      if(o.progress > 0.94 && o.progress < 0.97 && o.lane === this.playerLane && !this.isJumping && !this.isInvincible) {
        // Set invincible immediately to prevent multiple deaths
        this.isInvincible = true;
        
        // Hit obstacle during dash - game over
        this.cameras.main.shake(500, 0.03);
        this.player.setTint(0xff0000);
        
        // Player death sound - same as regular collision
        try {
          const now = Tone.now();
          gameSounds.obstacleHit.triggerAttackRelease("G2", "16n", now);
          gameSounds.obstacleHit.triggerAttackRelease("D2", "16n", now + 0.05);
          gameSounds.obstacleHit.triggerAttackRelease("G1", "16n", now + 0.1);
          gameSounds.explosion.triggerAttackRelease("8n", now + 0.02);
        } catch(e) {}
        
        // Show game over screen
        this.showGameOverScreen();
        break;
      }
    }
  }
  
  superJump(chargePercent = 1.0) {
    if(this.isJumping) return;
    this.isJumping = true;
    
    // Track super jumps for tutorial (only count if charged enough)
    if (this.isTutorial && this.tutorialWave === 5 && chargePercent > 0.3) {
      this.tutorialSuperJumps = (this.tutorialSuperJumps || 0) + 1;
    }
    
    // Calculate jump height: from 1x (120) to 3x (360) based on charge for more distinction
    const minHeight = 120;
    const maxHeight = 360;
    const jumpHeight = minHeight + (maxHeight - minHeight) * chargePercent;
    
    // Scale the stretch effect based on charge
    const stretchX = 0.6 + (1.0 - chargePercent) * 0.3; // More dramatic stretch
    const stretchY = 1.3 + chargePercent * 0.8; // More stretch for higher charge
    
    // Create launch particles effect for charged jumps
    if(chargePercent > 0.3) {
      // Create burst effect at player position
      const particleCount = Math.floor(5 + chargePercent * 15);
      for(let i = 0; i < particleCount; i++) {
        const angle = (Math.PI * 2 * i) / particleCount;
        const speed = 100 + chargePercent * 250;
        const particle = this.add.graphics();
        particle.x = this.player.x;
        particle.y = this.player.y;
        
        // Draw small glowing particle
        const particleColor = chargePercent > 0.7 ? 0xff00ff : 0x00ffcc;
        particle.fillStyle(particleColor, 1);
        particle.fillCircle(0, 0, 4);
        
        // Animate particle outward and fade
        this.tweens.add({
          targets: particle,
          x: particle.x + Math.cos(angle) * speed,
          y: particle.y + Math.sin(angle) * speed / 2,
          alpha: 0,
          duration: 600,
          ease: 'Power2',
          onComplete: () => {
            particle.destroy();
          }
        });
      }
      
      // Screen shake for powerful jumps
      if(chargePercent > 0.7) {
        this.cameras.main.shake(200, 0.008 + chargePercent * 0.01);
      }
    }
    
    // First squash down as launch preparation with jello wobble
    this.player.setScale(1.6, 0.3);
    
    // Pre-launch wobble build-up
    this.wobbleVelocity.y = -20 * (1 + chargePercent);
    
    // Then stretch up and launch with elastic
    this.tweens.add({
      targets: this.player,
      scaleX: stretchX * 0.7,
      scaleY: stretchY * 1.3,
      duration: 150,
      ease: 'Back.easeOut',
      onComplete: () => {
        // Launch up with variable height
        const jumpDuration = 300 + chargePercent * 200;
        
        // Main jump tween with wobble
        this.tweens.add({
          targets: this.player,
          y: PLAYER_Y - jumpHeight,
          duration: jumpDuration,
          ease: 'Cubic.easeOut',
          onUpdate: (tween) => {
            // Add wobble during flight
            const progress = tween.progress;
            const wobbleAmount = (1 - progress) * 0.15; // Less wobble as we reach apex
            this.player.scaleX = 1 + Math.sin(progress * Math.PI * 4) * wobbleAmount;
            this.player.scaleY = 1 + Math.cos(progress * Math.PI * 4) * wobbleAmount;
          },
          yoyo: true,
          onYoyo: () => {
            // At apex, add a little squish
            this.player.setScale(1.2, 0.8);
            this.tweens.add({
              targets: this.player,
              scaleX: 1,
              scaleY: 1,
              duration: 100,
              ease: 'Sine.easeInOut'
            });
          },
          onComplete: () => {
            // Landing with multiple bounces
            this.player.setScale(2, 0.3); // Extreme squash on landing
            this.wobbleVelocity.y = 15;
            
            // First bounce up
            this.tweens.add({
              targets: this.player,
              scaleX: 0.7,
              scaleY: 1.5,
              y: PLAYER_Y - 20,
              duration: 100,
              ease: 'Quad.easeOut',
              onComplete: () => {
                // Mini landing
                this.tweens.add({
                  targets: this.player,
                  scaleX: 1.3,
                  scaleY: 0.7,
                  y: PLAYER_Y,
                  duration: 80,
                  ease: 'Quad.easeIn',
                  onComplete: () => {
                    // Allow jumping after first bounce
                    this.isJumping = false;
                    this.player.y = PLAYER_Y;
                    
                    // Handle rotation reset and queued actions here
                    if(Math.abs(this.player.angle % 360) > 1) {
                      this.tweens.add({
                        targets: this.player,
                        angle: 0,
                        duration: 200,
                        ease: 'Cubic.easeOut'
                      });
                    } else {
                      this.player.angle = 0;
                    }
                    
                    // Check if we should start charging based on queued crouch
                    if (this.queuedCrouchOnLanding && this.currentZone === 'crouch') {
                      this.isChargingJump = true;
                      this.chargeGlow.setVisible(true);
                      this.queuedCrouchOnLanding = false;
                      
                      // Start time-based charging like keyboard
                      this.touchChargeStartTime = this.time.now;
                      this.usingTimeBasedCharge = true;
                      this.jumpChargeAmount = 0;
                      this.maxPullDistance = 0;
                      // Start charge sound
                      try {
                        gameSounds.jumpCharge.triggerAttack("C2");
                      } catch(e) {}
                      
                      // Reset touch reference point
                      const activePointer = this.input.activePointer;
                      if (activePointer && activePointer.isDown) {
                        const edgePadding = this.zoneRadius * 0.7;
                        this.touchStartX = Phaser.Math.Clamp(activePointer.x, edgePadding, WIDTH - edgePadding);
                        this.touchStartY = Phaser.Math.Clamp(activePointer.y, edgePadding, HEIGHT - edgePadding);
                      }
                      
                      // Squash animation when starting crouch
                      this.tweens.add({
                        targets: this.player,
                        scaleX: 1.4,
                        scaleY: 0.6,
                        duration: 100,
                        ease: 'Power2'
                      });
                    }
                    
                    // Check for queued super jump
                    if (this.queuedSuperJumpCharge > 0) {
                      const charge = this.queuedSuperJumpCharge;
                      this.queuedSuperJumpCharge = 0;
                      this.time.delayedCall(50, () => {
                        this.superJump(charge);
                      });
                    }
                    
                    // Final jello settle
                    this.tweens.add({
                      targets: this.player,
                      scaleX: 1,
                      scaleY: 1,
                      duration: 400,
                      ease: 'Elastic.easeOut',
                      easeParams: [0.2, 0.15],
                      onComplete: () => {
                        // Final settle complete - everything was handled after first bounce
                      }
                    });
                  }
                });
              }
            });
          }
        });
        
        // Spin based on charge with wobble
        const spinAngle = 360 + chargePercent * 360;
        this.tweens.add({
          targets: this.player,
          angle: spinAngle,
          duration: jumpDuration * 2,
          ease: 'Cubic.easeInOut'
        });
      }
    });
    
    // Enhanced super jump sound that scales with charge
    try {
      const now = Tone.now();
      
      // Base launch sound - deeper and more powerful than regular jump
      gameSounds.powerUp.triggerAttackRelease("C3", "8n", now);
      
      if(chargePercent > 0.3) {
        // Add harmonic layer
        gameSounds.powerUp.triggerAttackRelease("G3", "8n", now + 0.02);
        gameSounds.move.triggerAttackRelease("C6", "16n", now);
      }
      if(chargePercent > 0.5) {
        // Add rising arpeggio
        gameSounds.powerUp.triggerAttackRelease("E4", "16n", now + 0.05);
        gameSounds.move.triggerAttackRelease("G6", "16n", now + 0.08);
      }
      if(chargePercent > 0.7) {
        // Add high sparkle for max charge
        gameSounds.powerUp.triggerAttackRelease("C5", "32n", now + 0.1);
        gameSounds.move.triggerAttackRelease("E7", "32n", now + 0.12);
        // Extra bass thump for maximum power
        gameSounds.offScreenWomp.triggerAttackRelease("C1", "16n", now);
      }
    } catch(e) {}
  }

  _laneX(lane, progress = 1){ 
    // Interpolate X position between vanishing point and lane position based on progress
    // Use the same vanishing point as the grid
    const vanishX = this.vanishX || WIDTH / 2;
    // Clamp off-screen lanes to be partially visible
    let clampedLane = lane;
    if(lane < 0) {
      clampedLane = -0.7; // Show 30% of ship on left edge
    } else if(lane >= LANES) {
      clampedLane = LANES - 0.3; // Show 30% of ship on right edge
    }
    const bottomLaneX = clampedLane * LANE_W + LANE_W / 2;
    return vanishX + (bottomLaneX - vanishX) * progress;
  }
  _spawnEnemy(lane, speed, texture='enemyTex'){ 
    const vanishY = HEIGHT * 0.15; // Same horizon as grid
    const e=this.add.image(this._laneX(lane, 0), vanishY, texture); // Start at vanishing point
    e.lane = lane;
    e.progress = 0; // 0 = at horizon, 1 = at player
    e.vy=speed; 
    e.baseSize = texture === 'fastEnemyTex' ? this.fastEnemyBaseSize : this.enemyBaseSize;
    e.w=e.baseSize; e.h=e.baseSize; 
    e.enemyType = texture; // Track enemy type
    e.setScale(0.1); // Start tiny at horizon
    e.setDepth(100); // Between shield (10) and poles (200)
    e.trailPoints = []; // Store trail history
    this.enemies.push(e); 
  }
  
  _createSplatEffect(x, y) {
    // Create a splat/squish effect for hitting walls
    const splatColor = 0x00ffcc;
    
    // Main splat circle that expands and fades
    const splat = this.add.circle(x, y, 30, splatColor, 1); // Much bigger initial size
    splat.setDepth(1000); // Make sure it's on top
    this.tweens.add({
      targets: splat,
      scaleX: 6, // Bigger expansion
      scaleY: 0.8, // Less squish
      alpha: 0,
      duration: 400,
      ease: 'Power2',
      onComplete: () => splat.destroy()
    });
    
    // Splatter particles that spray outward
    for(let i = 0; i < 12; i++) {
      const particle = this.add.rectangle(x, y, 16, 16, splatColor); // Bigger particles
      particle.setDepth(1000); // Make sure particles are on top
      const angle = (Math.PI * 2 / 12) * i;
      const speed = 150 + Math.random() * 100;
      
      // Particles spray more horizontally than vertically
      const xVel = Math.cos(angle) * speed * 1.5;
      const yVel = Math.sin(angle) * speed * 0.5;
      
      this.tweens.add({
        targets: particle,
        x: x + xVel,
        y: y + yVel,
        scaleX: 0.2,
        scaleY: 2, // Stretch vertically as they fall
        alpha: 0,
        rotation: Math.random() * Math.PI,
        duration: 600,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    }
    
    // Screen flash
    this.cameras.main.flash(200, 0, 255, 204, true);
  }
  
  pauseGame() {
    if (this.isPaused) return;
    
    this.isPaused = true;
    
    // Track pause time for accurate game timer
    this.pauseStartTime = this.time.now;
    
    // Pause all tweens
    this.tweens.pauseAll();
    
    // Apply blur effect
    this.cameras.main.setPostPipeline('Blur');
    
    // Create pause overlay
    this.pauseOverlay = this.add.graphics();
    this.pauseOverlay.fillStyle(0x000000, 0.5);
    this.pauseOverlay.fillRect(0, 0, WIDTH, HEIGHT);
    this.pauseOverlay.setDepth(10000);
    
    // Calculate responsive font sizes
    const baseFontSize = Math.min(WIDTH, HEIGHT) * 0.08;
    const smallFontSize = Math.min(WIDTH, HEIGHT) * 0.04;
    
    // Add PAUSED text
    this.pauseText = this.add.text(WIDTH/2, HEIGHT/2 - 60, 'PAUSED', {
      font: `${baseFontSize}px monospace`,
      fill: '#ffffff'
    });
    this.pauseText.setOrigin(0.5);
    this.pauseText.setDepth(10001);
    
    // Add high score display (on top) - centered with proper spacing
    this.pauseHighScoreText = this.add.text(WIDTH/2, HEIGHT/2, `High Score: ${sessionHighScore}`, {
      font: `${smallFontSize}px monospace`,
      fill: '#ff0'
    });
    this.pauseHighScoreText.setOrigin(0.5, 0.5);
    this.pauseHighScoreText.setDepth(10001);
    
    // Add current score display (below) - centered with proper spacing
    this.pauseScoreText = this.add.text(WIDTH/2, HEIGHT/2 + 40, `Score: ${this.score}`, {
      font: `${smallFontSize}px monospace`,
      fill: '#0f0'
    });
    this.pauseScoreText.setOrigin(0.5, 0.5);
    this.pauseScoreText.setDepth(10001);
    
    // Add instruction text
    this.pauseInstructionText = this.add.text(WIDTH/2, HEIGHT/2 + 80, 'Press SPACE or tap to continue', {
      font: `${smallFontSize * 0.7}px monospace`,
      fill: '#888888'
    });
    this.pauseInstructionText.setOrigin(0.5);
    this.pauseInstructionText.setDepth(10001);
    
    // Pause music
    if (Tone.Transport.state === 'started') {
      Tone.Transport.pause();
    }
    
    // Update play/pause button to show play icon
    const btn = document.getElementById('playPauseBtn');
    if (btn) {
      btn.textContent = '▶';
      btn.title = 'Resume';
    }
  }
  
  resumeGame() {
    if (!this.isPaused) return;
    
    this.isPaused = false;
    
    // Adjust game start time to account for pause duration
    if (this.pauseStartTime) {
      const pauseDuration = this.time.now - this.pauseStartTime;
      this.gameStartTime += pauseDuration;
      
      // Also adjust adaptive difficulty timer if assisting
      if (this.adaptiveState.isAssisting && this.adaptiveState.assistStartTime) {
        this.adaptiveState.assistStartTime += pauseDuration;
      }
    }
    
    // Resume all tweens
    this.tweens.resumeAll();
    
    // Remove blur effect
    this.cameras.main.resetPostPipeline();
    
    // Clean up pause overlay
    if (this.pauseOverlay) {
      this.pauseOverlay.destroy();
      this.pauseOverlay = null;
    }
    if (this.pauseText) {
      this.pauseText.destroy();
      this.pauseText = null;
    }
    if (this.pauseScoreText) {
      this.pauseScoreText.destroy();
      this.pauseScoreText = null;
    }
    if (this.pauseHighScoreText) {
      this.pauseHighScoreText.destroy();
      this.pauseHighScoreText = null;
    }
    if (this.pauseInstructionText) {
      this.pauseInstructionText.destroy();
      this.pauseInstructionText = null;
    }
    
    // Resume music if it was playing
    if (Tone.Transport.state === 'paused') {
      Tone.Transport.start();
    }
    
    // Update play/pause button to show pause icon
    const btn = document.getElementById('playPauseBtn');
    if (btn) {
      btn.textContent = '||';
      btn.title = 'Pause';
    }
  }
  
  showGameOverScreen() {
    // Set flag to block pause and controls
    this.isShowingGameOver = true;
    this.playerCanControl = false;
    
    // Track this death for adaptive difficulty
    this.recentDeaths.push({
      score: this.score,
      timestamp: Date.now()
    });
    
    // Keep only last 3 deaths
    if (this.recentDeaths.length > 3) {
      this.recentDeaths.shift();
    }
    
    // Check if player is struggling (all 3 recent deaths < 1000 points)
    if (this.recentDeaths.length === 3 && 
        this.recentDeaths.every(death => death.score < 1000)) {
      // Enable adaptive assistance
      this.adaptiveState.isAssisting = true;
      this.adaptiveState.assistStartTime = this.time.now;
      this.adaptiveState.currentSpawnMultiplier = 0.7;  // 70% spawn rate
      this.adaptiveState.currentSpeedMultiplier = 0.85; // 85% speed
    }
    
    // Calculate survival time
    const survivalTimeMs = this.time.now - this.gameStartTime;
    const survivalSeconds = Math.floor(survivalTimeMs / 1000);
    const survivalMinutes = Math.floor(survivalSeconds / 60);
    const survivalSecondsRemainder = survivalSeconds % 60;
    const survivalTimeString = `${survivalMinutes}:${survivalSecondsRemainder.toString().padStart(2, '0')}`;
    
    // Calculate points per second
    const pointsPerSecond = survivalSeconds > 0 ? (this.score / survivalSeconds).toFixed(1) : '0.0';
    
    // Track game over event with detailed metrics
    const scoreBucket = this.score < 100 ? '0-99' : 
                       this.score < 500 ? '100-499' :
                       this.score < 1000 ? '500-999' :
                       this.score < 2500 ? '1000-2499' :
                       this.score < 5000 ? '2500-4999' : '5000+';
    
    const sessionTime = this.sessionStartTime ? Math.floor((Date.now() - this.sessionStartTime) / 1000) : 0;
    
    trackEvent('game_over', {
      score: this.score,
      score_bucket: scoreBucket,
      high_score: sessionHighScore,
      new_high_score: this.score > sessionHighScore,
      combo_max: this.maxComboReached || this.comboCount,
      beats_survived: this.beats,
      session_time: sessionTime,
      control_type: window.controlType,
      difficulty: currentDifficulty?.name || 'normal',
      genre: currentGenre || 'techno',
      grid_enabled: gridEnabled
    });
    
    // Track specific achievement for scores > 100
    if (this.score > 100) {
      trackEvent('achievement_unlocked', {
        achievement: 'score_over_100',
        score: this.score
      });
    }
    
    // Darken the screen - very high depth to be above everything
    const overlay = this.add.graphics();
    overlay.fillStyle(0x000000, 0.7);
    overlay.fillRect(0, 0, WIDTH, HEIGHT);
    overlay.setAlpha(0);
    overlay.setDepth(20000); // Above everything else
    
    // Check if new high score (before resetting)
    const beatHighScore = this.score > sessionHighScore;
    if(beatHighScore) {
      sessionHighScore = this.score;
      saveGameData({ highScore: sessionHighScore });
      
      // Track new high score separately
      trackEvent('new_high_score', {
        score: this.score,
        previous_high: this.sessionHighScore || 0,
        improvement: this.score - (this.sessionHighScore || 0)
      });
    }
    
    // Calculate responsive text sizes based on screen dimensions
    const screenRef = Math.min(WIDTH, HEIGHT);
    const isMobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);
    
    // Scale based on screen size with mobile boost
    const mobileMult = isMobile ? 1.2 : 1.0;
    const bigFontSize = `${Math.floor(screenRef * 0.09 * mobileMult)}px`;
    const medFontSize = `${Math.floor(screenRef * 0.05 * mobileMult)}px`;
    const smallFontSize = `${Math.floor(screenRef * 0.03 * mobileMult)}px`;
    const tinyFontSize = `${Math.floor(screenRef * 0.025 * mobileMult)}px`;
    
    // Score display
    const scoreLabel = this.add.text(WIDTH/2, HEIGHT/2 - screenRef * 0.08, 'SCORE', {
      font: `${medFontSize} monospace`,
      fill: '#0f0'
    });
    scoreLabel.setOrigin(0.5);
    scoreLabel.setAlpha(0);
    scoreLabel.setDepth(20001); // Above overlay
    
    const scoreText = this.add.text(WIDTH/2, HEIGHT/2, this.score.toString(), {
      font: `${bigFontSize} monospace`,
      fill: beatHighScore ? '#ffff00' : '#00ffcc'
    });
    scoreText.setOrigin(0.5);
    scoreText.setAlpha(0);
    scoreText.setShadow(0, 0, beatHighScore ? '#ffff00' : '#00ffcc', 20);
    scoreText.setDepth(20001); // Above overlay
    
    // High score message
    let congratsText = null;
    if(beatHighScore) {
      congratsText = this.add.text(WIDTH/2, HEIGHT/2 + screenRef * 0.1, 'NEW HIGH SCORE!', {
        font: `${medFontSize} monospace`,
        fill: '#ff00ff'
      });
      congratsText.setOrigin(0.5);
      congratsText.setAlpha(0);
      congratsText.setShadow(0, 0, '#ff00ff', 15);
      congratsText.setDepth(20001); // Above overlay
      
      // Pulse animation for new high score
      this.tweens.add({
        targets: congratsText,
        scaleX: 1.1,
        scaleY: 1.1,
        duration: 500,
        yoyo: true,
        repeat: -1,
        ease: 'Sine.inOut'
      });
    } else {
      const highScoreText = this.add.text(WIDTH/2, HEIGHT/2 + screenRef * 0.1, `HIGH SCORE: ${sessionHighScore}`, {
        font: `${smallFontSize} monospace`,
        fill: '#ff0'
      });
      highScoreText.setOrigin(0.5);
      highScoreText.setAlpha(0);
      highScoreText.setData('isHighScoreText', true); // Mark for later cleanup
      
      this.tweens.add({
        targets: highScoreText,
        alpha: 0.8,
        duration: 600,
        delay: 800
      });
    }
    
    // Survival stats - time and points/second
    const statsY = beatHighScore ? HEIGHT/2 + screenRef * 0.15 : HEIGHT/2 + screenRef * 0.13;
    const survivalStatsText = this.add.text(WIDTH/2, statsY, 
      `Survived: ${survivalTimeString}  •  ${pointsPerSecond} pts/sec`, {
      font: `${tinyFontSize} monospace`,
      fill: '#00ffcc'
    });
    survivalStatsText.setOrigin(0.5);
    survivalStatsText.setAlpha(0);
    survivalStatsText.setDepth(20001);
    survivalStatsText.setData('isSurvivalStats', true); // Mark for cleanup
    
    this.tweens.add({
      targets: survivalStatsText,
      alpha: 0.9,
      duration: 600,
      delay: 1000
    });
    
    // Simple feedback UI - just thumbs up/down
    const feedbackY = HEIGHT/2 + screenRef * 0.17;
    
    // Feedback container for proper cleanup
    const feedbackContainer = this.add.container(WIDTH/2, feedbackY);
    feedbackContainer.setDepth(20001);
    feedbackContainer.setAlpha(0);
    feedbackContainer.setData('isFeedbackUI', true);
    
    // Check if we've already asked for feedback recently (within last 5 games)
    const lastFeedbackGame = parseInt(localStorage.getItem('lastFeedbackGame') || '0');
    const gamesPlayed = parseInt(localStorage.getItem('gamesPlayed') || '0');
    const newGamesPlayed = gamesPlayed + 1;
    localStorage.setItem('gamesPlayed', newGamesPlayed.toString());
    
    // Only show feedback UI every 5 games and if score > 100 (decent play session)
    const shouldShowFeedback = (newGamesPlayed - lastFeedbackGame >= 5 || lastFeedbackGame === 0) && this.score > 100;
    
    if (shouldShowFeedback) {
      // Question text
      const feedbackQuestion = this.add.text(0, 0, 'Having fun?', {
        font: `${tinyFontSize} monospace`,
        fill: '#888'
      });
      feedbackQuestion.setOrigin(0.5);
      feedbackContainer.add(feedbackQuestion);
      
      // Thumbs up button
      const thumbsUp = this.add.text(-30, 20, '👍', {
        font: `${medFontSize} monospace`,
        fill: '#fff'
      });
      thumbsUp.setOrigin(0.5);
      thumbsUp.setInteractive({ useHandCursor: true });
      thumbsUp.setAlpha(0.5);
      feedbackContainer.add(thumbsUp);
      
      // Thumbs down button
      const thumbsDown = this.add.text(30, 20, '👎', {
        font: `${medFontSize} monospace`,
        fill: '#fff'
      });
      thumbsDown.setOrigin(0.5);
      thumbsDown.setInteractive({ useHandCursor: true });
      thumbsDown.setAlpha(0.5);
      feedbackContainer.add(thumbsDown);
      
      // Hover effects
      thumbsUp.on('pointerover', () => {
        thumbsUp.setAlpha(1);
        thumbsUp.setScale(1.1);
      });
      thumbsUp.on('pointerout', () => {
        thumbsUp.setAlpha(0.5);
        thumbsUp.setScale(1);
      });
      
      thumbsDown.on('pointerover', () => {
        thumbsDown.setAlpha(1);
        thumbsDown.setScale(1.1);
      });
      thumbsDown.on('pointerout', () => {
        thumbsDown.setAlpha(0.5);
        thumbsDown.setScale(1);
      });
      
      // Handle thumbs up click - simple version
      thumbsUp.on('pointerdown', () => {
        // Track positive feedback
        trackEvent('feedback_given', {
          type: 'positive',
          score: this.score,
          games_played: newGamesPlayed,
          survival_time: Math.floor((this.time.now - this.gameStartTime) / 1000)
        });
        
        // Remember we asked for feedback
        localStorage.setItem('lastFeedbackGame', newGamesPlayed.toString());
        
        // Hide feedback UI
        feedbackContainer.setVisible(false);
        
        // Show simple thanks
        const thanksText = this.add.text(WIDTH/2, feedbackY + 5, 'Thanks! 💜', {
          font: `${tinyFontSize} monospace`,
          fill: '#0f0'
        });
        thanksText.setOrigin(0.5);
        thanksText.setDepth(20001);
        thanksText.setData('isThanksUI', true);
        
        // Fade in thanks message
        thanksText.setAlpha(0);
        this.tweens.add({
          targets: thanksText,
          alpha: 1,
          duration: 400
        });
      });
      
      // Handle thumbs down click - simple with Google Form link
      thumbsDown.on('pointerdown', () => {
        // Track negative feedback
        trackEvent('feedback_given', {
          type: 'negative',
          score: this.score,
          games_played: newGamesPlayed,
          survival_time: Math.floor((this.time.now - this.gameStartTime) / 1000)
        });
        
        // Remember we asked for feedback
        localStorage.setItem('lastFeedbackGame', newGamesPlayed.toString());
        
        // Hide initial feedback UI
        feedbackContainer.setVisible(false);
        
        // Show feedback link
        const formContainer = this.add.container(WIDTH/2, feedbackY);
        formContainer.setDepth(20001);
        formContainer.setData('isFormUI', true);
        
        const thanksText = this.add.text(0, 0, 'Thanks for the feedback!', {
          font: `${tinyFontSize} monospace`,
          fill: '#0ff'
        });
        thanksText.setOrigin(0.5);
        formContainer.add(thanksText);
        
        // Google Form link - you'll need to create this form and update the URL
        const formLink = this.add.text(0, 18, '[Share details]', {
          font: `${tinyFontSize} monospace`,
          fill: '#666'
        });
        formLink.setOrigin(0.5);
        formLink.setInteractive({ useHandCursor: true });
        formContainer.add(formLink);
        
        formLink.on('pointerover', () => {
          formLink.setStyle({ fill: '#fff' });
        });
        formLink.on('pointerout', () => {
          formLink.setStyle({ fill: '#666' });
        });
        
        formLink.on('pointerdown', () => {
          // Track form link click
          trackEvent('feedback_form_opened', {
            score: this.score
          });
          
          // Open Google Form in new tab
          window.open('https://docs.google.com/forms/d/e/1FAIpQLSeHzYiQAqJ_1VR6PAXgsBdJxkYte-UcwBlC1w83dJ0gopqBNQ/viewform', '_blank');
          
          formLink.setText('[Form opened]');
          formLink.setStyle({ fill: '#0f0' });
        });
        
        // Fade in form container
        formContainer.setAlpha(0);
        this.tweens.add({
          targets: formContainer,
          alpha: 1,
          duration: 400
        });
      });
      
      // Fade in feedback UI
      this.tweens.add({
        targets: feedbackContainer,
        alpha: 1,
        duration: 600,
        delay: 1200
      });
    }
    
    // Restart instruction with countdown - adjust Y position if feedback is shown
    const restartY = shouldShowFeedback ? HEIGHT/2 + screenRef * 0.23 : HEIGHT/2 + screenRef * 0.2;
    const restartText = this.add.text(WIDTH/2, restartY, 'RESTARTING IN 3...', {
      font: `${smallFontSize} monospace`,
      fill: '#00ffcc'  // Brighter cyan color for visibility
    });
    restartText.setOrigin(0.5);
    restartText.setAlpha(0);
    restartText.setDepth(20001); // Above overlay
    
    // Countdown timer
    let countdown = 3;
    const countdownTimer = this.time.addEvent({
      delay: 1000,
      callback: () => {
        countdown--;
        if (countdown > 0) {
          restartText.setText(`RESTARTING IN ${countdown}...`);
        } else {
          restartText.setText(`RESTARTING NOW!`);
        }
        // Pulse effect on each countdown
        this.tweens.add({
          targets: restartText,
          scaleX: 1.2,
          scaleY: 1.2,
          duration: 100,
          yoyo: true,
          ease: 'Power2'
        });
      },
      repeat: 2  // Run 2 more times after initial (3, 2, 1/NOW)
    });
    
    // Fade in overlay
    this.tweens.add({
      targets: overlay,
      alpha: 1,
      duration: 300
    });
    
    // Fade in score label
    this.tweens.add({
      targets: scoreLabel,
      alpha: 1,
      duration: 400,
      delay: 200
    });
    
    // Fade in and scale score number
    this.tweens.add({
      targets: scoreText,
      alpha: 1,
      scaleX: { from: 0.5, to: 1 },
      scaleY: { from: 0.5, to: 1 },
      duration: 600,
      delay: 400,
      ease: 'Back.out'
    });
    
    // Fade in congrats/high score text
    if(congratsText) {
      this.tweens.add({
        targets: congratsText,
        alpha: 1,
        duration: 600,
        delay: 800
      });
      
      // Celebratory sound for new high score
      try {
        const now = Tone.now();
        // Victory fanfare
        gameSounds.powerUp.triggerAttackRelease("C4", "16n", now);
        gameSounds.powerUp.triggerAttackRelease("E4", "16n", now + 0.1);
        gameSounds.powerUp.triggerAttackRelease("G4", "16n", now + 0.2);
        gameSounds.powerUp.triggerAttackRelease("C5", "8n", now + 0.3);
      } catch(e) {}
    }
    
    // Fade in restart text - full opacity for visibility
    this.tweens.add({
      targets: restartText,
      alpha: 1,  // Full opacity instead of 0.5
      duration: 400,
      delay: 1200
    });
    
    // Respawn right after countdown completes (1.2s delay + 3s countdown)
    this.time.delayedCall(4300, () => {
      // Fade out game over screen elements
      const highScoreElement = this.children.list.find(child => child && child.getData && child.getData('isHighScoreText'));
      const survivalStatsElement = this.children.list.find(child => child && child.getData && child.getData('isSurvivalStats'));
      const feedbackElement = this.children.list.find(child => child && child.getData && child.getData('isFeedbackUI'));
      const thanksElement = this.children.list.find(child => child && child.getData && child.getData('isThanksUI'));
      const formElement = this.children.list.find(child => child && child.getData && child.getData('isFormUI'));
      
      this.tweens.add({
        targets: [overlay, scoreLabel, scoreText, restartText, congratsText, highScoreElement, 
                 survivalStatsText, feedbackElement, thanksElement, formElement].filter(Boolean),
        alpha: 0,
        duration: 300,
        onComplete: () => {
          // Clean up game over screen elements
          overlay.destroy();
          scoreLabel.destroy();
          scoreText.destroy();
          restartText.destroy();
          if(congratsText) congratsText.destroy();
          if(highScoreElement) highScoreElement.destroy();
          if(survivalStatsText) survivalStatsText.destroy();
          if(feedbackElement) feedbackElement.destroy();
          if(thanksElement) thanksElement.destroy();
          if(formElement) formElement.destroy();
          
          // Reset score and combo for new round
          this.score = 0;
          this.scoreText.setText('0');
          this.combo = 1;
          this.comboText.setAlpha(0);
          
          // Reset difficulty progression
          this.beats = 0;
          
          // Reset game timer for new round
          this.gameStartTime = this.time.now;
          
          // Clear any power-ups
          this.rapidFire = false;
          this.rapidFireTimer = 0;
          this.player.clearTint();
          
          // Reset player to center lane with invincibility
          this.playerLane = 2;
          this.player.x = this._laneX(2);
          this.player.setVisible(true);
          this.player.setDepth(500); // Ensure player stays on top after respawn
          
          // Reset player states
          this.isJumping = false;
          this.isCrouching = false;
          this.isStretching = false;
          this.isDashing = false;
          this.isMoving = false;
          this.isTouchFiring = false;
          this.crouchTimer = 0;
          if(this.chargeGlow) this.chargeGlow.setVisible(false);
          
          // Re-enable controls and continue invincibility
          this.isShowingGameOver = false;
          this.playerCanControl = true;
          
          // Stop any existing invincibility tween
          if(this.invincibilityTween) {
            this.invincibilityTween.stop();
            this.invincibilityTween = null;
          }
          
          // Create flashing effect for invincibility
          this.invincibilityTween = this.tweens.add({
            targets: this.player,
            alpha: { from: 0.3, to: 1 },
            duration: 100,
            yoyo: true,
            repeat: -1
          });
          
          // End invincibility after 2 seconds (from when screen fades)
          this.time.delayedCall(2000, () => {
            this.isInvincible = false;
            if(this.invincibilityTween) {
              this.invincibilityTween.stop();
              this.invincibilityTween = null;
              this.player.setAlpha(1);
            }
          });
        }
      });
    });
  }
  
  _createDeathExplosion(playerX, playerY, enemyX, enemyY, enemyScale = 1.0) {
    // Multi-stage explosion for dramatic effect
    const colors = [0x00ffcc, 0xff3366, 0xffff00, 0xffffff];
    
    // Stage 1: Initial impact
    this._createExplosion(playerX, playerY, 0x00ffcc, 25, 1.0); // Player explosion always full size
    this._createExplosion(enemyX, enemyY, 0xff3366, 15, enemyScale); // Enemy explosion scales
    
    // Stage 2: Shockwave ring
    const ring = this.add.circle(playerX, playerY, 20, 0xffffff, 0);
    ring.setStrokeStyle(4, 0x00ffff, 1);
    this.tweens.add({
      targets: ring,
      scale: 5,
      alpha: 0,
      duration: 500,
      ease: 'Power2',
      onComplete: () => ring.destroy()
    });
    
    // Stage 3: Delayed secondary explosions
    this.time.delayedCall(100, () => {
      for(let i = 0; i < 3; i++) {
        const offsetX = (Math.random() - 0.5) * 60;
        const offsetY = (Math.random() - 0.5) * 60;
        this._createExplosion(playerX + offsetX, playerY + offsetY, colors[i % colors.length], 10);
      }
    });
    
    // Camera shake and flash
    this.cameras.main.shake(500, 0.02);
    this.cameras.main.flash(300, 255, 0, 0, true);
  }
  
  _createExplosion(x, y, color = 0xff3366, particleCount = 8, scale = 1.0){
    // Create particle explosion effect scaled by distance
    const scaledParticleCount = Math.max(3, Math.floor(particleCount * scale)); // Reduce particles for distant explosions
    const particleSize = 12 * scale; // Scale particle size
    
    for(let i = 0; i < scaledParticleCount; i++){
      const particle = this.add.rectangle(x, y, particleSize, particleSize, color);
      particle.setDepth(1000); // Ensure on top
      const angle = (Math.PI * 2 / scaledParticleCount) * i;
      const speed = (100 + Math.random() * 100) * scale; // Scale spread distance
      
      this.tweens.add({
        targets: particle,
        x: x + Math.cos(angle) * speed,
        y: y + Math.sin(angle) * speed,
        alpha: 0,
        scale: 0.1,
        duration: 400,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    }
    
    // Add a flash effect scaled by distance
    const flash = this.add.circle(x, y, 40 * scale, color, 0.9); // Scale flash size
    flash.setDepth(999); // Just below particles
    this.tweens.add({
      targets: flash,
      scale: 3, // Bigger expansion
      alpha: 0,
      duration: 200,
      ease: 'Power2',
      onComplete: () => flash.destroy()
    });
  }
  _spawnObstacle(lane){
    const vanishY = HEIGHT * 0.15;
    const baseX = this._laneX(lane, 0);
    
    // Calculate dimensions
    const obstacleW = Math.floor(80 * (Math.min(WIDTH, HEIGHT) / 800) * (isMobile ? 1.2 : 1.0) * MOBILE_SCALE);
    const obstacleH = Math.floor(22 * (Math.min(WIDTH, HEIGHT) / 800) * (isMobile ? 1.2 : 1.0) * MOBILE_SCALE);
    const poleWidth = Math.floor(obstacleW * 0.15);
    const shieldGap = 2;
    
    // For now, just use the original simple obstacle texture
    // The layering effect doesn't work with containers as I tried
    const o = this.add.image(baseX, vanishY, 'obstacleTex');
    o.lane = lane;
    o.progress = 0;
    o.vy = ENEMY_SPEED_BASE * 0.7;
    o.baseSize = Math.floor(60 * MOBILE_SCALE);
    o.w = o.baseSize;
    o.h = Math.floor(22 * MOBILE_SCALE);
    o.setScale(0.1);
    o.setDepth(150); // Put obstacles in front of enemies for now
    o.trailPoints = [];
    o.isObstacle = true;
    
    this.obstacles.push(o);
    
    // If we're in break section, spawn a star above this obstacle
    // During tutorial wave 6, always spawn stars. After tutorial, only in actual break sections
    if(this.isBreakSection) {
      // Always spawn stars during tutorial wave 6, or in normal game breaks
      if ((this.isTutorial && this.tutorialWave === 6) || !this.isTutorial) {
        this._spawnFloatingStar(o);
      }
    }
  }
  
  _spawnFloatingStar(obstacle) {
    const star = this.add.image(obstacle.x, obstacle.y - 25, 'starTex');
    star.attachedObstacle = obstacle;
    star.setScale(1.0); // Start at normal size, let update handle perspective scaling
    star.setDepth(160); // Above obstacles
    star.collected = false;
    star.rotationSpeed = 0.05; // Spinning speed
    star.floatOffset = 0;
    star.floatSpeed = 0.003;
    
    this.floatingStars.push(star);
  }
  
  _spawnPowerUp(lane){
    const vanishY = HEIGHT * 0.15;
    const p = this.add.image(this._laneX(lane, 0), vanishY, 'powerUpTex');
    p.lane = lane;
    p.progress = 0;
    p.vy = ENEMY_SPEED_BASE * 1.2;
    p.baseSize = Math.floor(20 * MOBILE_SCALE);
    p.setScale(0.1);
    p.setDepth(100); // Same depth as enemies - between shield and poles
    this.powerUps.push(p);
  }
  
  handleTutorialSpawn() {
    // Only spawn on certain beats for controlled tutorial experience
    switch(this.tutorialWave) {
      case 0: // Shooting practice
        if (!this.tutorialWaveStarted) {
          this.tutorialText.setText('PRESS SPACE TO SHOOT');
          this.tutorialProgressText.setText('Shoot the approaching enemies');
          this.tutorialWaveStarted = true;
          this.shootingShown = false;
        }
        
        // After 1 beat, start spawning enemies
        if (this.beats >= 1) {
          if (!this.shootingShown) {
            this.shootingShown = true;
            this.tutorialText.setText('ENEMIES APPEAR ON BEAT!');
          }
          // Spawn every beat for continuous flow
          if (this.beats % 1 === 0) {
            this._spawnEnemy(2, ENEMY_SPEED_BASE * 0.8, 'enemyTex'); // Center lane
          }
        }
        break;
        
      case 1: // Movement practice
        if (!this.tutorialWaveStarted) {
          // First just show the controls
          this.tutorialText.setText('PRESS ← → TO MOVE LANES');
          this.tutorialProgressText.setText('Move left and right');
          this.tutorialWaveStarted = true;
          this.tutorialTimer = 10000; // 10 seconds total
          this.movementShown = false;
          
          // Spawn first V formation immediately
          this.tutorialText.setText('DODGE THE V FORMATION!');
          this.movementShown = true;
          
          // Proper V formation with obstacles - 1 second spacing
          // Center lane first (point of V)
          this._spawnObstacle(2);
          // Inner lanes 1000ms later
          this.time.delayedCall(1000, () => {
            this._spawnObstacle(1);
            this._spawnObstacle(3);
          });
          // Outer lanes 1000ms after that (wings)
          this.time.delayedCall(2000, () => {
            this._spawnObstacle(0);
            this._spawnObstacle(4);
          });
        }
        
        // Second V formation - spawn earlier at beat 4 instead of 6
        if (this.beats === 4) {
          // Another V with same 1 second spacing
          this._spawnObstacle(2);
          this.time.delayedCall(1000, () => {
            this._spawnObstacle(1);
            this._spawnObstacle(3);
          });
          this.time.delayedCall(2000, () => {
            this._spawnObstacle(0);
            this._spawnObstacle(4);
          });
        }
        break;
        
      case 2: // Arc shot practice - move to shoot over obstacles
        if (this.beats % 6 === 0) {
          this._spawnObstacle(2); // Center lane obstacle
          // Spawn enemy behind it with more spacing
          this.time.delayedCall(600, () => {
            this._spawnEnemy(2, ENEMY_SPEED_BASE * 0.6, 'enemyTex');
          });
        }
        
        if (!this.tutorialWaveStarted) {
          this.tutorialText.setText('JUMP + SHOOT = ARC SHOT OVER SHIELDS');
          this.tutorialProgressText.setText('Hit 2 enemies behind shields');
          this.tutorialWaveStarted = true;
        }
        break;
        
      case 3: // Dash practice
        if (!this.tutorialWaveStarted) {
          this.tutorialText.setText('DOUBLE-TAP → TO DASH');
          this.tutorialProgressText.setText('Dash through gaps to collect power-ups');
          this.tutorialWaveStarted = true;
          
          // Spawn immediately when entering this wave
          // Create wall of obstacles with gap
          this._spawnObstacle(0);
          this._spawnObstacle(1);
          // Gap in lane 2
          this._spawnObstacle(3);
          this._spawnObstacle(4);
          
          // Spawn power-up RIGHT behind the wall
          this.time.delayedCall(20, () => {
            this._spawnPowerUp(0); // Power-up on left side, requires dash to reach
          });
        }
        
        // Second wall after some beats
        if (this.beats % 8 === 0 && this.beats > 0) {
          // Create another wall
          this._spawnObstacle(0);
          this._spawnObstacle(1);
          // Gap in lane 2
          this._spawnObstacle(3);
          this._spawnObstacle(4);
          
          // Power-up behind
          this.time.delayedCall(20, () => {
            this._spawnPowerUp(4); // Different lane this time
          });
        }
        break;
        
      case 4: // Arc shot practice
        // First set - teach arc shot
        if (this.beats === 1) {
          this._spawnObstacle(2); // Center lane obstacle
          // Spawn enemy behind it with more spacing
          this.time.delayedCall(700, () => {
            this._spawnEnemy(2, ENEMY_SPEED_BASE * 0.5, 'enemyTex');
          });
        }
        
        // Second set - more spacing, different lane
        if (this.beats === 12) {  // Much more spacing
          this._spawnObstacle(3); // Different lane
          this.time.delayedCall(700, () => {
            this._spawnEnemy(3, ENEMY_SPEED_BASE * 0.5, 'enemyTex');
          });
        }
        
        if (!this.tutorialWaveStarted) {
          this.tutorialText.setText('JUMP + SHOOT = ARC SHOT');
          this.tutorialProgressText.setText('Hit enemy, then move to dodge shield');
          this.tutorialWaveStarted = true;
          this.tutorialArcShotCount = 0;
        }
        
        // Update text after first arc shot
        if (this.tutorialArcShotCount !== (this.tutorialProgress.arcShotsHit || 0)) {
          this.tutorialArcShotCount = this.tutorialProgress.arcShotsHit || 0;
          if (this.tutorialArcShotCount === 1) {
            this.tutorialText.setText('GOOD! NOW MOVE TO DODGE THE SHIELD');
          }
        }
        break;
        
      case 5: // Super jump teaching
        if (!this.tutorialWaveStarted) {
          this.tutorialText.setText('HOLD ↓ TO CHARGE SUPER JUMP');
          this.tutorialProgressText.setText('Hold down, then release to jump higher!');
          this.tutorialWaveStarted = true;
          this.superJumpShown = false;
          this.tutorialSuperJumps = 0;
        }
        
        // After 2 beats, spawn obstacle to practice jumping over
        if (this.beats === 2 && !this.superJumpShown) {
          this.superJumpShown = true;
          this.tutorialText.setText('CHARGE AND JUMP OVER THE SHIELD!');
          this._spawnObstacle(2); // Center lane obstacle to jump over
        }
        
        // Spawn another obstacle every 6 beats for practice
        if (this.beats > 2 && this.beats % 6 === 0) {
          this._spawnObstacle(Phaser.Math.Between(1, 3));
        }
        break;
        
      case 6: // Star collection with super jump
        if (!this.tutorialWaveStarted) {
          this.tutorialText.setText('STARS APPEAR DURING BREAKS!');
          this.tutorialProgressText.setText('Super jump to collect stars above shields');
          this.tutorialWaveStarted = true;
          // Force break section behavior for stars during tutorial
          this.isBreakSection = true;
        }
        
        // Spawn obstacles with stars
        if (this.beats % 8 === 0) {
          this._spawnObstacle(2); // This will auto-spawn a star above it
        }
        if (this.beats % 8 === 4) {
          this._spawnObstacle(Phaser.Math.Between(1, 3));
        }
        break;
        
      case 7: // Full game preview with adaptive assistance
        if (!this.tutorialWaveStarted) {
          this.tutorialText.setText('FULL GAME - SURVIVE!');
          this.tutorialProgressText.setText('Starting at 70% difficulty, will increase gradually');
          this.tutorialWaveStarted = true;
          this.tutorialTimer = 30000; // 30 seconds
          
          // Enable adaptive assistance at 70% for the start
          this.adaptiveState.isAssisting = true;
          this.adaptiveState.assistStartTime = this.time.now;
          this.adaptiveState.currentSpawnMultiplier = 0.7;  // 70% spawn rate
          this.adaptiveState.currentSpeedMultiplier = 0.85; // 85% speed
        }
        // Wave 7 uses normal game spawning via GameAPI callbacks
        // No manual spawns needed here
        break;
    }
  }
  
  updateTutorialProgress() {
    if (!this.isTutorial) return;
    
    // Check wave completion based on current wave
    switch(this.tutorialWave) {
      case 0: // Shooting - need 3 hits
        this.tutorialProgressText.setText(`Enemies hit: ${this.tutorialProgress.shotsHit}/3`);
        if (this.tutorialProgress.shotsHit >= 3) {
          this.advanceTutorial();
        }
        break;
        
      case 1: // Movement - survive timer
        if (this.tutorialTimer) {
          this.tutorialTimer -= 16; // Approximate frame time
          const seconds = Math.ceil(this.tutorialTimer / 1000);
          this.tutorialProgressText.setText(`Dodge for: ${seconds} seconds`);
          if (this.tutorialTimer <= 0) {
            this.advanceTutorial();
          }
        }
        break;
        
      case 2: // Arc shots - hit enemies behind obstacles
        this.tutorialProgressText.setText(`Arc shots hit: ${this.tutorialProgress.arcShotsHit || 0}/2`);
        if ((this.tutorialProgress.arcShotsHit || 0) >= 2) {
          this.advanceTutorial();
        }
        break;
        
      case 3: // Dash - collect power-ups through dashing
        this.tutorialProgressText.setText(`Power-ups collected: ${this.tutorialProgress.powerUpsCollected || 0}/2`);
        if ((this.tutorialProgress.powerUpsCollected || 0) >= 2) {
          this.advanceTutorial();
        }
        break;
        
      case 4: // Arc shots - hit enemies behind obstacles
        this.tutorialProgressText.setText(`Arc shots hit: ${this.tutorialProgress.arcShotsHit || 0}/2`);
        if ((this.tutorialProgress.arcShotsHit || 0) >= 2) {
          this.advanceTutorial();
        }
        break;
        
      case 5: // Super jump teaching - need to perform 2 super jumps
        // Update instruction based on charge state
        if (this.jumpChargeAmount > 0.3) {
          this.tutorialText.setText('RELEASE TO JUMP!');
        } else if (this.jumpChargeAmount > 0.1) {
          this.tutorialText.setText('KEEP HOLDING TO CHARGE MORE!');
        } else if (this.isChargingJump) {
          this.tutorialText.setText('CHARGING...');
        }
        
        // Progress is now tracked directly in superJump function
        this.tutorialProgressText.setText(`Super jumps: ${this.tutorialSuperJumps || 0}/2`);
        if ((this.tutorialSuperJumps || 0) >= 2) {
          this.advanceTutorial();
        }
        break;
        
      case 6: // Stars - collect 2
        this.tutorialProgressText.setText(`Stars collected: ${this.tutorialProgress.starsCollected}/2`);
        if (this.tutorialProgress.starsCollected >= 2) {
          // Turn off break section mode after completing star tutorial
          this.isBreakSection = false;
          this.advanceTutorial();
        }
        break;
        
      case 7: // Full game - survive timer with adaptive difficulty display
        if (this.tutorialTimer) {
          this.tutorialTimer -= 16;
          const seconds = Math.ceil(this.tutorialTimer / 1000);
          
          // Show current difficulty level based on adaptive state
          const difficultyPercent = Math.round(this.adaptiveState.currentSpawnMultiplier * 100);
          const speedPercent = Math.round(this.adaptiveState.currentSpeedMultiplier * 100);
          
          this.tutorialProgressText.setText(`Practice: ${seconds}s | Difficulty: ${difficultyPercent}% | Speed: ${speedPercent}%`);
          
          if (this.tutorialTimer <= 0) {
            this.completeTutorial();
          }
        }
        break;
    }
  }
  
  advanceTutorial() {
    this.tutorialWave++;
    this.tutorialWaveStarted = false;
    this.tutorialTimer = null; // Reset any timers
    
    // Flash success message
    const successText = this.add.text(WIDTH/2, HEIGHT/2, 'EXCELLENT!', {
      font: 'bold 48px monospace',
      fill: '#00ff00',
      stroke: '#000000',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(1001);
    
    this.tweens.add({
      targets: successText,
      scale: 1.5,
      alpha: 0,
      duration: 1000,
      ease: 'Power2',
      onComplete: () => successText.destroy()
    });
    
    // Check if we've completed all waves (0-6, then 7 completes itself)
    if (this.tutorialWave >= 7) {
      // Wave 7 will complete itself via timer
      // Don't call completeTutorial here
    }
  }
  
  skipTutorial() {
    // Mark tutorial as skipped but not completed
    // Don't save completion so it will be offered again next time
    
    // Show skip message briefly
    this.tutorialText.setText('SKIPPING TUTORIAL...');
    this.tutorialProgressText.setText('Starting full game...');
    
    // Transition to normal game quickly
    this.time.delayedCall(500, () => {
      this.isTutorial = false;
      this.tutorialText.destroy();
      this.tutorialProgressText.destroy();
      this.skipTutorialButton.destroy();
      
      // Reset adaptive difficulty to normal
      this.adaptiveState.isAssisting = false;
      this.adaptiveState.currentSpawnMultiplier = 1.0;
      this.adaptiveState.currentSpeedMultiplier = 1.0;
      this.adaptiveState.assistStartTime = null;
      
      // Reset tempo to normal
      Tone.Transport.bpm.value = 120;
      
      // Reset beats counter
      this.beats = 0;
    });
  }
  
  completeTutorial() {
    // Save completion
    localStorage.setItem('beatrider_tutorial_completed', 'true');
    
    // Show completion message
    this.tutorialText.setText('TUTORIAL COMPLETE!');
    this.tutorialProgressText.setText('Starting full game...');
    
    // Transition to normal game after delay
    this.time.delayedCall(2000, () => {
      this.isTutorial = false;
      this.tutorialText.destroy();
      this.tutorialProgressText.destroy();
      if (this.skipTutorialButton && !this.skipTutorialButton.destroyed) {
        this.skipTutorialButton.destroy();
      }
      
      // Reset adaptive difficulty to normal
      this.adaptiveState.isAssisting = false;
      this.adaptiveState.currentSpawnMultiplier = 1.0;
      this.adaptiveState.currentSpeedMultiplier = 1.0;
      this.adaptiveState.assistStartTime = null;
      
      // Reset tempo to normal
      Tone.Transport.bpm.value = 120;
      
      // Reset GameAPI to normal spawning
      window.GameAPI.onBeat = () => {
        this.beats++;
        const speed=(ENEMY_SPEED_BASE + Math.floor(this.beats/16)*30) * currentDifficulty.speedMult;
        const lane = Phaser.Math.Between(0,LANES-1);
        this._spawnEnemy(lane, speed, 'enemyTex');
        
        for(let enemy of this.enemies) {
          if(enemy.enemyType === 'enemyTex') {
            enemy.pulseTime = this.time.now;
          }
        }
      };
    });
  }
  
  _spawnDrifter(lane){
    const vanishY = HEIGHT * 0.15;
    const d = this.add.image(this._laneX(lane, 0), vanishY, 'drifterTex');
    d.lane = lane;
    d.targetLane = lane; // Will change
    d.progress = 0;
    d.vy = ENEMY_SPEED_BASE * 0.8;
    d.baseSize = this.enemyBaseSize; // Use screen-relative size
    // Smaller collision box for diamonds - about 70% of visual size for tighter timing
    d.w = d.baseSize * 0.7; 
    d.h = d.baseSize * 0.7;
    d.enemyType = 'drifterTex';
    d.isDrifter = true;
    d.driftTimer = 0;
    d.setScale(0.1);
    d.setDepth(100); // Between shield (10) and poles (200)
    d.trailPoints = []; // Initialize trail points
    this.enemies.push(d); // Add to enemies array for collision
  }
  
  _pulseGrid(){
    // Set a pulse flag and timer
    this.pulseActive = true;
    this.pulseTimer = 150; // milliseconds
    this.pulsePhase = 0;
    
    // Check if we're in chaos mode - use random
    if (currentDifficulty === DIFFICULTY_PRESETS.chaos) {
      // Random pulse type: 0 = forward, 1 = left, 2 = right
      this.pulseType = Math.floor(Math.random() * 3);
    } else {
      // Use pattern based on current section
      const section = getSection(currentBar);
      const patternType = sectionPatternMap[section] || 'gentle';
      const patterns = pulsePatternPool[patternType];
      
      // Pick a pattern based on the current cycle
      // Use currentBar to ensure consistency within each section
      const patternIndex = Math.floor(currentBar / 8) % patterns.length;
      const pattern = patterns[patternIndex];
      
      // Calculate position within pattern (2 sub hits per bar)
      const hitsPerBar = 2;
      const totalHits = currentBar * hitsPerBar;
      const positionInPattern = totalHits % pattern.length;
      
      // Get direction from pattern (-1 = skip, 0 = forward, 1 = left, 2 = right)
      const direction = pattern[positionInPattern];
      
      if (direction === -1) {
        // Skip this pulse
        this.pulseActive = false;
        return;
      }
      
      // Safety check: prevent more than 2 forward pulses in a row
      if (!this.lastTwoDirections) this.lastTwoDirections = [];
      if (direction === 0 && this.lastTwoDirections.length >= 2 && 
          this.lastTwoDirections[0] === 0 && this.lastTwoDirections[1] === 0) {
        // Force a side movement instead
        this.pulseType = Math.random() > 0.5 ? 1 : 2;
      } else {
        this.pulseType = direction;
      }
      
      // Track last two directions
      this.lastTwoDirections.unshift(this.pulseType);
      if (this.lastTwoDirections.length > 2) {
        this.lastTwoDirections.pop();
      }
    }
  }
  
  _drawPerspectiveGrid(){
    // Clear and redraw the entire grid
    if(!this.gridGraphics){
      this.gridGraphics = this.add.graphics();
      this.gridOffset = 0;
    }
    
    // Always update vanishing point based on current dimensions
    this.vanishX = WIDTH / 2;
    this.vanishY = HEIGHT * 0.15;  // Move horizon much higher
    
    // Safety check - recreate if destroyed
    if(!this.gridGraphics.scene) {
      this.gridGraphics = this.add.graphics();
    }
    
    // Safety check before clearing
    if(!this.gridGraphics || !this.gridGraphics.scene) {
      // Grid graphics lost, recreating...
      this.gridGraphics = this.add.graphics();
    }
    
    this.gridGraphics.clear();
    const numLines = 12;
    
    // Draw curved lane lines that match the exponential perspective
    for(let lane = 0; lane <= LANES; lane++){
      const bottomX = lane * LANE_W;
      this.gridGraphics.lineStyle(1, 0x00ff00, 0.2);
      
      // Draw lane as a series of connected segments following the curve
      let lastX = this.vanishX;
      let lastY = this.vanishY;
      
      for(let t = 0.1; t <= 1; t += 0.1){
        // Use same exponential curve as objects
        const y = this.vanishY + (HEIGHT - this.vanishY) * Math.pow(t, 2.5);
        // Interpolate X position along the curve
        const x = this.vanishX + (bottomX - this.vanishX) * t;
        
        this.gridGraphics.lineBetween(lastX, lastY, x, y);
        lastX = x;
        lastY = y;
      }
      // Final segment to bottom
      this.gridGraphics.lineBetween(lastX, lastY, bottomX, HEIGHT);
    }
    
    // Draw horizontal lines with exponential spacing (Beamrider style)
    for(let i = 0; i < numLines; i++){
      // Calculate position with perspective - exponential spacing
      const t = (i + this.gridOffset % 1) / numLines;
      const y = this.vanishY + (HEIGHT - this.vanishY) * Math.pow(t, 2.5); // Exponential curve for perspective
      
      if(y < this.vanishY || y > HEIGHT) continue;
      
      // Width increases as lines get closer
      const width = WIDTH * (0.1 + t * 1.5);
      const alpha = 0.3 - t * 0.2; // Fade in distance
      
      this.gridGraphics.lineStyle(2, 0x00ff00, alpha);
      this.gridGraphics.lineBetween(WIDTH/2 - width/2, y, WIDTH/2 + width/2, y);
    }
  }
  _fire(){ 
    // Can't shoot while controls disabled or moving
    if(!this.playerCanControl || this.isMoving) return;
    
    // Check if we're off-screen for horizontal shooting
    const isOffScreen = this.playerLane < 0 || this.playerLane >= LANES;
    if(!HORIZONTAL_SHOOTING && isOffScreen) return; // Original behavior - can't shoot off-screen
    
    // Enforce turn delay when off-screen (timing-based shot limit)
    if(HORIZONTAL_SHOOTING && isOffScreen) {
      if(this.offScreenTurnDelay > 0) return; // Still turning around
      // Shot limit is now controlled by the firing window duration
    }
    
    const now=this.time.now; 
    
    // Block firing if we just resumed from pause
    if(this.fireBlockTime && now < this.fireBlockTime) return;
    
    const cooldown = (this.rapidFire ? FIRE_COOLDOWN/3 : FIRE_COOLDOWN) * currentDifficulty.fireMult;
    if(now-this.lastShotAt<cooldown) return; 
    this.lastShotAt=now;
    
    // Add recoil wobble when shooting
    this.wobbleVelocity.y = 3; // Small upward push
    if(!this.isJumping) {
      // Quick recoil animation for ground shots
      this.tweens.add({
        targets: this.player,
        scaleX: 0.9,
        scaleY: 1.1,
        duration: 50,
        ease: 'Power1',
        yoyo: true
      });
    } 
    // Shoot from player's current position (accounts for jumping)
    const b=this.add.image(this.player.x, this.player.y, 'bulletTex'); 
    b.lane = this.playerLane;
    b.setDepth(50); // Above enemies/obstacles but below player
    
    // Set bullet color based on combo level - smooth progression white->green->cyan->purple
    let bulletColor = 0xffffff; // 1x: Pure white (no combo)
    
    switch(this.combo) {
      case 1: bulletColor = 0xffffff; break;  // Pure white
      case 2: bulletColor = 0xccffcc; break;  // Light green
      case 3: bulletColor = 0x00ff00; break;  // Pure green
      case 4: bulletColor = 0x00ff88; break;  // Green-cyan blend
      case 5: bulletColor = 0x00ffff; break;  // Pure cyan
      case 6: bulletColor = 0x88ccff; break;  // Cyan-purple blend
      case 7: bulletColor = 0xcc88ff; break;  // Light purple
      case 8: 
      default: bulletColor = 0xff00ff; break;  // Neon purple (max combo)
    }
    
    // Modify brightness based on jump height for visual variety
    if(this.isJumping) {
      const jumpHeight = Math.max(0, this.groundY - this.player.y);
      const heightPercent = Math.min(1, jumpHeight / 200);
      // Add subtle brightness boost for jump shots
      if(heightPercent > 0.5) {
        // Brighten the color slightly for high jumps
        const r = Math.min(255, ((bulletColor >> 16) & 0xFF) + 30);
        const g = Math.min(255, ((bulletColor >> 8) & 0xFF) + 30);
        const b = Math.min(255, (bulletColor & 0xFF) + 30);
        bulletColor = (r << 16) | (g << 8) | b;
      }
    }
    
    b.setTint(bulletColor);
    
    // Store initial values for rotation calculation
    b.lastX = this.player.x;
    b.lastY = this.player.y;
    b.rotationSpeed = 0; // For spinning effect at higher combos
    if(this.combo >= 6) {
      b.rotationSpeed = 0.3; // Spin bullets at high combo
    }
    
    // Calculate progress based on player's current Y position
    // When jumping, player.y is higher (smaller), so we need to adjust progress
    const vanishY = HEIGHT * 0.15;
    const normalizedY = (this.player.y - vanishY) / (HEIGHT - vanishY);
    // Inverse the exponential curve formula to get progress from Y position
    b.progress = Math.pow(normalizedY, 1/2.5);
    
    // Debug logging for arc shot spawn
    if(this.isJumping) {
    }
    
    if (HORIZONTAL_SHOOTING && isOffScreen) {
      // Horizontal shooting when off-screen - sweep across all lanes
      // Determine direction based on which side we're on
      const direction = this.playerLane < 0 ? 1 : -1; // Shoot right if on left, left if on right
      
      b.vx = direction * BULLET_SPEED * 1.2; // Slightly faster for dramatic effect
      b.vy = 0; // No vertical movement
      b.isHorizontal = true;
      b.startLane = this.playerLane;
      b.currentLane = this.playerLane < 0 ? -0.5 : 4.5; // Start just outside visible area
      b.w = Math.floor(12 * MOBILE_SCALE); // Wider for horizontal
      b.h = Math.floor(6 * MOBILE_SCALE); // Shorter for horizontal
      b.setRotation(direction > 0 ? Math.PI/2 : -Math.PI/2); // Rotate 90 degrees for horizontal orientation
    } else {
      // Normal vertical shooting
      b.vy=-BULLET_SPEED; 
      b.isHorizontal = false;
    }
    
    b.w = b.w || Math.floor(6 * MOBILE_SCALE); 
    b.h = b.h || Math.floor(12 * MOBILE_SCALE);
    
    // If jumping, give bullet an arc trajectory with safe distance
    if(this.isJumping && !isOffScreen) {
      b.isArcShot = true;
      // Calculate safe distance based on jump height
      const jumpHeight = Math.abs(this.player.y - PLAYER_Y);
      const jumpPercent = Math.min(jumpHeight / ARC_SHOT_MAX_JUMP_HEIGHT, 1);
      b.safeDistance = ARC_SHOT_BASE_SAFE_DISTANCE + (jumpPercent * ARC_SHOT_HEIGHT_BONUS);
      b.startY = this.player.y; // Launch from jump height
      b.progress = 1.0; // Arc shots always start at bottom progress, regardless of visual height
      b.arcDistance = 0; // Track how far the arc shot has traveled
    } 
    if(this.rapidFire) {
      b.vy *= 1.5; // Faster bullets in rapid fire
      // Only play sound sometimes in rapid fire to avoid timing errors
      if(Math.random() < 0.3){
        try {
          // Use a consistent note in rapid fire instead of random
          const note = getGameNote(this.playerLane) + "6"; // Higher octave but same lane note
          const sound = gameSounds.laserSounds[gameSounds.currentLaserSound];
          if (sound.triggerAttackRelease) {
            sound.triggerAttackRelease(note, "32n", Tone.now() + 0.01);
          } else if (sound.triggerAttack) {
            // For PluckSynth which uses triggerAttack
            sound.triggerAttack(note, Tone.now() + 0.01);
          }
        } catch(e) {}
      }
    } else {
      try {
        const note = getGameNote(this.playerLane) + "5";
        const sound = gameSounds.laserSounds[gameSounds.currentLaserSound];
        
        // Different sounds need different trigger methods
        if (gameSounds.currentLaserSound === 2) {
          // Chord stab - play a mini chord
          const chordNotes = [note, getGameNote(this.playerLane + 2) + "5", getGameNote(this.playerLane + 4) + "5"];
          sound.triggerAttackRelease(chordNotes, "32n", Tone.now() + 0.01);
        } else if (gameSounds.currentLaserSound === 4) {
          // PluckSynth uses triggerAttack
          sound.triggerAttack(note, Tone.now() + 0.01);
        } else if (gameSounds.currentLaserSound === 5) {
          // Pew pew - play high note then quickly sweep down
          const highNote = getGameNote(this.playerLane) + "6";
          const lowNote = getGameNote(this.playerLane) + "3";
          sound.triggerAttackRelease(highNote, "16n", Tone.now());
          // Ramp the frequency down for pew pew effect
          sound.frequency.exponentialRampToValueAtTime(
            Tone.Frequency(lowNote).toFrequency(),
            Tone.now() + 0.15
          );
        } else {
          // Regular MonoSynth sounds
          sound.triggerAttackRelease(note, "32n", Tone.now() + 0.01);
        }
      } catch(e) {}
    }
    this.bullets.push(b); 
  }
  _aabb(a,b){ 
    return Math.abs(a.x-b.x) < (a.w+b.w)/2 && Math.abs(a.y-b.y) < (a.h+b.h)/2; 
  }

  update(_, dt){
    // Update tutorial progress if in tutorial mode
    if (this.isTutorial) {
      this.updateTutorialProgress();
    }
    
    // Update adaptive difficulty recovery
    if (this.adaptiveState.isAssisting && !this.isPaused && !this.isShowingGameOver) {
      const assistDuration = (this.time.now - this.adaptiveState.assistStartTime) / 1000;
      
      if (assistDuration > 90) {
        // After 90 seconds, return to normal
        this.adaptiveState.isAssisting = false;
        this.adaptiveState.currentSpawnMultiplier = 1.0;
        this.adaptiveState.currentSpeedMultiplier = 1.0;
      } else if (assistDuration > 60) {
        // 60-90 seconds: 90% spawn, 95% speed
        this.adaptiveState.currentSpawnMultiplier = 0.9;
        this.adaptiveState.currentSpeedMultiplier = 0.95;
      } else if (assistDuration > 30) {
        // 30-60 seconds: 80% spawn, 90% speed
        this.adaptiveState.currentSpawnMultiplier = 0.8;
        this.adaptiveState.currentSpeedMultiplier = 0.9;
      }
      // 0-30 seconds: stays at 70% spawn, 85% speed
    }
    
    // Handle ESC key for pause (blocked during game over)
    if (Phaser.Input.Keyboard.JustDown(this.keys.ESC)) {
      if (this.isShowingGameOver) return; // Block pause during game over
      if (!this.isPaused) {
        this.pauseGame();
      } else {
        this.resumeGame();
      }
    }
    
    // Handle grid toggle even when paused
    if(Phaser.Input.Keyboard.JustDown(this.keys.G)){
      this.gridVisible = !this.gridVisible;
      gridEnabled = this.gridVisible; // Save to persistent setting
      saveGameData({ settings: { gridEnabled: gridEnabled } });
      if(!this.gridVisible && this.gridGraphics) {
        this.gridGraphics.clear();
      } else if(this.gridVisible && this.isPaused) {
        // When paused and turning grid on, we need to draw it manually
        // since the normal update loop won't run
        this._drawPerspectiveGrid();
      }
      // Sync UI state
      uiState.gridVisible = this.gridVisible;
      updateGridButton();
    }
    
    // Handle resume from pause with SPACE or touch
    if (this.isPaused) {
      if (this.keys.SPACE.isDown || this.isTouchFiring) {
        this.resumeGame();
        // Small delay to prevent immediate firing after resume
        this.fireBlockTime = this.time.now + 100;
      }
      return; // Skip all updates when paused
    }
    
    // Update idle wobble animation when not moving
    if(!this.isMoving && !this.isJumping && !this.isDashing && this.player) {
      // Breathing/idle animation
      this.idleWobblePhase += dt * 0.003;
      const breathScale = 1 + Math.sin(this.idleWobblePhase) * 0.03;
      const squishScale = 1 - Math.cos(this.idleWobblePhase * 2) * 0.02;
      
      // Apply idle animation only if not already being animated
      if(!this.tweens.isTweening(this.player)) {
        this.player.setScale(
          breathScale * (1 + this.wobbleVelocity.x * 0.01),
          squishScale * (1 + this.wobbleVelocity.y * 0.01)
        );
      }
      
      // Update wobble physics
      this.wobbleVelocity.x *= this.wobbleDamping;
      this.wobbleVelocity.y *= this.wobbleDamping;
      
      // Add subtle random wobble impulses
      if(Math.random() < 0.02) {
        this.wobbleVelocity.x += (Math.random() - 0.5) * 2;
        this.wobbleVelocity.y += (Math.random() - 0.5) * 2;
      }
    }
    
    // Handle time-based touch charge (when queued from air)
    if (this.isChargingJump && this.usingTimeBasedCharge) {
      const currentTime = this.time.now;
      const elapsed = currentTime - this.touchChargeStartTime;
      const previousCharge = this.jumpChargeAmount;
      this.jumpChargeAmount = Math.min(elapsed / this.maxChargeTime, 1.0);
      
      // Log every 100ms to avoid spam
      if (Math.floor(elapsed / 100) > Math.floor((elapsed - dt) / 100)) {
      }
      
      // Update the glow effect
      this.chargeGlow.clear();
      this.chargeGlow.setPosition(this.player.x, this.player.y);
      
      const pulseSpeed = 10 + this.jumpChargeAmount * 20;
      const pulse = Math.sin(currentTime * pulseSpeed * 0.001) * 0.2 + 0.8;
      const glowRadius = 30 + this.jumpChargeAmount * 50 * pulse;
      const glowAlpha = 0.3 + this.jumpChargeAmount * 0.5 * pulse;
      
      const glowColor = this.jumpChargeAmount < 0.3 ? 
        { r: 0, g: 136, b: 255 } : // Blue
        this.jumpChargeAmount < 0.7 ? 
        { r: 255, g: 255, b: 0 } : // Yellow
        { r: 255, g: 0, b: 255 };  // Purple
      
      const hexColor = Phaser.Display.Color.GetColor(glowColor.r, glowColor.g, glowColor.b);
      this.chargeGlow.fillStyle(hexColor, glowAlpha);
      this.chargeGlow.fillCircle(0, 0, glowRadius);
      
      // Update pitch of charge sound
      try {
        const pitchShift = 1 + this.jumpChargeAmount * 2;
        gameSounds.jumpCharge.frequency.exponentialRampToValueAtTime(
          Tone.Frequency("C2").toFrequency() * pitchShift,
          Tone.now() + 0.05
        );
      } catch(e) {}
    }
    
    // Update combo timer display
    if(this.combo > 1) {
      const timeSinceKill = this.time.now - this.lastKillTime;
      const timeRemaining = Math.max(0, this.comboWindow - timeSinceKill);
      const meterPercent = timeRemaining / this.comboWindow;
      
      // Show combo meter
      this.comboMeterBg.setVisible(true);
      this.comboMeter.clear();
      
      // Color based on combo level and time remaining
      let meterColor = 0x00ff00; // Green
      if(meterPercent < 0.3) meterColor = 0xff0000; // Red when about to expire
      else if(meterPercent < 0.6) meterColor = 0xffff00; // Yellow warning
      else if(this.combo >= 6) meterColor = 0xff00ff; // Purple for high combos
      else if(this.combo >= 4) meterColor = 0x00ffff; // Cyan for mid combos
      
      this.comboMeter.fillStyle(meterColor, 0.8);
      this.comboMeter.fillRect(10, this.comboMeterY, 200 * meterPercent, 8);
      
      // Reset combo if timer expired
      if(timeRemaining <= 0) {
        this.combo = 1;
        this.comboMeterBg.setVisible(false);
        this.comboMeter.clear();
      }
    } else {
      // Hide meter when no combo
      this.comboMeterBg.setVisible(false);
      this.comboMeter.clear();
    }
    
    // Update starfield background
    this.updateStarfield(dt);
    
    // Update and draw trails
    this.updateTrails(dt);
    
    // Handle pulse effect - shift in different directions
    let pulseShift = 0;
    let pulseXShift = 0;
    // Disable pulse during tutorial to reduce difficulty
    if(this.pulseActive && !this.isTutorial){
      this.pulseTimer -= dt;
      if(this.pulseTimer <= 0){
        this.pulseActive = false;
      } else {
        // Create a pulse curve
        const t = 1 - (this.pulseTimer / 150);
        const amount = Math.sin(t * Math.PI);
        
        if(this.pulseType === 0){
          // Forward pulse - reduced from 0.05 to 0.015 for gentler movement
          pulseShift = amount * 0.015;
        } else if(this.pulseType === 1){
          // Left pulse
          pulseXShift = -amount * 30; // pixels
        } else {
          // Right pulse
          pulseXShift = amount * 30;
        }
      }
    }
    
    // Animate the perspective grid tied to BPM
    if(!this.gridOffset) this.gridOffset = 0;
    // Get current BPM from Tone.Transport or use default
    const currentBPM = (typeof Tone !== 'undefined' && Tone.Transport) ? Tone.Transport.bpm.value : 132;
    // Scale grid speed to BPM - higher BPM = faster scrolling
    // Grid toggle moved to top of update() to work when paused
    
    // Switch laser sounds with number keys
    if(Phaser.Input.Keyboard.JustDown(this.keys.ONE)) {
      gameSounds.currentLaserSound = 0;
      this.updateSoundDisplay();
    }
    if(Phaser.Input.Keyboard.JustDown(this.keys.TWO)) {
      gameSounds.currentLaserSound = 1;
      this.updateSoundDisplay();
    }
    if(Phaser.Input.Keyboard.JustDown(this.keys.THREE)) {
      gameSounds.currentLaserSound = 2;
      this.updateSoundDisplay();
    }
    if(Phaser.Input.Keyboard.JustDown(this.keys.FOUR)) {
      gameSounds.currentLaserSound = 3;
      this.updateSoundDisplay();
    }
    if(Phaser.Input.Keyboard.JustDown(this.keys.FIVE)) {
      gameSounds.currentLaserSound = 4;
      this.updateSoundDisplay();
    }
    if(Phaser.Input.Keyboard.JustDown(this.keys.SIX)) {
      gameSounds.currentLaserSound = 5;
      this.updateSoundDisplay();
    }
    
    // Add pulse shift to grid movement
    this.gridOffset += (dt / 1000) * (currentBPM / 60) + pulseShift * 1; // Reduced multiplier from 2 to 1 for gentler pulse
    if(this.gridVisible) {
      this._drawPerspectiveGrid();
    }
    
    // Apply horizontal shift to grid
    if(this.gridGraphics && pulseXShift !== 0){
      this.gridGraphics.x = pulseXShift;
    } else if(this.gridGraphics){
      this.gridGraphics.x = 0;
    }
    
    // Movement with rubber band effect and smooth transitions
    if(!this.playerCanControl) {
      // Block all movement when controls are disabled
    } else if(Phaser.Input.Keyboard.JustDown(this.keys.LEFT)||Phaser.Input.Keyboard.JustDown(this.keys.A)){ 
      const now = this.time.now;
      // Check for double-tap dash
      if(now - this.lastLeftPress < this.doubleTapWindow) {
        // Cancel the previous move and dash from original position (like touch controls)
        if (this.laneBeforeKeyboardMove !== undefined && this.isMoving) {
          // Kill ALL tweens to prevent move animations from continuing
          this.tweens.killTweensOf(this.player);
          
          // Reset to original lane AND position
          this.playerLane = this.laneBeforeKeyboardMove;
          this.player.x = this._laneX(this.playerLane);
          this.player.setScale(1, 1);
          this.isMoving = false;
        }
        this.dashLeft();
        this.lastLeftPress = 0; // Reset to prevent triple-tap
        this.laneBeforeKeyboardMove = undefined; // Clear the saved lane
      } else {
        this.laneBeforeKeyboardMove = this.playerLane; // Save current lane before move
        this.moveLeft();
        this.lastLeftPress = now;
      }
    }
    else if(Phaser.Input.Keyboard.JustDown(this.keys.RIGHT)||Phaser.Input.Keyboard.JustDown(this.keys.D)){ 
      const now = this.time.now;
      // Check for double-tap dash
      if(now - this.lastRightPress < this.doubleTapWindow) {
        // Cancel the previous move and dash from original position (like touch controls)
        if (this.laneBeforeKeyboardMove !== undefined && this.isMoving) {
          // Kill ALL tweens to prevent move animations from continuing
          this.tweens.killTweensOf(this.player);
          
          // Reset to original lane AND position
          this.playerLane = this.laneBeforeKeyboardMove;
          this.player.x = this._laneX(this.playerLane);
          this.player.setScale(1, 1);
          this.isMoving = false;
        }
        this.dashRight();
        this.lastRightPress = 0; // Reset to prevent triple-tap
        this.laneBeforeKeyboardMove = undefined; // Clear the saved lane
      } else {
        this.laneBeforeKeyboardMove = this.playerLane; // Save current lane before move
        this.moveRight();
        this.lastRightPress = now;
      }
    }
    
    // Rubber band effect - pull player back if off-screen too long
    if(this.playerLane < 0 || this.playerLane >= LANES){
      this.offScreenTimer -= dt;
      if(this.offScreenTurnDelay > 0) {
        this.offScreenTurnDelay -= dt;
      }
      
      // Apply distortion effects when off-screen
      // Screen shake intensity based on how long off-screen
      const shakeIntensity = Math.max(0, 1 - (this.offScreenTimer / 800)) * 4;
      this.cameras.main.shake(100, shakeIntensity * 0.01);
      
      // Continuous audio distortion pulse while off-screen
      if(!this.offScreenPulse) {
        this.offScreenPulse = 0; // Initialize as timer
      }
      this.offScreenPulse += dt;
      
      // Pulse every 200ms with increasing intensity
      if(this.offScreenPulse > 200) {
        this.offScreenPulse = 0;
        try {
          // Low frequency pulse that gets more intense over time
          const intensity = Math.max(0, 1 - (this.offScreenTimer / 800));
          const freq = 50 + intensity * 30; // Lower frequency as timer runs out
          gameSounds.offScreenWomp.triggerAttackRelease(freq, "16n", Tone.now(), 0.2 + intensity * 0.3);
        } catch(e) {}
      }
      
      // Add chromatic aberration effect via camera tint
      if(this.playerLane < 0) {
        // Left side - cyan/red split
        this.cameras.main.setPostPipeline('ChromaticAberration');
      } else {
        // Right side - magenta/green split  
        this.cameras.main.setPostPipeline('ChromaticAberration');
      }
      
      // Visual warning - increase shake as timer runs out
      if(this.offScreenTimer < 300){
        this.cameras.main.shake(100, 0.02);
      }
      // Pull back when timer expires
      if(this.offScreenTimer <= 0){
        // Store the off-screen position for animation
        const fromX = this.player.x;
        
        if(this.playerLane < 0){
          this.playerLane = 0;
        } else if(this.playerLane >= LANES){
          this.playerLane = LANES - 1;
        }
        
        const targetX = this._laneX(this.playerLane);
        
        // Rubber band snap animation - overshoot then settle
        this.tweens.add({
          targets: this.player,
          x: targetX,
          duration: 300,
          ease: 'Back.easeOut', // Elastic overshoot effect
          onStart: () => {
            // Stretch effect during snap
            this.player.setScale(1.5, 0.7); // Stretch horizontally, squash vertically
          },
          onComplete: () => {
            // Bounce settle animation
            this.tweens.add({
              targets: this.player,
              scaleX: 1,
              scaleY: 1,
              duration: 200,
              ease: 'Bounce.easeOut'
            });
          }
        });
        
        // Spin the player during snap-back
        this.tweens.add({
          targets: this.player,
          angle: 360,
          duration: 300,
          ease: 'Power2'
        });
        
        // Restore power-up tint if active
        if(this.rapidFire) {
          this.player.setTint(0x00ff00);
        } else {
          this.player.clearTint();
        }
        this.player.setAlpha(1); // Restore full opacity
        this.offScreenPulse = false; // Reset audio pulse flag
        // Rubber band snap sound
        try {
          gameSounds.move.triggerAttackRelease("C3", "16n");
        } catch(e) {}
      }
    } else {
      // Clear any warning tint and effects when back in bounds
      if(!this.rapidFire) this.player.clearTint();
      this.offScreenPulse = false; // Reset audio pulse flag
      // Reset camera effects
      this.cameras.main.resetPostPipeline();
    }
    
    // Crouch/charge mechanic for super jump - hold DOWN to charge, release to jump
    // Allow charging even while jumping to queue next super jump
    if(this.playerCanControl && (this.keys.DOWN.isDown || this.keys.S.isDown)){
      if(!this.isCrouching) {
        this.isCrouching = true;
        this.crouchTimer = 0;
        this.chargeGlow.setVisible(true);
        
        // Start charge sound with rising pitch
        try {
          gameSounds.jumpCharge.triggerAttack("C2");
          // Create a rising pitch ramp
          gameSounds.jumpCharge.frequency.rampTo(440, this.maxChargeTime / 1000);
        } catch(e) {}
        
        // Squash animation when crouching (only if on ground)
        if (!this.isJumping) {
          this.tweens.add({
            targets: this.player,
            scaleX: 1.4,
            scaleY: 0.6,
            duration: 100,
            ease: 'Power2'
          });
        }
      }
      this.crouchTimer += dt;
      
      // Update charge glow
      const chargePercent = Math.min(this.crouchTimer / this.maxChargeTime, 1.0);
      this.chargeGlow.clear();
      this.chargeGlow.x = this.player.x;
      this.chargeGlow.y = this.player.y;
      
      // Draw growing glow circle - match touch control max size
      const pulse = Math.sin(this.time.now * (10 + chargePercent * 20) * 0.001) * 0.2 + 0.8;
      const glowRadius = 30 + chargePercent * 50 * pulse; // Same as touch: 30-80 range
      const glowAlpha = 0.3 + chargePercent * 0.5 * pulse; // Same as touch
      const glowColor = Phaser.Display.Color.Interpolate.ColorWithColor(
        {r: 0, g: 255, b: 204}, // Start cyan
        {r: 255, g: 255, b: 0}, // End yellow
        1,
        chargePercent
      );
      const hexColor = Phaser.Display.Color.GetColor(glowColor.r, glowColor.g, glowColor.b);
      
      this.chargeGlow.fillStyle(hexColor, glowAlpha);
      this.chargeGlow.fillCircle(0, 0, glowRadius);
    } else if(this.isCrouching) {
      // Released DOWN - execute super jump immediately
      const chargePercent = Math.min(this.crouchTimer / this.maxChargeTime, 1.0);
      
      // Stop the charge sound
      try {
        gameSounds.jumpCharge.triggerRelease();
      } catch(e) {}
      
      // Execute super jump if on ground, or queue if airborne
      if (!this.isJumping) {
        this.superJump(chargePercent);
      } else {
        // Queue the super jump to execute on landing
        this.queuedSuperJumpCharge = chargePercent;
      }
      this.isCrouching = false;
      this.crouchTimer = 0;
      this.chargeGlow.setVisible(false);
    }
    
    // Regular jump mechanic - UP or W key (only if not crouching)
    if(this.playerCanControl && (Phaser.Input.Keyboard.JustDown(this.keys.UP) || Phaser.Input.Keyboard.JustDown(this.keys.W)) && !this.isCrouching){
      this.jump();
    }
    
    // Firing - keyboard space or touch hold
    if(this.keys.SPACE.isDown || this.isTouchFiring) {
      // Track keyboard if space is pressed
      if(this.keys.SPACE.isDown && (window.controlType === 'unknown' || window.controlType === 'touch')) {
        window.controlType = 'keyboard';
        trackEvent('control_type_detected', {
          type: 'keyboard',
          platform: /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ? 'mobile' : 'desktop'
        });
      }
      this._fire();
    }

    // Update enemies with perspective
    const vanishY = HEIGHT * 0.15;
    for(let i=this.enemies.length-1; i>=0; i--){
      const e=this.enemies[i]; 
      
      // Move along perspective curve - add pulse shift
      e.progress += (e.vy * dt/1000) / (HEIGHT * 0.8) + pulseShift;
      
      // Handle drifting enemies
      if(e.isDrifter){
        e.driftTimer += dt;
        if(e.driftTimer > 1000){ // Change lane every second
          e.driftTimer = 0;
          e.targetLane = Phaser.Math.Between(0, LANES-1);
        }
        // Smoothly interpolate to target lane
        const laneDiff = e.targetLane - e.lane;
        if(Math.abs(laneDiff) > 0.1){
          e.lane += laneDiff * 0.05;
        }
      }
      
      // Calculate position on exponential curve (same as grid)
      const y = vanishY + (HEIGHT - vanishY) * Math.pow(e.progress, 2.5);
      e.y = y;
      
      // Update X position along perspective lane + pulse shift
      e.x = this._laneX(e.lane, e.progress) + pulseXShift;
      
      // Check if enemy should be in front or behind obstacles based on progress
      // Find the closest obstacle ahead in the same lane
      let closestObstacleAhead = null;
      let minDistance = Infinity;
      
      for(let obstacle of this.obstacles) {
        if(Math.floor(obstacle.lane) === Math.floor(e.lane)) {
          // Only consider obstacles that are ahead or at same position
          if(obstacle.progress >= e.progress) {
            const distance = obstacle.progress - e.progress;
            if(distance < minDistance) {
              minDistance = distance;
              closestObstacleAhead = obstacle;
            }
          }
        }
      }
      
      // If there's an obstacle ahead in our lane, be behind it
      // Otherwise be in front (we've passed all obstacles in our lane)
      e.setDepth(closestObstacleAhead ? 80 : 180); // 80 = behind obstacles, 180 = in front
      
      // Add position to trail history
      if(!e.trailPoints) e.trailPoints = [];
      e.trailPoints.push({x: e.x, y: e.y, alpha: 1.0});
      if(e.trailPoints.length > 8) e.trailPoints.shift(); // Keep trail short
      
      // Scale based on distance
      let scale = 0.1 + e.progress * 1.2; // Start tiny, grow to normal size
      
      // Apply pulse effect for all enemy types
      if(e.pulseTime) {
        const timeSincePulse = this.time.now - e.pulseTime;
        if(timeSincePulse < 300) { // Pulse lasts 300ms
          const pulseProgress = 1 - (timeSincePulse / 300);
          const pulseMagnitude = Math.sin(pulseProgress * Math.PI) * 0.5;
          scale *= (1 + pulseMagnitude);
          
          // Different tint colors based on enemy type
          if(e.isDrifter) {
            // Purple enemies - flash with purple-white
            const tintValue = Math.floor(255 * (1 - pulseProgress * 0.5));
            e.setTint(Phaser.Display.Color.GetColor(255, tintValue, 255));
          } else if(e.enemyType === 'fastEnemyTex') {
            // Yellow enemies - flash with yellow-white
            const tintValue = Math.floor(255 * (1 - pulseProgress * 0.3));
            e.setTint(Phaser.Display.Color.GetColor(255, 255, tintValue));
          } else if(e.enemyType === 'enemyTex') {
            // Red enemies - flash with red-white
            const tintValue = Math.floor(255 * (1 - pulseProgress * 0.5));
            e.setTint(Phaser.Display.Color.GetColor(255, tintValue, tintValue));
          }
        } else {
          e.setTint(0xffffff); // Reset tint
        }
      }
      
      e.setScale(scale);
      
      // Update collision box
      if(e.isDrifter) {
        // Drifters have tighter collision boxes (70% of visual size)
        e.w = e.baseSize * scale * 0.7;
        e.h = e.baseSize * scale * 0.7;
      } else {
        e.w = e.baseSize * scale;
        e.h = e.baseSize * scale;
      }
      
      // Remove or check collision (can't hit while jumping or stretching)
      // 3D collision: enemies only collide when near player (0.94-0.97), can step behind them after
      if(e.progress > 1.1){ e.destroy(); this.enemies.splice(i,1); }
      else if(e.progress > 0.94 && e.progress < 0.97 && !this.isJumping && !this.isStretching && !this.isInvincible && this._aabb(e, this.player)){ 
        // Set invincible immediately to prevent multiple deaths
        this.isInvincible = true;
        
        // Save highscore before restarting
        if(this.score > sessionHighScore) {
          sessionHighScore = this.score;
        }
        
        // Create dramatic explosion for enemy hit with proper scale
        const enemyScale = 0.1 + e.progress * 1.2; // Same formula as enemy scaling
        this._createDeathExplosion(this.player.x, this.player.y, e.x, e.y, enemyScale);
        
        try {
          // Player death sound - descending pitch
          const now = Tone.now();
          gameSounds.obstacleHit.triggerAttackRelease("G2", "16n", now);
          gameSounds.obstacleHit.triggerAttackRelease("D2", "16n", now + 0.05);
          gameSounds.obstacleHit.triggerAttackRelease("G1", "16n", now + 0.1);
          gameSounds.explosion.triggerAttackRelease("8n", now + 0.02);
        } catch(e) {}
        
        // Hide player and enemy immediately
        this.player.setVisible(false);
        e.destroy();
        
        // Show game over screen
        this.showGameOverScreen();
      }
    }
    
    // Update floating stars
    for(let i=this.floatingStars.length-1; i>=0; i--){
      const star = this.floatingStars[i];
      
      // Check if the attached obstacle still exists and is active
      const obstacle = star.attachedObstacle;
      const obstacleExists = obstacle && obstacle.active && this.obstacles.includes(obstacle);
      
      if(obstacleExists) {
        // Follow the obstacle position
        const scale = 0.1 + obstacle.progress * 1.2;
        
        // Floating motion (up and down)
        star.floatOffset += star.floatSpeed * dt;
        const floatY = Math.sin(star.floatOffset) * 10;
        
        // Position above obstacle with floating offset (scaled with perspective)
        star.x = obstacle.x;
        star.y = obstacle.y - (60 * scale) + floatY; // Scale the offset with perspective
        star.setScale(scale); // Just use obstacle's scale for perspective
        
        // Spin the star
        star.rotation += star.rotationSpeed;
        
        // Check collection - player must be jumping and in the same lane
        // Uses same collision timing as obstacles (0.94-0.97) so you collect the star
        // at the exact moment you'd hit the obstacle if you weren't jumping
        if(!star.collected && this.isJumping && obstacle.lane === this.playerLane) {
          // Same collision window as obstacles
          if(obstacle.progress > 0.94 && obstacle.progress < 0.97) {
            // Collect the star!
            star.collected = true;
            this.score += 50;
            this.combo = Math.min(this.combo + 1, 8);
            this.lastKillTime = this.time.now;
            this.scoreText.setText(this.score.toString());
            
            // Track for tutorial
            if (this.isTutorial) {
              this.tutorialProgress.starsCollected++;
            }
            
            // Show combo text
            if(this.combo > 1) {
              this.comboText.setText(`${this.combo}x COMBO! +50`);
              this.comboText.setAlpha(1);
            }
            
            // Instantly hide the star
            star.visible = false;
            
            // Classic coin collection sound - ascending arpeggio
            try {
              const coinSound = new Tone.Synth({
                oscillator: { type: "square" },
                envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
              }).connect(reverb);
              
              // Classic coin pickup sound - quick ascending notes
              const now = Tone.now();
              coinSound.triggerAttackRelease("B5", "32n", now);
              coinSound.triggerAttackRelease("E6", "32n", now + 0.03);
              
              setTimeout(() => coinSound.dispose(), 300);
            } catch(e) {
            }
            
            // Create star explosion particles
            for(let j = 0; j < 8; j++) {
              const angle = (Math.PI * 2 * j) / 8;
              const speed = 200 + Math.random() * 100;
              
              const particle = this.add.image(star.x, star.y, 'starTex');
              particle.setScale(0.3);
              particle.setDepth(999);
              
              const destX = star.x + Math.cos(angle) * speed;
              const destY = star.y + Math.sin(angle) * speed;
              
              this.tweens.add({
                targets: particle,
                x: destX,
                y: destY,
                scale: 0,
                alpha: 0,
                rotation: Math.random() * Math.PI * 4,
                duration: 600,
                ease: 'Power2',
                onComplete: () => particle.destroy()
              });
            }
            
            // Immediately destroy the star and remove from array
            star.destroy();
            this.floatingStars.splice(i, 1);
          }
        }
        
        // Remove star if obstacle is gone off-screen
        if(obstacle.progress > 1.1) {
          star.destroy();
          this.floatingStars.splice(i, 1);
        }
      } else {
        // Obstacle was destroyed or doesn't exist, remove orphaned star
        star.destroy();
        this.floatingStars.splice(i, 1);
      }
    }
    
    // Update obstacles
    for(let i=this.obstacles.length-1; i>=0; i--){
      const o=this.obstacles[i];
      o.progress += (o.vy * dt/1000) / (HEIGHT * 0.8) + pulseShift;
      const y = vanishY + (HEIGHT - vanishY) * Math.pow(o.progress, 2.5);
      o.y = y;
      o.x = this._laneX(o.lane, o.progress) + pulseXShift;
      const scale = 0.1 + o.progress * 1.2;
      o.setScale(scale, scale * 1.2); // Much taller shields
      o.w = o.baseSize * scale;
      o.h = 22 * scale * 1.2; // Adjusted height for collision
      
      // Animate the whole obstacle with shimmer effect on the barrier part
      if (!o.shimmerTime) o.shimmerTime = 0;
      o.shimmerTime += dt * 0.004; // Slow shimmer
      let shimmerAlpha = 0.85 + Math.sin(o.shimmerTime + o.progress * 3) * 0.15;
      
      // Add electric pulse effect on hi-hat beats
      if(o.pulseTime) {
        const timeSincePulse = this.time.now - o.pulseTime;
        if(timeSincePulse < 200) { // Shorter, sharper pulse for electric effect
          const pulseProgress = 1 - (timeSincePulse / 200);
          const pulseMagnitude = Math.sin(pulseProgress * Math.PI);
          
          // Scale pulse - make shield "surge" with electricity
          const pulseScale = 1 + pulseMagnitude * 0.3;
          o.setScale(scale * pulseScale, scale * 1.2 * pulseScale);
          
          // Bright electric flash - purple to white
          const flashIntensity = pulseMagnitude;
          const tintR = 191 + (64 * flashIntensity); // 191 -> 255
          const tintG = 64 + (191 * flashIntensity);  // 64 -> 255  
          const tintB = 255; // Keep full blue
          o.setTint(Phaser.Display.Color.GetColor(tintR, tintG, tintB));
          
          // Boost alpha for electric surge
          shimmerAlpha = Math.min(1, shimmerAlpha + pulseMagnitude * 0.3);
        } else {
          o.clearTint(); // Reset tint after pulse
        }
      }
      
      o.setAlpha(shimmerAlpha);
      
      // Check collision with player (can jump over obstacles!)
      // 3D collision: obstacles only collide when near player (0.94-0.97), can step behind them after
      if(o.progress > 0.94 && o.progress < 0.97 && o.lane === this.playerLane) {
        if (this.isJumping || this.isStretching) {
          // Successfully jumped over obstacle - track for tutorial
          if (this.isTutorial && !o.tutorialCounted) {
            o.tutorialCounted = true; // Only count once per obstacle
            this.tutorialProgress.jumpsMade++;
          }
        } else if (!this.isInvincible) {
          // Hit obstacle - game over
          // Set invincible immediately to prevent multiple deaths
          this.isInvincible = true;
          
          // Save highscore before restarting
          if(this.score > sessionHighScore) {
            sessionHighScore = this.score;
          }
          
          // Create splat effect for hitting wall
          this._createSplatEffect(this.player.x, this.player.y);
          
          try {
            // Low impact thud with pitch bend down
            gameSounds.obstacleHit.triggerAttackRelease("C2", "8n");
            gameSounds.explosion.triggerAttackRelease("8n");
          } catch(e) {}
          
          // Show game over screen
          this.showGameOverScreen();
          
          // Clean up any stars attached to this obstacle
          for(let j = this.floatingStars.length - 1; j >= 0; j--) {
            if(this.floatingStars[j].attachedObstacle === o) {
              this.floatingStars[j].destroy();
              this.floatingStars.splice(j, 1);
            }
          }
        }
      }
      else if(o.progress > 1.1){ 
        // Remove any attached stars before destroying obstacle
        for(let j = this.floatingStars.length - 1; j >= 0; j--) {
          if(this.floatingStars[j].attachedObstacle === o) {
            this.floatingStars[j].destroy();
            this.floatingStars.splice(j, 1);
          }
        }
        o.destroy(); 
        this.obstacles.splice(i,1); 
      }
    }
    
    // Update power-ups
    for(let i=this.powerUps.length-1; i>=0; i--){
      const p=this.powerUps[i];
      p.progress += (p.vy * dt/1000) / (HEIGHT * 0.8) + pulseShift;
      const y = vanishY + (HEIGHT - vanishY) * Math.pow(p.progress, 2.5);
      p.y = y;
      p.x = this._laneX(p.lane, p.progress) + pulseXShift;
      const scale = 0.1 + p.progress * 1.2;
      p.setScale(scale);
      p.angle += dt * 0.2; // Rotate
      
      // Check collection - slightly more forgiving than enemy collision
      if(p.progress > 0.93 && p.progress < 0.98 && p.lane === this.playerLane){
        p.destroy();
        this.powerUps.splice(i,1);
        this.score += 10; // Award 10 points for power-up collection
        this.scoreText.setText(this.score.toString()); // Update score display
        
        // Track for tutorial
        if (this.isTutorial) {
          this.tutorialProgress.powerUpsCollected = (this.tutorialProgress.powerUpsCollected || 0) + 1;
        }
        
        this.rapidFire = true;
        this.rapidFireTimer = 5000; // 5 seconds
        this.player.setTint(0x00ff00); // Green tint
        
        // Add jello wobble reaction for power-up
        this.wobbleVelocity.x = (Math.random() - 0.5) * 20;
        this.wobbleVelocity.y = -15;
        
        // Excited jello bounce animation
        this.tweens.add({
          targets: this.player,
          scaleX: 1.4,
          scaleY: 0.7,
          duration: 100,
          ease: 'Power2',
          yoyo: true,
          repeat: 2,
          onComplete: () => {
            this.tweens.add({
              targets: this.player,
              scaleX: 1,
              scaleY: 1,
              duration: 200,
              ease: 'Elastic.easeOut',
              easeParams: [0.5, 0.3]
            });
          }
        })
        // Play quick arpeggio for power-up
        try {
          const now = Tone.now();
          gameSounds.powerUp.triggerAttackRelease("C5", "32n", now + 0.01);
          gameSounds.powerUp.triggerAttackRelease("E5", "32n", now + 0.05);
          gameSounds.powerUp.triggerAttackRelease("G5", "32n", now + 0.09);
        } catch(e) {}
      } else if(p.progress > 1.1){
        p.destroy();
        this.powerUps.splice(i,1);
      }
    }
    
    // Update rapid fire timer
    if(this.rapidFire){
      this.rapidFireTimer -= dt;
      if(this.rapidFireTimer <= 0){
        this.rapidFire = false;
        this.player.clearTint();
      }
    }

    // Update bullets with perspective
    for(let i=this.bullets.length-1; i>=0; i--){
      const b=this.bullets[i]; 
      
      if(b.isHorizontal) {
        // Horizontal bullet movement across lanes
        b.currentLane += (b.vx * dt/1000) / 150; // Convert speed to lane units
        b.lane = Math.floor(b.currentLane + 0.5); // Round to nearest lane for collision
        
        // Update position using current lane and constant progress
        b.x = this._laneX(b.currentLane, b.progress);
        b.y = vanishY + (HEIGHT - vanishY) * Math.pow(b.progress, 2.5);
        
        // Remove if bullet has crossed all lanes
        if((b.vx > 0 && b.currentLane > 5) || (b.vx < 0 && b.currentLane < -1)) {
          b.destroy(); 
          this.bullets.splice(i,1); 
          continue;
        }
      } else {
        // Normal vertical bullet movement
        // Move backward along perspective curve
        b.progress -= (Math.abs(b.vy) * dt/1000) / (HEIGHT * 0.8);
        
        // Calculate base position on exponential curve
        let y = vanishY + (HEIGHT - vanishY) * Math.pow(b.progress, 2.5);
        
        // Apply arc trajectory if this is a jump shot
        if(b.isArcShot) {
          // Update arc distance based on bullet speed
          b.arcDistance += (Math.abs(b.vy) * dt/1000) / (HEIGHT * 0.8);
          const distanceTraveled = b.arcDistance;
          const normalY = vanishY + (HEIGHT - vanishY) * Math.pow(b.progress, 2.5);
          const normalStartY = vanishY + (HEIGHT - vanishY) * Math.pow(1.0, 2.5); // Where normal bullets start
          const perspectiveOffset = normalStartY - PLAYER_Y; // How much the curve differs from player position
          const jumpHeight = PLAYER_Y - b.startY; // Positive when jumping
          
          // Log first frame of arc shot
          if (!b.arcLogged) {
            b.arcLogged = true;
          }
          
          if (distanceTraveled < b.safeDistance) {
            // Draw straight line from A to B
            const arcProgress = distanceTraveled / b.safeDistance;
            
            // Point A: player position when fired
            const pointA = b.startY;
            
            // Point B: After traveling safeDistance from progress 1.0
            // The bullet will be at progress (1.0 - safeDistance)
            // But we need to calculate where that is in screen Y
            const progressAtB = 1.0 - b.safeDistance;
            // This is the Y position for that progress value on the perspective curve
            const pointB = vanishY + (HEIGHT - vanishY) * Math.pow(progressAtB, 2.5);
            
            // Linear interpolation from A to B
            y = pointA + (pointB - pointA) * arcProgress;
            
            // Check at boundary
            if (arcProgress > 0.99 && !b.boundaryChecked) {
              const arcEndY = pointA + (pointB - pointA) * 1.0; // Where arc ends (should be pointB)
              const nextFrameProgress = b.progress - (Math.abs(b.vy) * dt/1000) / (HEIGHT * 0.8);
              const nextFrameY = vanishY + (HEIGHT - vanishY) * Math.pow(nextFrameProgress, 2.5) - perspectiveOffset;
              b.boundaryChecked = true;
            }
            
            // Log near transition
            if (arcProgress > 0.98 && !b.almostTransition) {
              const arcEndY = pointA + (pointB - pointA) * 1.0; // Where arc ends (should equal pointB)
              const normalStartProgress = 1.0 - b.safeDistance;
              const normalStartY = vanishY + (HEIGHT - vanishY) * Math.pow(normalStartProgress, 2.5) - perspectiveOffset;
              b.almostTransition = true;
            }
          } else {
            // After safeDistance: Arc shots don't need perspective offset
            y = normalY;
            b.isArcShot = false;
          }
        }
        
        b.y = y;
        
        // Update X position along perspective lane
        b.x = this._laneX(b.lane, b.progress);
        
        if(b.progress < 0){ b.destroy(); this.bullets.splice(i,1); continue; }
      }
      
      // Add bullet trail
      if(!b.trailPoints) b.trailPoints = [];
      b.trailPoints.push({x: b.x, y: b.y, alpha: 1.0});
      if(b.trailPoints.length > 6) b.trailPoints.shift();
      
      // Calculate rotation to align with trajectory
      if(!b.isHorizontal) {
        const deltaX = b.x - b.lastX;
        const deltaY = b.y - b.lastY;
        
        // Only update rotation if bullet has moved
        if(Math.abs(deltaX) > 0.1 || Math.abs(deltaY) > 0.1) {
          // Calculate angle from movement direction
          let angle = Math.atan2(deltaY, deltaX) + Math.PI/2; // Add 90 degrees since bullet sprite points up
          
          // For arc shots, add some visual flair
          if(b.isArcShot) {
            // Slight wobble on arc shots
            angle += Math.sin(b.progress * Math.PI * 4) * 0.1;
          }
          
          b.setRotation(angle);
          b.lastX = b.x;
          b.lastY = b.y;
        }
        
        // Add spinning effect for high combo bullets
        if(b.rotationSpeed) {
          b.rotation += b.rotationSpeed;
        }
      }
      
      // Scale based on distance
      const scale = 0.1 + b.progress * 1.2;
      b.setScale(scale);
      
      // Check collision with obstacles first
      let hitObstacle = false;
      for(let j=this.obstacles.length-1; j>=0; j--){
        const o = this.obstacles[j];
        if(o.lane === b.lane && Math.abs(o.progress - b.progress) < 0.05){
          // Arc shots pass over obstacles during safe distance
          if(b.isArcShot) {
            const distanceTraveled = 1.0 - b.progress;
            if(distanceTraveled < b.safeDistance) {
              continue; // Bullet is in safe flight, skip collision
            }
          }
          
          // Bullet hits obstacle - small spark effect (obstacles don't scale)
          this._createExplosion(b.x, b.y, 0xffff00, 4, 0.5);
          b.destroy(); 
          this.bullets.splice(i,1);
          hitObstacle = true;
          
          // Obstacle block sound - metallic ping
          try {
            gameSounds.move.triggerAttackRelease("C7", "64n");
          } catch(e) {}
          break; // Obstacle blocks the shot
        }
      }
      
      // Check collision with enemies if not blocked
      if(!hitObstacle){
        for(let j=this.enemies.length-1; j>=0; j--){
          const e = this.enemies[j];
          // Check if in same lane and close in progress
          // Drifters require more precise timing due to lane-changing movement
          const progressThreshold = e.isDrifter ? 0.03 : 0.05; // Tighter window for drifters
          const laneThreshold = e.isDrifter ? 0.3 : 0.5; // More precise lane alignment needed
          if(Math.abs(e.lane - b.lane) < laneThreshold && Math.abs(e.progress - b.progress) < progressThreshold){
            // Calculate enemy scale for explosion
            const enemyScale = 0.1 + e.progress * 1.2; // Same formula as enemy scaling
            
            // Create explosion at enemy position with proper scale
            const explosionColor = e.isDrifter ? 0x9966ff : (e.enemyType === 'fastEnemyTex' ? 0xffff00 : 0xff3366);
            this._createExplosion(e.x, e.y, explosionColor, e.isDrifter ? 12 : 8, enemyScale);
            
            b.destroy(); this.bullets.splice(i,1);
            e.destroy(); this.enemies.splice(j,1);
            
            // Track for tutorial
            if (this.isTutorial) {
              this.tutorialProgress.shotsHit++;
              // Track arc shots specifically
              if (b.isArcShot) {
                this.tutorialProgress.arcShotsHit = (this.tutorialProgress.arcShotsHit || 0) + 1;
              }
              this.updateTutorialProgress();
            }
            
            // Differentiated scoring based on enemy type
            let basePoints = 10; // Default for red enemies
            if(e.isDrifter) {
              basePoints = 50; // Purple drifters worth most
            } else if(e.enemyType === 'fastEnemyTex') {
              basePoints = 25; // Yellow fast enemies worth more
            }
            
            // Check for combo
            const currentTime = this.time.now;
            if(currentTime - this.lastKillTime < this.comboWindow) {
              // Within combo window - increase multiplier
              this.combo = Math.min(this.combo + 1, this.maxCombo);
            } else {
              // Combo expired - reset to 1
              this.combo = 1;
            }
            this.lastKillTime = currentTime;
            
            // Apply combo multiplier
            const points = basePoints * this.combo;
            this.score += points;
            this.scoreText.setText(this.score.toString());
            
            // Show combo text with animation
            if(this.combo > 1) {
              this.comboText.setText(`${this.combo}x COMBO! +${points}`);
              this.comboText.setAlpha(1);
              // Pulse effect based on combo level
              const comboColor = this.combo >= 6 ? '#ff00ff' : this.combo >= 4 ? '#ffff00' : '#00ffff';
              this.comboText.setColor(comboColor);
              this.comboText.setScale(1 + (this.combo * 0.05));
              
              // Fade out combo text
              this.tweens.add({
                targets: this.comboText,
                alpha: 0,
                scale: 1,
                duration: 1000,
                ease: 'Power2'
              });
              
              // Screen flash for high combos
              if(this.combo >= 4) {
                const flash = this.add.graphics();
                flash.fillStyle(this.combo >= 6 ? 0xff00ff : 0xffff00, 0.3);
                flash.fillRect(0, 0, WIDTH, HEIGHT);
                this.tweens.add({
                  targets: flash,
                  alpha: 0,
                  duration: 200,
                  onComplete: () => flash.destroy()
                });
              }
              
              // Bonus sound effects for combo milestones
              if(this.combo === 4 || this.combo === 6 || this.combo === 8) {
                try {
                  const now = Tone.now();
                  // Ascending arpeggio for combo milestone
                  gameSounds.powerUp.triggerAttackRelease("C4", "32n", now);
                  gameSounds.powerUp.triggerAttackRelease("E4", "32n", now + 0.05);
                  gameSounds.powerUp.triggerAttackRelease("G4", "32n", now + 0.1);
                  gameSounds.powerUp.triggerAttackRelease("C5", "32n", now + 0.15);
                } catch(e) {}
              }
            }
            // Update highscore if beaten
            if(this.score > sessionHighScore) {
              sessionHighScore = this.score;
              saveGameData({ highScore: sessionHighScore });
              this.highScoreText.setText(sessionHighScore.toString());
              this.highScoreText.setColor('#0ff'); // Cyan when beating high score
            }
            
            // Play destruction sound based on enemy type with pitch variation
            try {
              const now = Tone.now();
              if(e.isDrifter){
                // Drifter destruction - descending stab chord
                gameSounds.powerUp.triggerAttackRelease("G4", "32n", now);
                gameSounds.powerUp.triggerAttackRelease("D4", "32n", now + 0.02);
                gameSounds.powerUp.triggerAttackRelease("A3", "32n", now + 0.04);
              } else if(e.enemyType === 'fastEnemyTex'){
                // Fast enemy - high pitched noise burst
                gameSounds.explosion.triggerAttackRelease("32n", now);
                gameSounds.enemyDestroy.triggerAttackRelease("G5", "32n", now + 0.01);
              } else {
                // Regular enemy - distorted kick-like sound with random note from scale
                const noteIndex = Math.floor(Math.random() * 7);
                // Add tiny random offset to each sound to prevent exact timing conflicts
                const offset = Math.random() * 0.005;
                gameSounds.enemyDestroy.triggerAttackRelease(getGameNote(noteIndex) + "3", "16n", now + offset);
                gameSounds.explosion.triggerAttackRelease("32n", now + 0.015 + offset);
              }
            } catch(err) {
              // Timing conflict - sounds will be skipped this frame
            }
            break;
          }
        }
      }
    }

  }
  
  resize(gameSize, baseSize, displaySize, resolution) {
    // Update global dimensions using the actual camera dimensions
    WIDTH = this.cameras.main.width;
    HEIGHT = this.cameras.main.height;
    LANE_W = WIDTH / LANES;
    PLAYER_Y = HEIGHT - (isMobile ? 90 : 60);
    isLandscape = WIDTH > HEIGHT;
    MOBILE_SCALE = isMobile ? (isLandscape ? 1.2 : 1.5) : 1;
    
    // Update vanishing point for consistent perspective
    this.vanishX = WIDTH / 2;
    this.vanishY = HEIGHT * 0.15;
    
    // Update player position
    if (this.player) {
      this.player.x = this._laneX(this.playerLane);
      this.player.y = PLAYER_Y;
    }
    
    // Update UI text positions
    const scoreY = isMobile ? HEIGHT-36 : HEIGHT-24;
    const highScoreY = isMobile ? HEIGHT-72 : HEIGHT-48;
    const comboY = isMobile ? HEIGHT-108 : HEIGHT-72;
    
    // Update score label and value positions
    if (this.scoreLabel) {
      this.scoreLabel.y = scoreY;
    }
    if (this.scoreText) {
      this.scoreText.y = scoreY;
    }
    
    // Update high score label and value positions
    if (this.highScoreLabel) {
      this.highScoreLabel.y = highScoreY;
    }
    if (this.highScoreText) {
      this.highScoreText.y = highScoreY;
    }
    
    if (this.comboText) {
      this.comboText.y = comboY;
    }
    
    // Update combo meter position
    if (this.comboMeterBg) {
      const meterY = comboY + 30;
      this.comboMeterY = meterY;
      this.comboMeterBg.clear();
      this.comboMeterBg.fillStyle(0x333333, 0.5);
      this.comboMeterBg.fillRect(10, meterY, 200, 8);
    }
    
    // Recreate starfield with new dimensions
    if (this.stars) {
      this.createStarfield();
    }
    
    // Update grid if visible
    if (this.gridVisible && this.gridGraphics) {
      this._drawPerspectiveGrid();
    }
    
    // Update mobile controls positions if they exist
    if (this.mobileControls) {
      this.setupMobileControls();
    }
  }
  
  updateTrails(dt) {
    this.trailGraphics.clear();
    
    // Draw enemy trails
    for(let enemy of this.enemies) {
      if(enemy.trailPoints && enemy.trailPoints.length > 1) {
        for(let i = 0; i < enemy.trailPoints.length - 1; i++) {
          const point = enemy.trailPoints[i];
          const nextPoint = enemy.trailPoints[i + 1];
          
          // Fade trail based on position in array
          const alpha = (i / enemy.trailPoints.length) * 0.5;
          point.alpha = alpha;
          
          // Choose color based on enemy type
          let color = 0xff3366; // Default red
          if(enemy.enemyType === 'fastEnemyTex') color = 0xffff00;
          else if(enemy.isDrifter) color = 0xff00ff;
          
          this.trailGraphics.lineStyle(2, color, alpha);
          this.trailGraphics.lineBetween(point.x, point.y, nextPoint.x, nextPoint.y);
        }
      }
    }
    
    // Draw bullet trails
    for(let bullet of this.bullets) {
      if(bullet.trailPoints && bullet.trailPoints.length > 1) {
        for(let i = 0; i < bullet.trailPoints.length - 1; i++) {
          const point = bullet.trailPoints[i];
          const nextPoint = bullet.trailPoints[i + 1];
          
          const alpha = (i / bullet.trailPoints.length) * 0.7;
          
          // Cyan trails for bullets, yellow if arc shot
          const color = bullet.isArcShot ? 0xffff00 : 0x00ffff;
          
          this.trailGraphics.lineStyle(1, color, alpha);
          this.trailGraphics.lineBetween(point.x, point.y, nextPoint.x, nextPoint.y);
        }
      }
    }
  }
}

// Initialize Phaser game with proper scale configuration
const game = new Phaser.Game({
  type: Phaser.AUTO,
  parent: 'gameContainer',
  scene: [StartupScene, Main],
  scale: {
    mode: Phaser.Scale.RESIZE,
    parent: 'gameContainer',
    width: window.visualViewport ? window.visualViewport.width : window.innerWidth,
    height: window.visualViewport ? window.visualViewport.height : window.innerHeight,
    autoCenter: Phaser.Scale.CENTER_BOTH
  }
});

// Wait for game to be fully initialized before setting up resize handlers
setTimeout(() => {
  // Register the resize handler on the scale manager
  if (game && game.scale) {
    // This is the proper way to listen for Phaser resize events
    game.scale.on('resize', (gameSize) => {
      const mainScene = game.scene.getScene('Main');
      if (mainScene && mainScene.resize) {
        mainScene.resize(gameSize);
      }
    });
    
    // Also add a window resize listener as backup
    window.addEventListener('resize', () => {
      if (game && game.scale) {
        game.scale.refresh();
      }
    });
    
    // Handle visual viewport changes (mobile browser UI showing/hiding)
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', () => {
        if (game && game.scale) {
          game.scale.refresh();
        }
      });
    }
    
    // Check orientation changes
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        if (game && game.scale) {
          game.scale.refresh();
        }
      }, 100);
    });
  }
}, 500); // Give more time for initialization

// Register service worker for PWA
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('sw.js')
      .then(registration => {
      })
      .catch(error => {
      });
  });
}

// Removed - now handled by Phaser's scale manager
</script>
</body>
</html>